/** ****************************************************************************

                    Huawei Technologies Sweden AB (C), 2001-2015

 ********************************************************************************
 * @author    Automatically generated by DAISY
 * @version
 * @date      2015-08-28
 * @file
 * @brief
 * This interface carries message units and channel control parameters from
 * 1x_Layer_2 to be encoded. It includes:
 * Input: Primitive including reference to data stream. Frequency: Once per
 * frame to be encoded.
 * @copyright Huawei Technologies Sweden AB
 *******************************************************************************/
#ifndef CSDR_1X_ENCDATA_PIF_H
#define CSDR_1X_ENCDATA_PIF_H

/*******************************************************************************
 1. Other files included
*******************************************************************************/
#include "uphy_type_define.h"
#include "csdr_1x_data_public_pif.h"

#ifdef __cplusplus
#if __cplusplus
    extern "C" {
#endif /* __cpluscplus */
#endif /* __cpluscplus */
#pragma pack(4)

/*******************************************************************************
 2. Macro definitions
*******************************************************************************/

/**
 * per segment maximum size in per segment in octet in a ACH probe, then
 * transfer into 16-bit for DSP
 * 32-bit align(88bit) = 96bit, 16-bit-occupied(96 bit) = 6*uint16
 */
#define CSDR_1X_ACH_PER_PROBE_BLK_MAX_SIZE                  ( 6 )
/**
 * per segment maximum size in per segment in 32-bit aligned in an EACH probe,
 * then transfer into 16-bit for DSP
 * 32-bit align(744bit) = 768bit, 16-bit-occupied(768 bit) = 48*uint16
 */
#define CSDR_1X_EACH_PER_PROBE_BLK_MAX_SIZE                 ( 48 )
/**
 * maximum frame size in in 32-bit aligned on R-DCCH, then transfers into
 * 16-bit for DSP
 * 32-bit align(267bit) = 288bit, 16-bit-occupied(288) = 18
 */
#define CSDR_1X_RDCCH_BLK_MAX_SIZE                          ( 18 )
/**
 * maximum frame size in in 32-bit aligned on R-FCH, then transfers into 16-bit
 * for DSP
 * 32-bit align(267bit) = 288bit, 16-bit-occupied(288 bit) = 18*uint16
 */
#define CSDR_1X_RFCH_BLK_MAX_SIZE                           ( 18 )
/**
 * maximum frame size in in 32-bit aligned on R-SCCH, then transfers into
 * 16-bit for DSP
 * 32-bit align(267bit) = 288bit, 16-bit-occupied(288) = 18
 */
#define CSDR_1X_RSCCH_BLK_MAX_SIZE                          ( 18 )
/**
 * maximum frame size in in 32-bit aligned on R-SCH, then transfers into 16-bit
 * for DSP
 * 32-bit align(6120bit) = 6144bit, 16-bit-occupied(6144) = 384
 */
#define CSDR_1X_RSCH_BLK_MAX_SIZE                           ( 384 )
#define CSDR_1X_ESTIMATE_DCCH_BIT_MASK                      ( 0x10 )
#define CSDR_1X_ESTIMATE_FCH_BIT_MASK                       ( 0x2 )
#define CSDR_1X_ESTIMATE_PILOT_BIT_MASK                     ( 0x1 )
#define CSDR_1X_ESTIMATE_SCCH_BIT_MASK                      ( 0x8 )
#define CSDR_1X_ESTIMATE_SCH_BIT_MASK                       ( 0x4 )
/**
 * MAC will write all access channel frames when providing the first frame in a
 * probe. A frame is a block. From figure 2-10. Access Attempt (Part 2) in
 * C.S0003, there are 10 frames at most on ACH.
 */
#define CSDR_1X_MAX_ACH_DATA_BLK_CNT                        ( 10 )
/**
 * MAC will write all enhanced access channel frames when providing the first
 * frame in a probe. A frame is a block. There are 18 blocks at most on EACH,
 * refer to the table blow.
 * _TABLE_bold,border\!45,90\!
 * ACC_RATEs |ACC_FRAME_DURATIONs |ACC_MAX_DURATONs |ACC_RESIDUAL_SIZEs
 * |Information bits |loop cnt\?
 * 9600  |20      |16     |768    |172    |5\?
 * 19200  |10      |16     |1536    |172    |9\?
 * 19200  |20      |16     |1536    |360    |5\?
 * 38400  |20      |16     |3072    |744    |5\?
 * 38400  |10      |16     |3072    |360    |9\?
 * 38400  |5      |16     |3072    |172    |18
 * \!frame count on EACH.
 * _TABLE_
 */
#define CSDR_1X_MAX_EACH_DATA_BLK_CNT                       ( 18 )
/**
 * It's used to calculate how many octet will be occupied in memory for a
 * segment maximum size in a ACH probe.
 */
#define CSDR_1X_ACH_PER_PROBE_BLK_MAX_MEM_OCCUPIED          CTTF_CSDR_1X_MEMORY_OCCUPIED(CSDR_1X_ACH_PER_PROBE_BLK_MAX_SIZE)
/**
 * It's used to calculate how many octet will be occupied in memory for a
 * segment maximum size in a EACH probe.
 */
#define CSDR_1X_EACH_PER_PROBE_BLK_MAX_MEM_OCCUPIED         CTTF_CSDR_1X_MEMORY_OCCUPIED(CSDR_1X_EACH_PER_PROBE_BLK_MAX_SIZE)
/**
 * It's used to calculate how many octet will be occupied in memory for a block
 * maximum size in a R-DCCH frame.
 */
#define CSDR_1X_RDCCH_BLK_MAX_MEM_OCCUPIED                  CTTF_CSDR_1X_MEMORY_OCCUPIED(CSDR_1X_RDCCH_BLK_MAX_SIZE)
/**
 * It's used to calculate how many octet will be occupied in memory for a block
 * maximum size in a R-FCH frame.
 */
#define CSDR_1X_RFCH_BLK_MAX_MEM_OCCUPIED                   CTTF_CSDR_1X_MEMORY_OCCUPIED(CSDR_1X_RFCH_BLK_MAX_SIZE)
/**
 * It's used to calculate how many octet will be occupied in memory for a block
 * maximum size in a R-SCH frame.
 */
#define CSDR_1X_RSCH_BLK_MAX_MEM_OCCUPIED                   CTTF_CSDR_1X_MEMORY_OCCUPIED(CSDR_1X_RSCH_BLK_MAX_SIZE)

/*******************************************************************************
 3. Enumerations declarations
*******************************************************************************/

/** ****************************************************************************
 * Name        : CSDR_1X_ENCDATA_PIF_MSG_TYPE_ENUM_UINT16
 *
 * Description :
 *******************************************************************************/
enum CSDR_1X_ENCDATA_PIF_MSG_TYPE_ENUM
{
    ID_CTTF_CSDR_1X_ACH_TRACE_DATA_REQ                      = 0x0000, /**< @sa CTTF_CSDR_1X_ACH_TRACE_DATA_REQ_STRU */
    ID_CTTF_CSDR_1X_EACH_TRACE_DATA_REQ                     = 0x0001, /**< @sa CTTF_CSDR_1X_EACH_TRACE_DATA_REQ_STRU */
    ID_CTTF_CSDR_1X_FCH_TRACE_DATA_REQ                      = 0x0002, /**< @sa CTTF_CSDR_1X_FCH_TRACE_DATA_REQ_STRU */
    ID_CTTF_CSDR_1X_SCH_TRACE_DATA_REQ                      = 0x0003, /**< @sa CTTF_CSDR_1X_SCH_TRACE_DATA_REQ_STRU */
    ID_CTTF_CSDR_1X_DCCH_TRACE_DATA_REQ                     = 0x0004, /**< @sa CTTF_CSDR_1X_DCCH_TRACE_DATA_REQ_STRU */
    ID_CTTF_CSDR_1X_SCCH_TRACE_DATA_REQ                     = 0x0005, /**< @sa CTTF_CSDR_1X_SCCH_TRACE_DATA_REQ_STRU */
    ID_CSDR_1X_ENCDATA_PIF_MSG_TYPE_ENUM_BUTT               = 0x0006
};
typedef VOS_UINT16 CSDR_1X_ENCDATA_PIF_MSG_TYPE_ENUM_UINT16;

/** ****************************************************************************
 * Name        : CSDR_1X_MUTEX_ENUM_UINT16
 *
 * Description : It's used to indicate whether data has been written or not.
 * The purpose is avoid data is being writing, SDR begins to read data; or SDR
 * is busy on reading data, MAC goes to update data. So when @enMutexFlag is
 * data not existed, MAC can write data. And then MAC sets @enMutexFlag to data
 * existed. Till then, SDR can begin to read data. After read out data, SDR
 * sets @enMutexFlag to data not existed.
 *******************************************************************************/
enum CSDR_1X_MUTEX_ENUM
{
    CSDR_1X_MUTEX_DATA_NOT_EXISTED      = 0x0000,
    CSDR_1X_MUTEX_DATA_EXISTED          = 0x0001,
    CSDR_1X_MUTEX_ENUM_BUTT             = 0x0002
};
typedef VOS_UINT16 CSDR_1X_MUTEX_ENUM_UINT16;

/** ****************************************************************************
 * Name        : CSDR_1X_TX_CTRL_ENUM_UINT16
 *
 * Description : It's used to indicate whether allow MAC to tx data or not.
 * CSDR_1X_ALLOW_TX: allow MAC to tx data, but MAC needs to check which channel
 * can tx data by cfg-id
 * CSDR_1X_NOT_ALLOW_TX: forbidden to tx data on any channel
 *******************************************************************************/
enum CSDR_1X_TX_CTRL_ENUM
{
    CSDR_1X_ALLOW_TX                    = 0x0000,
    CSDR_1X_NOT_ALLOW_TX                = 0x0001,
    CSDR_1X_TX_CTRL_BUTT                = 0x0002
};
typedef VOS_UINT16 CSDR_1X_TX_CTRL_ENUM_UINT16;

/*******************************************************************************
 4. Message Header declaration
*******************************************************************************/

/*******************************************************************************
 5. Message declaration
*******************************************************************************/

/*******************************************************************************
 6. STRUCT and UNION declaration
*******************************************************************************/

/** ****************************************************************************
 * Name        : CTTF_CSDR_1X_R_TCH_ADJ_GAIN_STRU
 *
 * Description : It's used to calc the reverse channel code output power. The
 * procedure is defined in section 2.1.2.3.1.5 in 3GPP2 C.S0002-A v6.0:
 * "Physical Layer Standard for cdma2000 Spread Spectrum Systems", page 2-49,
 * line 16~30.
 * @sGain: It includes six parts at most. They are:
 * -  a. "Nominal_Attribute_Gain", which is the nominal Reverse Fundamental
 *    Channel, Reverse Supplemental Channel, or Reverse Dedicated Control
 *    Channel power relative to the Reverse Pilot Channel power for each data
 *    rate listed in Table 2.1.2.3.3.7-1 and Table 2.1.2.3.3.7-2, frame
 *    duration, and type of coding supported by the mobile station.
 * -  b. "Attribute_Adjustment_Gain", which is an offset relative to the
 *    Reverse Pilot Channel power for each data rate, frame duration, and type
 *    of coding supported by the mobile station;
 * -  c. "Reverse Channel Adjustment Gain", "The mobile station shall maintain
 *    a Reverse Link Attribute Adjustment Gain Table containing an offset
 *    relative to the Reverse Pilot Channel power for each data rate, frame
 *    duration, and coding rate supported by the mobile station. The mobile
 *    station shall initialize each entry in this table to 0." It can be
 *    updated by nework.
 * -  d. "RLGAIN_TRAFFIC_PILOTs", which is "Gain adjustment of the Reverse
 *    Traffic Channel with Radio Configurations 3 through 6 relative to the
 *    Reverse Pilot Channel". It's optional in configuration from network. If
 *    it's without it in configuraton, it's ignored, and will be included into
 *    @sGain
 * -  e. "RLGAIN_SCH_PILOT[i]s", which is "Gain adjustment of Reverse
 *    Supplemental Channel i relative to the Reverse Pilot Channel." Now
 *    product only support SCH0.
 * So @sGain = a + b + c + d + e, at most. If d and e have been not configed,
 * then @sGain = a + b + c. @sGain is unit of 0.125db.
 * @ausPilotRefLvl: They are two element in the array. Both of them are used to
 * calculate "Pilot_Reference_Level", which is used to define MAX_Channel. The
 * first element is Pilot_Attribute_Adjustment_Gain[Rate, Channel] from Table
 * 2.1.2.3.3.2, the second one is Nominal_Pilot_Reference_Level[Rate, Channel]
 * from nework configuration.Both of them are in unit of 0.125db.
 * @ausReserved: Reserve for future
 *******************************************************************************/
typedef struct
{
    VOS_INT16                           sGain;
    VOS_INT16                           asPilotRefLvl[2];
    VOS_UINT16                          ausReserved[5];
} CTTF_CSDR_1X_R_TCH_ADJ_GAIN_STRU;

/** ****************************************************************************
 * Name        : CTTF_CSDR_1X_R_POWERCTRL_STRU
 *
 * Description : It's used to estimate reverse channel power. CTTF1XRMAC will
 * use it to estimate power consuming base on channel traffic bits before it
 * try to prepare traffic bits, that's 20ms before the boudnary. CTTF1XRMAC
 * will use it to analysis how to schedule data from upper service to match the
 * power. Every 10ms CSDR updates it to latest value, before MAC read it. The
 * procedure is defined in section 2.1.2.3.2 and 2.1.2.3.3.2 in 3GPP2 C.S0002-A
 * v6.0: "Physical Layer Standard for cdma2000 Spread Spectrum Systems".
 * @lMaxTxPowerElement: The maximum allowed total transmit output power,
 * including any TCH channel, and pilot channel. In unit of 0.125dbm,
 * @lMaxTxPowerElement * 8 = MaxTxPower (dbm)
 * @lMeanPilotPowerElement: To help 1x_MAC_Tx to estimate power, CSDR will
 * change "mean pilot channel output power (dBm)" into @lMeanPilotPowerElement,
 * which is in unit of 0.125dbm,
 * @lMeanPilotPowerElement * 8 = "mean pilot channel output power (dBm)"
 *******************************************************************************/
typedef struct
{
    VOS_INT32                           lMaxTxPowerElement;
    VOS_INT32                           lMeanPilotPowerElement;
    VOS_UINT16                          ausReserved[4];
} CTTF_CSDR_1X_R_POWERCTRL_STRU;

/** ****************************************************************************
 * Name        : CTTF_CSDR_1X_ACH_DATA_REQ_STRU
 *
 * Description : @enMutexFlag:
 * -  at 10ms before boundary, MAC writes data into share memory, after that
 *    sets enMutexFlag into with data.
 * -  MAC should both write preamble parameter and data, after then set it to
 *    data existed
 * -  SDR read out data, and then sets it into without data.
 * @usRa: access channel number
 * ra set to RA
 * @usPwrLvl: power level adjustment of the Access probe, in units of
 * PWR_STEPs, sent in the PHY-ACHPreamble.Request primitive and PHY-ACH.Request
 *  primitive;
 * pwr_lvl set to PWR_LVLs
 * PWR_LVLs to (seqno mod (NUM_STEPs+1)), and NUM_STEPs in [0..15]
 * @usRn: the pseudo-random offset of the Access probe from a zero-offset
 * Access Channel frame.
 * rn set to RN
 * @usNumPreambleFrames: the number of Access Channel preamble frames, sent in
 * the PHY-ACHPreamble.Request primitive
 * num_preamble_frames set to (1 + PAM_SZs), equal (1-16 frames)
 * @usDataNum: number of ACH frames in a probe, it includes R-ACH PREAMBLE and
 * R-ACH MESSAGE CAPSULE, totally it's (4 + PAM_SZs + MAX_CAP_SZs) frame, equa
 * (4-26 frames)
 * @usBlkBitSize: a frame(block) bit size, it's ACH_FRAME_SIZE, equals 88 bits
 * @usBaseId: Base station identification
 * @aulDataAddr: contains every ACH data block start addresses, CSDR initial it
 * to the address of ausAchProbeData one by one in
 * CTTF_CSDR_1X_R_DATA_BUFFER_STRU.
 * @ausReserve2: reserve for future
 *******************************************************************************/
typedef struct
{
    CSDR_1X_MUTEX_ENUM_UINT16           enMutexFlag;
    VOS_UINT16                          usRa;                                      /**< 0..31 */
    VOS_UINT16                          usPwrLvl;                                  /**< 0..15 */
    VOS_UINT16                          usRn;                                      /**< 0..511, unit:chip */
    VOS_UINT16                          usNumPreambleFrames;                       /**< 1..16 frame */
    VOS_UINT16                          usDataNum;                                 /**< 4..26 frame */
    VOS_UINT16                          usBlkBitSize;
    VOS_UINT16                          usBaseId;
    VOS_UINT32                          aulDataAddr[CSDR_1X_MAX_ACH_DATA_BLK_CNT];
    VOS_UINT16                          ausReserve[4];
} CTTF_CSDR_1X_ACH_DATA_REQ_STRU;

/** ****************************************************************************
 * Name        : CTTF_CSDR_1X_DCCH_DATA_REQ_STRU
 *
 * Description : Included parameters are defined in section 2.2.1.1.1.7.2 in
 * 3GPP2 C.S0003-A v6.0: "Medium Access Control (MAC) Standard for cdma2000
 * Spread Spectrum Systems".
 *
 * Use share memory to imply this signal, the structure looks like below:
 * @enMutexFlag:
 * -  It's best that at 10ms before boundary, MAC writes data into share
 *    memory, after that sets enMutexFlag into with data. The latest time to
 *    write data should before the 13th ms.
 * -  SDR read out data at the 13th ms, and then sets it into without data.
 * @enFrameDuration:  The duration of the frame
 * @usBlkBitSize: a frame(block) bit size
 * @usSignalOnChannel: indicate whether signal data is on current channel, 1
 * means that signal data is on the channel, 0 means that not on the channel.
 * @ulTimeStamp: get it from CDMA_Timing_GetSystemTime10ms when MAC write data
 * into memory.
 * @stPcAdjGain: Power control information about this frame required by CSDR
 * @ulDataAddr: data block start address, CSDR initial it to the address of
 * ausDcchData in CTTF_CSDR_1X_R_DATA_BUFFER_STRU.
 * @ausReserved: reserve for future
 *******************************************************************************/
typedef struct
{
    CSDR_1X_MUTEX_ENUM_UINT16           enMutexFlag;
    CSDR_1X_FRAME_DURATION_ENUM_UINT16  enFrameDuration;
    VOS_UINT16                          usBlkBitSize;      /**< RC3: 172, RC4: 267 */
    VOS_UINT16                          usSignalOnChannel;
    VOS_UINT32                          ulTimeStamp;
    CTTF_CSDR_1X_R_TCH_ADJ_GAIN_STRU    stPcAdjGain;
    VOS_UINT32                          ulDataAddr;
    VOS_UINT16                          ausReserved[4];
} CTTF_CSDR_1X_DCCH_DATA_REQ_STRU;

/** ****************************************************************************
 * Name        : CTTF_CSDR_1X_EACH_DATA_REQ_STRU
 *
 * Description : Now EACH only support basic mode, and using share memory to
 * imply it. Preamble and data are together.
 *
 * @enMutexFlag:
 * -  at 10ms before boundary, MAC writes data into share memory, after that
 *    sets enMutexFlag into with data.
 * -  MAC should both write preamble parameter and data, after then set it to
 *    data existed
 * -  SDR read out data, and then sets it into without data.
 * @usPwrLvl: the power level adjustment of the Enhanced Access probe, in units
 * of EACH_PWR_STEPs, sent in the PHY-EACHPreamble.Request primitive, the
 * PHY-EACHHeader.Request primitive, and the PHY-EACH.Request primitive.
 * @usFccchId: Forward Common Control Channel number
 * @usBaseId: Base station identification
 * @enFrameDuration:  The duration of the frame
 * @usDelaySlot: as EACH slot could be quite short, even 1.25ms, MAC is hard to
 * handle that order of magnitudes. So MAC gather all slots need to delay, and
 * asks SDR to do the delay before sending preamble.
 * @usIndex: the index of MODE PARM REC array in Enhanced Access Parameters
 * Message, [0..7]. It's used to match the array, to make sure that PHY and MAC
 * will use the parameters from the same occurrence.
 * @usBlkBitSize: a frame(block) bit size
 * @usDataNum: number of ACH frames in a probe
 * @aulDataAddr: it contains every ACH data block start addresses, CSDR initial
 * it to the address of ausEachProbeData one by one in
 * CTTF_CSDR_1X_R_DATA_BUFFER_STRU.
 * @ausReserved: reserve for future
 *******************************************************************************/
typedef struct
{
    CSDR_1X_MUTEX_ENUM_UINT16           enMutexFlag;
    VOS_UINT16                          usPwrLvl;
    VOS_UINT16                          usFccchId;
    VOS_UINT16                          usEachId;
    VOS_UINT16                          usBaseId;
    CSDR_1X_FRAME_DURATION_ENUM_UINT16  enFrameDuration;
    VOS_UINT16                          usDelaySlot;
    VOS_UINT16                          usIndex;
    VOS_UINT16                          usBlkBitSize;
    VOS_UINT16                          usDataNum;
    VOS_UINT32                          aulDataAddr[CSDR_1X_MAX_EACH_DATA_BLK_CNT];
    VOS_UINT16                          ausReserved[4];
} CTTF_CSDR_1X_EACH_DATA_REQ_STRU;

/** ****************************************************************************
 * Name        : CTTF_CSDR_1X_FCH_DATA_REQ_STRU
 *
 * Description : Included parameters are defined in section 2.2.1.1.1.7.1 in
 * 3GPP2 C.S0003-A v6.0: "Medium Access Control (MAC) Standard for cdma2000
 * Spread Spectrum Systems".
 *
 * Use share memory to imply this signal, the structure looks like below:
 * @enMutexFlag:
 * -  It's best that at 10ms before boundary, MAC writes data into share
 *    memory, after that sets enMutexFlag into with data. The latest time to
 *    write data should before the 13th ms.
 * -  SDR read out data at the 13th ms, and then sets it into without data.
 * @enFrameDuration:  The duration of the frame
 * @usBlkBitSize: a frame(block) bit size
 * @usSignalOnChannel: indicate whether signal data is on current channel, 1
 * means that signal data is on the channel, 0 means that not on the channel.
 * @ulTimeStamp: get it from CDMA_Timing_GetSystemTime10ms when MAC write data
 * into memory.
 * @stPcAdjGain: Power control information about this frame required by CSDR,
 * it's only valid when FCH RC >2
 * @ulDataAddr: data block start address, CSDR initial it to the address of
 * ausFchData in CTTF_CSDR_1X_R_DATA_BUFFER_STRU.
 * @ausReserved: reserve for future
 *******************************************************************************/
typedef struct
{
    CSDR_1X_MUTEX_ENUM_UINT16           enMutexFlag;
    CSDR_1X_FRAME_DURATION_ENUM_UINT16  enFrameDuration;
    VOS_UINT16                          usBlkBitSize;      /**< RC1/3/8: {172, 80, 40, 16}, RC2/4: {267, 125, 55, 21} */
    VOS_UINT16                          usSignalOnChannel;
    VOS_UINT32                          ulTimeStamp;
    CTTF_CSDR_1X_R_TCH_ADJ_GAIN_STRU    stPcAdjGain;
    VOS_UINT32                          ulDataAddr;
    VOS_UINT16                          ausReserved[4];
} CTTF_CSDR_1X_FCH_DATA_REQ_STRU;

/** ****************************************************************************
 * Name        : CTTF_CSDR_1X_R_CTRL_HEADER_STRU
 *
 * Description : It's general control for channel management. It's on top of
 * all channels data management. After that, it's per channel data management
 * one by one.
 *
 * @usAllowedTx: To control whether L2 can tx any data or not. If not allow, it
 * means L2 can not tx any channel data. If allow, L2 can tx data on channel
 * that its channel-id matches L2 maintained channel-id.
 * @usAchCfgId, @usEachCfgId, @RFchCfgId, @RDcchCfgId, @RSchCfgId, @RScchCfgId:
 * -  SDR uses cfg-id in new configuration to update corresponding channel
 *    cfg-id in memory. PROC will calculate the time to activate MAC on reverse
 *    link. And when that time 2*1/4PCG before that time, SDR needs fill cfg-id
 *    into memory.
 * -  MAC shall read the ConfigID before handling the data. If cfg-id in memory
 *    and cfg-id stored in MAC are different, which means the ConfigID has
 *    changed, MAC shall perform the config change at first.
 * -  When SDR release a channel, it should set cfg-id corresponding in memory
 *    into NO_CHANNEL_CFG_ID, which is 0xFFFF.
 * Rev CfgIdActionTime includes uhwCfgIdActionTimePcg and
 * uhwCfgIdActionTimeFrame. Except active immediately, it should refer to 20ms
 * before the time to send data on air-interface. Below are scenarios listed:
 * Establishment
 * uhwCfgIdActionTimePcg and uhwCfgIdActionTimeFrame will be set to
 * CSDR_1X_ACTIVATE_AT_ONCE, i.e the same value as uwhActionTime.
 *
 * Reconfiguration
 * uhwCfgIdActionTimePcg = (FrameOffset-16) mod 64 (i.e. 20ms before the "real
 * activation time")
 * uhwCfgIdActionTimeFrame = ActionTime from CAS, 0..63
 * uhwActionTime = FrameOffset
 *
 * Hard Handoff
 * uhwCfgIdActionTimePcg = (First PCG of data transmission - 16) mod 64
 * uhwCfgIdActionTimeFrame = System Frame number in which data transmission
 * starts
 * uhwActionTime = First PCG of the frame  in which the preamble starts
 *
 * Revert
 * <240ms
 * uhwCfgIdActionTimePcg = (First PCG of data transmission - 16) mod 64
 * uhwCfgIdActionTimeFrame = System Frame number in which data transmission
 * starts
 * uhwActionTime = First PCG of data transmission
 *
 * >=240ms
 * uhwCfgIdActionTimePcg = (First PCG of data transmission - 16) mod 64
 * uhwCfgIdActionTimeFrame = System Frame number in which data transmission
 * starts
 * uhwActionTime = First PCG of data transmission
 *******************************************************************************/
typedef struct
{
    CSDR_1X_TX_CTRL_ENUM_UINT16         enAllowedTx;
    VOS_UINT16                          usAchCfgId;
    VOS_UINT16                          usEachCfgId;
    VOS_UINT16                          usRFchCfgId;
    VOS_UINT16                          usRDcchCfgId;
    VOS_UINT16                          usRSchCfgId;
    VOS_UINT16                          usRScchCfgId;
    VOS_UINT16                          ausReserve[1];
} CTTF_CSDR_1X_R_CTRL_HEADER_STRU;

/** ****************************************************************************
 * Name        : CTTF_CSDR_1X_R_DATA_BUFFER_STRU
 *
 * Description : It's used to corporate with per channel data management to
 * indicate where and how many bits need to transmit on certain type channel.
 * And also with some parameters about this channel.
 *******************************************************************************/
typedef struct
{
    VOS_UINT16                          ausAchProbeData[CSDR_1X_MAX_ACH_DATA_BLK_CNT][CSDR_1X_ACH_PER_PROBE_BLK_MAX_SIZE];
    VOS_UINT16                          ausEachProbeData[CSDR_1X_MAX_EACH_DATA_BLK_CNT][CSDR_1X_EACH_PER_PROBE_BLK_MAX_SIZE];
    VOS_UINT16                          ausFchData[CSDR_1X_RFCH_BLK_MAX_SIZE];
    VOS_UINT16                          ausSchData[CSDR_1X_RSCH_BLK_MAX_SIZE];
    VOS_UINT16                          ausDcchData[CSDR_1X_RDCCH_BLK_MAX_SIZE];
    VOS_UINT16                          ausScchData[CSDR_1X_RSCCH_BLK_MAX_SIZE];
} CTTF_CSDR_1X_R_DATA_BUFFER_STRU;

/** ****************************************************************************
 * Name        : CTTF_CSDR_1X_SCCH_DATA_REQ_STRU
 *
 * Description : Included parameters are defined in section 2.2.1.1.1.7.3 in
 * 3GPP2 C.S0003-A v6.0: "Medium Access Control (MAC) Standard for cdma2000
 * Spread Spectrum Systems".
 *
 * Now SCCH has designed in RTT(includes HW and L1) only for chip testing, the
 * product does not need it. So just list this interface between L1 and L2. But
 * L2 will not try to implements SCCH. And L1 and L2 agree to use share memory
 * to imply this signal, the structure looks like below temporarily:
 * @enMutexFlag:
 * -  It's best that at 10ms before boundary, MAC writes data into share
 *    memory, after that sets enMutexFlag into with data. The latest time to
 *    write data should before the 13th ms.
 * -  SDR read out data at the 13th ms, and then sets it into without data.
 * @enFrameDuration:  The duration of the frame
 * @usBlkBitSize: a frame(block) bit size
 * @usSignalOnChannel: indicate whether signal data is on current channel, 1
 * means that signal data is on the channel, 0 means that not on the channel.
 * @ulTimeStamp: get it from CDMA_Timing_GetSystemTime10ms when MAC write data
 * into memory.
 * @stPcAdjGain: Power control information about this frame required by CSDR,
 * it's only valid when SCCH RC >2
 * @ulDataAddr: data block start address, CSDR initial it to the address of
 * ausScchData in CTTF_CSDR_1X_R_DATA_BUFFER_STRU.
 * @ausReserved: reserve for future
 *******************************************************************************/
typedef struct
{
    CSDR_1X_MUTEX_ENUM_UINT16           enMutexFlag;
    CSDR_1X_FRAME_DURATION_ENUM_UINT16  enFrameDuration;
    VOS_UINT16                          usBlkBitSize;
    VOS_UINT16                          usSignalOnChannel;
    VOS_UINT32                          ulTimeStamp;
    CTTF_CSDR_1X_R_TCH_ADJ_GAIN_STRU    stPcAdjGain;
    VOS_UINT32                          ulDataAddr;
    VOS_UINT16                          ausReserved[4];
} CTTF_CSDR_1X_SCCH_DATA_REQ_STRU;

/** ****************************************************************************
 * Name        : CTTF_CSDR_1X_SCH_DATA_REQ_STRU
 *
 * Description : Included parameters are defined in section 2.2.1.1.1.7.4 in
 * 3GPP2 C.S0003-A v6.0: "Medium Access Control (MAC) Standard for cdma2000
 * Spread Spectrum Systems".
 *
 * Now only support one SCH, and use share memory to imply this signal, the
 * structure looks like below:
 * @enMutexFlag:
 * -  It's best that at 10ms before boundary, MAC writes data into share
 *    memory, after that sets enMutexFlag into with data. The latest time to
 *    write data should before the 13th ms.
 * -  SDR read out data at the 13th ms, and then sets it into without data.
 * @enFrameDuration:  The duration of the frame
 * @usBlkBitSize: a frame(block) bit size. Now only support fix size in product
 * @usSignalOnChannel: indicate whether signal data is on current channel, 1
 * means that signal data is on the channel, 0 means that not on the channel.
 * @ulTimeStamp: get it from CDMA_Timing_GetSystemTime10ms when MAC write data
 * into memory.
 * @stPcAdjGain: Power control information about this frame required by CSDR
 * @ulDataAddr: data block start address, CSDR initial it to the address of
 * ausSchData in CTTF_CSDR_1X_R_DATA_BUFFER_STRU.
 * @ausReserved: reserve for future
 *******************************************************************************/
typedef struct
{
    CSDR_1X_MUTEX_ENUM_UINT16           enMutexFlag;
    CSDR_1X_FRAME_DURATION_ENUM_UINT16  enFrameDuration;
    VOS_UINT16                          usBlkBitSize;      /**< RC3: {172, 360, 744, 1512, 3048, 6120}, RC4: {267, 552, 1128, 2280, 4584}, RC8: {172, 360, 744, 1512, 3048} */
    VOS_UINT16                          usSignalOnChannel;
    VOS_UINT32                          ulTimeStamp;
    CTTF_CSDR_1X_R_TCH_ADJ_GAIN_STRU    stPcAdjGain;
    VOS_UINT32                          ulDataAddr;
    VOS_UINT16                          ausReserved[4];
} CTTF_CSDR_1X_SCH_DATA_REQ_STRU;

/** ****************************************************************************
 * Name        : CTTF_CSDR_1X_R_CTRL_MGMT_STRU
 *
 * Description : It's channel data management, shared in memory between
 * 1x_Layer_1 and CTTF1XRMAC. After CTTF_CSDR_1X_R_CTRL_HEADER_STRU, it is per
 * channel data management one by one. The order is ACH, EACH, FCH, SCH, DCCH
 * and SCCH. See more detail in CTTF_CSDR_1X_ACH_DATA_REQ_STRU,
 * CTTF_CSDR_1X_EACH_DATA_REQ_STRU, CTTF_CSDR_1X_FCH_DATA_REQ_STRU,
 * CTTF_CSDR_1X_SCH_DATA_REQ_STRU, CTTF_CSDR_1X_DCCH_DATA_REQ_STRU and
 * CTTF_CSDR_1X_SCCH_DATA_REQ_STRU.
 *
 * It's needed to be stored in non-power-down area. The owner to do
 * initialization is CSDR.
 * When power-on or RAT turns back to CDMA, e.g. from GSM back to CDMA, SDR
 * will initial this structure and link data pointers.
 * When release a channel, MAC set that channel @enMutexFlag to data-not-exist.
 *******************************************************************************/
typedef struct
{
    CTTF_CSDR_1X_R_CTRL_HEADER_STRU     st1xCtrlHeader;
    CTTF_CSDR_1X_R_POWERCTRL_STRU       st1xPowerCtrl;
    CTTF_CSDR_1X_ACH_DATA_REQ_STRU      st1xAchData;
    CTTF_CSDR_1X_EACH_DATA_REQ_STRU     st1xEachData;
    CTTF_CSDR_1X_FCH_DATA_REQ_STRU      st1xFchData;
    CTTF_CSDR_1X_SCH_DATA_REQ_STRU      st1xSchData;
    CTTF_CSDR_1X_DCCH_DATA_REQ_STRU     st1xDcchData;
    CTTF_CSDR_1X_SCCH_DATA_REQ_STRU     st1xScchData;
} CTTF_CSDR_1X_R_CTRL_MGMT_STRU;

/*******************************************************************************
 7. OTHER declarations
*******************************************************************************/

/** ****************************************************************************
 * Name        : CTTF_CSDR_1X_ACH_TRACE_DATA_REQ_STRU
 *
 * Description : This signal is used to trace PHY-ACHPreamble.Request and
 * PHY-ACH.Request. @usBlkBitSize shows how many bit is used in every block in
 * the same probe, using it to calculate how many octet will be occupied.
 *******************************************************************************/
typedef struct
{
    VOS_MSG_HEADER
    CSDR_1X_ENCDATA_PIF_MSG_TYPE_ENUM_UINT16                enMsgId;
    VOS_UINT16                                              usOpId;
    CSDR_1X_MUTEX_ENUM_UINT16                               enMutexFlag;
    VOS_UINT16                                              usCfgId;
    VOS_UINT16                                              usRa;
    VOS_UINT16                                              usPwrLvl;
    VOS_UINT16                                              usRn;
    VOS_UINT16                                              usNumPreambleFrames;
    VOS_UINT16                                              usDataNum;
    VOS_UINT16                                              usBlkBitSize;
    VOS_UINT16                                              usBaseId;
    VOS_UINT16                                              ausReserve1[1];
    VOS_UINT8                                               aucData[CSDR_1X_MAX_ACH_DATA_BLK_CNT][CSDR_1X_ACH_PER_PROBE_BLK_MAX_MEM_OCCUPIED];
} CTTF_CSDR_1X_ACH_TRACE_DATA_REQ_STRU;

/** ****************************************************************************
 * Name        : CTTF_CSDR_1X_EACH_TRACE_DATA_REQ_STRU
 *
 * Description : This signal is used to trace PHY-EACHPreamble.Request and
 * PHY-EACH.Request. @usBlkBitSize shows how many bit is used in every block in
 * the same probe, using it to calculate how many octet will be occupied.
 *******************************************************************************/
typedef struct
{
    VOS_MSG_HEADER
    CSDR_1X_ENCDATA_PIF_MSG_TYPE_ENUM_UINT16                enMsgId;
    VOS_UINT16                                              usOpId;
    CSDR_1X_MUTEX_ENUM_UINT16                               enMutexFlag;
    VOS_UINT16                                              usCfgId;
    VOS_UINT16                                              usPwrLvl;
    VOS_UINT16                                              usFccchId;
    VOS_UINT16                                              usEachId;
    VOS_UINT16                                              usBaseId;
    CSDR_1X_FRAME_DURATION_ENUM_UINT16                      enFrameDuration;
    VOS_UINT16                                              usDelaySlot;
    VOS_UINT16                                              usIndex;
    VOS_UINT16                                              usBlkBitSize;
    VOS_UINT16                                              usDataNum;
    VOS_UINT16                                              ausReserve1[1];
    VOS_UINT8                                               aucData[CSDR_1X_MAX_EACH_DATA_BLK_CNT][CSDR_1X_EACH_PER_PROBE_BLK_MAX_MEM_OCCUPIED];
} CTTF_CSDR_1X_EACH_TRACE_DATA_REQ_STRU;

/** ****************************************************************************
 * Name        : CTTF_CSDR_1X_FCH_TRACE_DATA_REQ_STRU
 *
 * Description : This signal is used to trace PHY-FCH.Request, including
 * parameters are defined in section 2.2.1.1.1.7.1 in 3GPP2 C.S0003-A v6.0:
 * "Medium Access Control (MAC) Standard for cdma2000 Spread Spectrum Systems".
 * @usBlkBitSize shows how many bit is used in every block in current frame,
 * using it to calculate how many octet will be occupied.
 *******************************************************************************/
typedef struct
{
    VOS_MSG_HEADER
    CSDR_1X_ENCDATA_PIF_MSG_TYPE_ENUM_UINT16                enMsgId;
    VOS_UINT16                                              usOpId;
    CSDR_1X_MUTEX_ENUM_UINT16                               enMutexFlag;
    VOS_UINT16                                              usCfgId;
    CSDR_1X_FRAME_DURATION_ENUM_UINT16                      enFrameDuration;
    VOS_UINT16                                              usBlkBitSize;
    VOS_UINT8                                               aucData[CSDR_1X_RFCH_BLK_MAX_MEM_OCCUPIED];
    VOS_UINT16                                              ausReserve[4];
} CTTF_CSDR_1X_FCH_TRACE_DATA_REQ_STRU;

/** ****************************************************************************
 * Name        : CTTF_CSDR_1X_SCH_TRACE_DATA_REQ_STRU
 *
 * Description : This signal is used to trace PHY-SCH.Request, including
 * parameters are defined in section 2.2.1.1.1.7.4 in 3GPP2 C.S0003-A v6.0:
 * "Medium Access Control (MAC) Standard for cdma2000 Spread Spectrum Systems".
 * @usBlkBitSize shows how many bit is used in every block in current frame,
 * using it to calculate how many octet will be occupied.
 *******************************************************************************/
typedef struct
{
    VOS_MSG_HEADER
    CSDR_1X_ENCDATA_PIF_MSG_TYPE_ENUM_UINT16                enMsgId;
    VOS_UINT16                                              usOpId;
    CSDR_1X_MUTEX_ENUM_UINT16                               enMutexFlag;
    VOS_UINT16                                              usCfgId;
    CSDR_1X_FRAME_DURATION_ENUM_UINT16                      enFrameDuration;
    VOS_UINT16                                              usBlkBitSize;
    VOS_UINT8                                               aucData[CSDR_1X_RSCH_BLK_MAX_MEM_OCCUPIED];
    VOS_UINT16                                              ausReserve[4];
} CTTF_CSDR_1X_SCH_TRACE_DATA_REQ_STRU;

/** ****************************************************************************
 * Name        : CTTF_CSDR_1X_DCCH_TRACE_DATA_REQ_STRU
 *
 * Description : This signal is used to trace PHY-DCCH.Request, including
 * parameters are defined in section 2.2.1.1.1.7.2 in 3GPP2 C.S0003-A v6.0:
 * "Medium Access Control (MAC) Standard for cdma2000 Spread Spectrum Systems".
 * @usBlkBitSize shows how many bit is used in every block in current frame,
 * using it to calculate how many octet will be occupied.
 *******************************************************************************/
typedef struct
{
    VOS_MSG_HEADER
    CSDR_1X_ENCDATA_PIF_MSG_TYPE_ENUM_UINT16                enMsgId;
    VOS_UINT16                                              usOpId;
    CSDR_1X_MUTEX_ENUM_UINT16                               enMutexFlag;
    VOS_UINT16                                              usCfgId;
    CSDR_1X_FRAME_DURATION_ENUM_UINT16                      enFrameDuration;
    VOS_UINT16                                              usBlkBitSize;
    VOS_UINT8                                               aucData[CSDR_1X_RDCCH_BLK_MAX_MEM_OCCUPIED];
} CTTF_CSDR_1X_DCCH_TRACE_DATA_REQ_STRU;

/** ****************************************************************************
 * Name        : CTTF_CSDR_1X_SCCH_TRACE_DATA_REQ_STRU
 *
 * Description : This signal is used to trace PHY-SCCH.Request, including
 * parameters are defined in section 2.2.1.1.1.7.3 in 3GPP2 C.S0003-A v6.0:
 * "Medium Access Control (MAC) Standard for cdma2000 Spread Spectrum Systems".
 * Now not support SCCH.
 *******************************************************************************/
typedef struct
{
    VOS_MSG_HEADER
    CSDR_1X_ENCDATA_PIF_MSG_TYPE_ENUM_UINT16                enMsgId;
    VOS_UINT16                                              usOpId;
} CTTF_CSDR_1X_SCCH_TRACE_DATA_REQ_STRU;

/*******************************************************************************
 8. Global  declaration
*******************************************************************************/

/*******************************************************************************
 9. Function declarations
*******************************************************************************/

#if ((VOS_OS_VER == VOS_WIN32) || (VOS_OS_VER == VOS_NUCLEUS))
#pragma pack()
#else
#pragma pack(0)
#endif

#ifdef __cplusplus
#if __cplusplus
}
#endif /* __cpluscplus */
#endif /* __cpluscplus */

#endif



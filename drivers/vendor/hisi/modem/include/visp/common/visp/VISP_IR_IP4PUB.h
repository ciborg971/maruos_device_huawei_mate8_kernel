/*************************************************************************
 *
 *              Copyright 2006, Huawei Technologies Co. Ltd.
 *                          ALL RIGHTS RESERVED
 *
 *-----------------------------------------------------------------------*
 *
 *                         VISP_IR_IP4PUB.H
 *
 *  Project Code: VISP1.6
 *   Module Name: PPMNG
 *  Date Created: 2006/11/16
 *        Author: liuyong
 *   Description: 这个头文件内容是从VISP PP4/AM4相关的各个头文件抽取IR需要的宏和结构构成，
 *                在后续开发和维护时，需要关注同VISP保持同步!
 *
 *-----------------------------------------------------------------------*
 *  Modification History
 *  DATE            NAME            DESCRIPTION
 *
 ************************************************************************/
#ifndef _VISP_IR_IP4PUB_H_
#define _VISP_IR_IP4PUB_H_

#ifdef  __cplusplus
extern "C"{
#endif
/*********************   from pp4_pub.h ***************************/
#ifndef IPPROTO_IPIP            /* ip over ip protocol */
#define IPPROTO_IPIP    4
#endif

#ifndef IPPROTO_ESP
#define IPPROTO_ESP     50      /* Ip Sec */
#endif

#ifndef IPPROTO_AH
#define IPPROTO_AH      51      /* Ip Sec */
#endif

#define IP_VERSION  4
#define IP_RAWOUTPUT        0x2             /* raw ip header exists */

#define PRCO_GETOPT 0
#define PRCO_SETOPT 1
#define PRCO_NCMDS  2

/*
 * Values for pr_flags.
 * PR_ADDR requires PR_ATOMIC;
 * PR_ADDR and PR_CONNREQUIRED are mutually exclusive.
 */
#define PR_ATOMIC       0x01        /* exchange atomic messages only */
#define PR_ADDR         0x02        /* addresses given with messages */
#define PR_CONNREQUIRED 0x04        /* connection required by protocol */
#define PR_WANTRCVD     0x08        /* want PRU_RCVD calls */
#define PR_RIGHTS       0x10        /* passes capabilities */

#define RTMSG_ADD        1

#define RTF_REF         0x2000
#define RTF_HOST        0x4            /* host entry (net otherwise) */
/***********************************************************************************************************************/
/***********************************************************************************************************************/
#define RTF_UP          0x1        /********************** route usable ************************************************/
#define RTF_GATEWAY     0x2        /********************** destination is a gateway ************************************/
#define RTF_REJECT      0x8        /********************** host or net unreachable *************************************/
#define RTF_DYNAMIC     0x10       /********************** created dynamically (by redirect) ***************************/
/***********************************************************************************************************************/
/***********************************************************************************************************************/
#define RTF_MODIFIED    0x20       /********************** modified dynamically (by redirect) **************************/
#define RTF_DONE        0x40       /********************** message confirmed *******************************************/
#define RTF_MASK        0x80       /********************** subnet mask present *****************************************/
#define RTF_CLONING     0x100      /********************** generate new routes on use **********************************/
/***********************************************************************************************************************/
/***********************************************************************************************************************/
/***********************************************************************************************************************/
#define RTF_XRESOLVE    0x200      /********************** external daemon resolves name *******************************/
#define RTF_LLINFO      0x400      /********************** generated by ARP or ESIS ************************************/
#define RTF_STATIC      0x800      /********************** manually added **********************************************/
/***********************************************************************************************************************/
/***********************************************************************************************************************/
#define RTF_BLACKHOLE   0x1000     /********************** just discard pkts (during updates) **************************/
#define RTF_PROTO2      0x4000     /********************** protocol specific routing flag ******************************/
#define RTF_REJECT2     0x8000     /********************** protocol specific routing flag ******************************/
/***********************************************************************************************************************/
/***********************************************************************************************************************/
/*
 * usrreq的参数是(*protosw[].pr_usrreq)(up, req, m, nam, opt) ;
 * The arguments to usrreq are:
 *  (*protosw[].pr_usrreq)(up, req, m, nam, opt);

 * 其中up是socket指针,req是这些请求之一
 * where up is a (struct socket *), req is one of these requests,

 * m是保存消息的可选mbuf链
 * m is a optional mbuf chain containing a message,

 * nam是保存地址的可选mbuf链
 * nam is an optional mbuf chain containing an address,

 * opt是socketopt指针,或者空指针
 * and opt is a pointer to a socketopt structure or nil.

 * 本协议只负责处理mbuf链
 * The protocol is responsible for disposal of the mbuf chain m,

 * 调用者需提供nam和opt使用的空间
 * the caller is responsible for any space held by nam and opt.

 * 若usrrep返回非零, 则需传递一个UNIX错误码给上层软件处理
 * A non-zero return from usrreq gives an
 * UNIX error number which should be passed to higher level software.
 */

#define PRU_ATTACH          0    /* 服从协议              attach protocol to up */
#define PRU_DETACH          1    /* 从协议分离            detach protocol from up */
#define PRU_BIND            2    /* 为socket绑定地址      bind socket to address */
#define PRU_LISTEN          3    /* 监听连接              listen for connection */
#define PRU_CONNECT         4    /* 建立对端的连接        establish connection to peer */
#define PRU_ACCEPT          5    /* 接受对端的连接        accept connection from peer */
#define PRU_DISCONNECT      6    /* 取消对端的连接        disconnect from peer */
#define PRU_SHUTDOWN        7    /* 不再发送数据          won't send any more data */
#define PRU_RCVD            8    /* 接收数据              have taken data; more room now */
#define PRU_SEND            9    /* 发送数据              send this data */
#define PRU_ABORT           10   /* 中止[快速断开,分离]   abort (fast DISCONNECT, DETATCH) */
#define PRU_CONTROL         11   /* 协议控制              control operations on protocol */
#define PRU_SENSE           12   /* 返回状态至m           return status into m */
#define PRU_RCVOOB          13   /* 获取band数据          retrieve out of band data */
#define PRU_SENDOOB         14   /* 发送band数据          send out of band data */
#define PRU_SOCKADDR        15   /* 获取socket地址        fetch socket's address */
#define PRU_PEERADDR        16   /* 获取对端地址          fetch peer's address */
#define PRU_CONNECT2        17   /* 连接两个socket        connect two sockets */
/* 供协议内部使用   begin for protocols internal use */
#define PRU_FASTTIMO        18   /* 200ms 超时    200ms timeout */
#define PRU_SLOWTIMO        19   /* 500ms 超时    500ms timeout */
#define PRU_PROTORCV        20   /* 下层接收      receive from below */
#define PRU_PROTOSEND       21   /* 下层分发      send to below */

#define PRU_NREQ            21
#define PRU_UNBIND          22   /* 解除socket和接口的邦定  unbind socket to interface */

/*
 * ctlinput routine的参数是: (*protosw[].pr_ctlinput)(cmd, sa, arg);
 * The arguments to the ctlinput routine are
 *  (*protosw[].pr_ctlinput)(cmd, sa, arg);

 * 其中cmd是以下命令之一:  sa是sockaddr指针
 * where cmd is one of the commands below, sa is a pointer to a sockaddr,

 * arg是在协议族中使用的一个caddr_t可选参数
 * and arg is an optional caddr_t argument used within a protocol family.
 */

#define PRC_IFDOWN              0   /* 接口转换             interface transition */
#define PRC_ROUTEDEAD           1   /* 选择新路由           select new route if possible ??? */
#define PRC_QUENCH2             3   /* DEC拥塞指示位        DEC congestion bit says slow down */
#define PRC_QUENCH              4   /* 源站被抑制           some one said to slow down */
#define PRC_MSGSIZE             5   /* 报文过大,强制丢弃    message size forced drop */
#define PRC_HOSTDEAD            6   /* 无主机响应           host appears to be down */
#define PRC_HOSTUNREACH         7   /* 不推荐(请使用PRC_UNREACH_HOST)   deprecated (use PRC_UNREACH_HOST) */
#define PRC_UNREACH_NET         8   /* 无网络路由           no route to network */
#define PRC_UNREACH_HOST        9   /* 无主机路由           no route to host */
#define PRC_UNREACH_PROTOCOL    10  /* 目的端回复错误协议   dst says bad protocol */
#define PRC_UNREACH_PORT        11  /* 错误端口号           bad port # */
/* was  PRC_UNREACH_NEEDFRAG    12     (use PRC_MSGSIZE) */
#define PRC_UNREACH_SRCFAIL     13  /* 源路由失败        source route failed */
#define PRC_REDIRECT_NET        14  /* 网络路由重定向    net routing redirect */
#define PRC_REDIRECT_HOST       15  /* 主机路由重定向    host routing redirect */
#define PRC_REDIRECT_TOSNET     16  /* 对服务类型和网络重定向  redirect for type of service & net */
#define PRC_REDIRECT_TOSHOST    17  /* 对服务类型和主机重定向  redirect for tos & host */
#define PRC_TIMXCEED_INTRANS    18  /* 传输期间数据报到期    packet lifetime expired in transit */
#define PRC_TIMXCEED_REASS      19  /* reass q数据报到期 lifetime expired on reass q */
#define PRC_PARAMPROB           20  /* 头部错误          header incorrect */

/* Start: RFC4443 compliance changes */
#define PRC_BEYOND_SCOPE          21 /* Beyond scope */
#define PRC_INGRESS_EGRESS_POLICY 22 /* ingress/egress policy filter */
#define PRC_REJECT_ROUTE          23 /* reject route configured to dst */
/* End: RFC4443 compliance changes */

#define PRC_NCMDS               24

#define PRC_IS_REDIRECT(cmd)    \
    ((cmd) >= PRC_REDIRECT_NET && (cmd) <= PRC_REDIRECT_TOSHOST)

#define PR_SLOWHZ   2       /* 2 slow timeouts per second */
#define PR_FASTHZ   5       /* 5 fast timeouts per second */

typedef struct tagINADDR
{
    ULONG s_ulAddr;
}INADDR_S;

typedef struct tagIP
{
#if VRP_LITTLE_ENDIAN == VRP_YES
    UCHAR   ip_chHLen:4;        /* header length */
    UCHAR   ip_chVer: 4;         /* version */
#else
    UCHAR  ip_chVer:  4;         /* version */
    UCHAR  ip_chHLen: 4;        /* header length */
#endif
    UCHAR   ip_chTOS;           /* type of service */
    USHORT  ip_usLen;           /* total length */
#define ip_sLen ip_usLen
    USHORT  ip_usId;            /* identification */
    USHORT  ip_usOff;           /* fragment offset field */
#define ip_sOff ip_usOff
#define IP_DF 0x4000            /* dont fragment flag */
#define IP_MF 0x2000            /* more fragments flag */
#define IP_OFFMASK 0x1fff       /* mask for fragmenting bits */
    UCHAR   ip_chTTL;           /* time to live */
    UCHAR   ip_chPr;            /* protocol */
    USHORT  ip_usSum;           /* checksum */
    struct  tagINADDR ip_stSrc;
    struct  tagINADDR ip_stDst; /* source and dest address */
}IP_S;

struct tagQUEUE;
typedef struct tagQUEUE
{
    struct tagQUEUE    *pNext;
    struct tagQUEUE    *pPrev;
}QUEUE_S;

/**********************************************************************
* ip multicast option struct
**********************************************************************/
struct tagIPMREQ;
typedef struct tagIPMOPTIONS
{
    ULONG   imo_ulIndexIf;      /* ifp for outgoing multicasts */
    UCHAR   imo_bTTL;           /* TTL for outgoing multicasts */
    UCHAR   imo_bLoop;          /* 1 => hear sends if a member */
    USHORT  imo_usVIF;          /* outgoing vif no             */

    USHORT  imo_usNumMemberships;       /* no. memberships this socket */
    UCHAR   ucPadding_1[2];
    struct tagIPMREQ *imo_pMembership_a; /* modifed structure imo_pMembership_a by mayun for D13667 2002-01-10 */
    USHORT  imo_usMaxMemberships;
    UCHAR   ucPadding_2[2];
}IPMOPTIONS_S, *PIPMOPTIONS_S;


/***************   from am4_pub.h      ********************/
#define IN_CLASSA(i)        (0 == ((long)(i) & 0x80000000L))
#define IN_CLASSA_HOST      0x00ffffffL
#define IN_CLASSB(i)        (0x80000000L == ((long)(i) & 0xc0000000L))
#define IN_CLASSB_HOST      0x0000ffffL
#define IN_CLASSC(i)        (0xc0000000L == ((long)(i) & 0xe0000000L))
#define IN_CLASSC_HOST      0x000000ffL

/* Socket address, internet style */
typedef struct tagSOCKADDRIN
{
    UCHAR   sin_chLen;
    UCHAR   sin_chFamily;
    USHORT  sin_usPort;
    struct  tagINADDR sin_stAddr;
    char    sin_chZero_a[8];
}SOCKADDRIN_S;

/***************   from ip_dmain.h      ********************/
struct tagDOMAIN;
struct tagSOCKET;
typedef struct tagPROTOSW
{
    /* Modified by X36317, 将此变量类型有short改为LONG，以解决ARM CPU四字节对齐问题, 2006/5/20 */
    LONG   pr_sType;              /* socket type used for */
    struct tagDOMAIN *pr_pDomain; /* domain protocol a member of */
    SHORT  pr_sProtocol;          /* protocol number */
    SHORT  pr_sFlags;             /* see below */

    /* protocol-protocol hooks */
    VOID   (*pr_pfInput)(MBUF_S *pRcvSeg, LONG);                               /* input to protocol (from below) */
    LONG   (*pr_pfOutput)(MBUF_S *,VOID *,VOID*,ULONG,VOID*);                  /* output to protocol (from above) */
    VOID   (*pr_pfCtlInput)(LONG,VOID *,VOID *);                               /* control input (from below) */
    LONG   (*pr_pfCtlOutput)(LONG,struct tagSOCKET *, LONG, LONG, MBUF_S **);  /* control output (from above) */

    /* user-protocol hook */
    LONG   (*pr_pfUsrReq)(struct tagSOCKET *, LONG, VOID *, VOID *, VOID *);   /* user request: see list below */

    /* utility hooks */
    VOID   (*pr_pfInit)();       /* initialization hook */
    VOID   (*pr_pfFastTimO)();   /* fast timeout (200ms) */
    VOID   (*pr_pfSlowTimO)();   /* slow timeout (500ms) */
    VOID   (*pr_pfDrain)();      /* flush any excess space possible */
    LONG   (*pr_pfSysCtl)(LONG *,ULONG,VOID *,ULONG *,VOID *,ULONG);           /* sysctl for protocol */
}PROTOSW_S;

typedef struct  tagDOMAIN
{
    int     dom_nFamily;            /* AF_xxx */
    CHAR    *dom_pName;
    VOID    (*dom_pfInit)(VOID);    /* initialize domain data structures */
    int     (*dom_pfExternalize)(MBUF_S *); /* externalize access rights */
    int     (*dom_pfDispose)(MBUF_S *);     /* dispose of internalized rights */
    struct tagPROTOSW   *dom_pProtoSw, *dom_pNextProtoSw;
    struct tagDOMAIN    *dom_pNext;
    int     (*dom_pfRtAttach)(VOID **, int);/* initialize routing table */
    int     dom_nRtOffset;          /* an arg to rtattach, in bits */
    int     dom_nMaxRtKey;          /* for routing layer */
}DOMAIN_S;

/***************   from pp4_input.h      ********************/
#define IP_MAXPACKET        65535   /* maximum packet size */


/***************   from pp4_core.h      ********************/
/* intermediate process not processed the packet.
 * Stack (PP) will do the processing
 */
#define IP_PP4_NOT_PROCESSED_BY_INTERMEDIATE              0
/* intermediate found the packet has Error, Stack will Destroy the Packet */
#define IP_PP4_INTER_PROCESS_ERROR                        1
/* Intermediate Processing will continue processing and will own the packet
 * PP do not need to process the packet any more
 */
#define IP_PP4_PROCESSED_BY_INTERMEDIATE                  2

/* ip pakcet hooks type */
#define IP_PP4_HOOK_INPUT_ALL_PKT                   0x01
#define IP_PP4_HOOK_INPUT_LOCAL_PKT                 0x02
#define IP_PP4_HOOK_FORWARD_PKT                     0x04
#define IP_PP4_HOOK_OUTPUT_LOCAL_PKT                0x08
#define IP_PP4_HOOK_OUTPUT_ALL_PKT                  0x10


/***************   from ip_pub.h      ********************/
typedef struct tagROUTE
{
    struct  tagRTENTRY  *ro_pRt;
    struct  tagSOCKADDR ro_stDst;
}ROUTE_S;


/***************   from icmp_fun.h      ********************/
/*
 * Definitions for IP options.
 */
#define IPOPT_EOL       0       /* end of option list */
#define IPOPT_NOP       1       /* no operation */
#define IPOPT_SECURITY  130     /* provide s,c,h,tcc */
/*No define in VISP*/
#define IPOPT_ESO       133
#define IPOPT_CIPSO     134


/***************   from tcp.h      ********************/
typedef ULONG   TCP_SEQ;

/* TCP头数据结构 */
typedef struct tagTCPHDR
{
    USHORT  usSrcPort;
    USHORT  usDstPort;
    TCP_SEQ                 seqSeqNumber;
    TCP_SEQ                 seqAckNumber;
#if VRP_LITTLE_ENDIAN == VRP_YES
    UCHAR   ucX2:4,
                    ucOffset:4;
#else
    UCHAR   ucOffset:4, /* warning:nonstandard extension used : bit field types other than LONG. */
                    ucX2:4;     /* warning:nonstandard extension used : bit field types other than LONG. */
#endif
    UCHAR   ucFlags;
    USHORT      usWnd;
    USHORT      usCheckSum;
    USHORT      usUrgentPoint;
} TCPHDR_S;


/***************   from udp.h      ********************/
typedef struct tagUDPHDR
{
    USHORT    uh_usSPort;        /* source port */
    USHORT    uh_usDPort;        /* destination port */
    SHORT     uh_sULen;          /* udp length */
    USHORT    uh_usSum;          /* udp checksum */
}UDPHDR_S;


/***************   from ipp4_inc.h      ********************/
typedef ULONG (*IP_PP4_INTERMEDIATE_HOOK_FUNC)(struct tagMBuf *pstMBuf);


/***************   from icmp_pub.h      ********************/

typedef ULONG   NTIME;  /* ms since 00:00 GMT, byte rev */

typedef struct tagICMP
{
    UCHAR   icmp_chType;        /* type of message, see below */
    UCHAR   icmp_chCode;        /* type sub code */
    USHORT  icmp_usCksum;       /* ones complement cksum of struct */
    union
    {
        UCHAR   ih_chPPtr;              /* ICMP_PARAMPROB */
        struct tagINADDR ih_stGwAddr;   /* ICMP_REDIRECT */
        struct tagIHIDSEQ
        {
            USHORT  icd_nsId;
            USHORT  icd_nsSeq;
        } ih_stIdSeq;
                LONG     ih_nVoid;

        /* ICMP_UNREACH_NEEDFRAG -- Path MTU Discovery (RFC1191) */
        struct tagIHPMTU
        {
            USHORT ipm_nsVoid;
            USHORT ipm_nsNextMtu;
        } ih_stPMtu;
    }icmp_unHun;
#define icmp_chPPtr     icmp_unHun.ih_chPPtr
#define icmp_stGwAddr   icmp_unHun.ih_stGwAddr
#define icmp_nsId       icmp_unHun.ih_stIdSeq.icd_nsId
#define icmp_nsSeq      icmp_unHun.ih_stIdSeq.icd_nsSeq
#define icmp_nVoid      icmp_unHun.ih_nVoid
#define icmp_nsPmVoid   icmp_unHun.ih_stPMtu.ipm_nsVoid
#define icmp_nsNextMtu  icmp_unHun.ih_stPMtu.ipm_nsNextMtu
    union
    {
        struct tagIDTS
        {
            NTIME  its_ntOTime;
            NTIME  its_ntRTime;
            NTIME  its_ntTTime;
        } id_stTS;
        struct tagIDIP
        {
            struct tagIP idi_stIp;
            /* options and then 64 bits of data */
        } id_stIp;
        ULONG   id_ulMask;
        char    id_chData_a[9];
    } icmp_unDun;
#define icmp_ntOTime    icmp_unDun.id_stTS.its_ntOTime
#define icmp_ntRTime    icmp_unDun.id_stTS.its_ntRTime
#define icmp_ntTTime    icmp_unDun.id_stTS.its_ntTTime
#define icmp_stIp       icmp_unDun.id_stIp.idi_stIp
#define icmp_ulMask     icmp_unDun.id_ulMask
#define icmp_chData_a   icmp_unDun.id_chData_a
}ICMP_S;



#ifdef  __cplusplus
}
#endif  /* end of __cplusplus */

#endif  /* end of _VISP_IR_IP4PUB_H_ */

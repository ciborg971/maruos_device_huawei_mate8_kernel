/** ****************************************************************************

                    Huawei Technologies Sweden AB (C), 2001-2015

 ********************************************************************************
 * @author    Automatically generated by DAISY
 * @version
 * @date      2015-08-05
 * @file
 * @brief
 * @copyright Huawei Technologies Sweden AB
 *******************************************************************************/
#ifndef CTTF_HRPD_PA_PPP_PIF_H
#define CTTF_HRPD_PA_PPP_PIF_H

/*******************************************************************************
 1. Other files included
*******************************************************************************/

#include "vos.h"
#include "cttf_hrpd_pa_public_pif.h"
#include "cttf_hrpd_sig_public_pif.h"
#include "rlp_ppp_pub_pif.h"

#ifdef __cplusplus
#if __cplusplus
    extern "C" {
#endif /* __cpluscplus */
#endif /* __cpluscplus */
#pragma pack(4)

/*******************************************************************************
 2. Macro definitions
*******************************************************************************/

/**
 * Maximum number of profile ids in QoS negotiations.
 */
#define CTTF_HRPD_MAX_NUM_PROFILE_IDS                       ( 4 )
/**
 * Maximum number of reservation labels per QoS request supported. To reduce
 * size of QoS req message we do not want to alloc space for all reservations.
 * We think that 10 reservations (5 reservations in Fwd and 5 reservations in
 * Rev link) is enough per QoS request. Take VT app as an example. This app
 * would require 6 reservations (1 audio, 1 video and one SIP in each
 * direction).
 *
 * Note, this define means that we allow maximum of 5 reservations per fwd /
 * rev direction per QoS request.
 */
#define CTTF_HRPD_MAX_NUM_RESERVATIONS_PER_QOS_REQ          ( 5 )

/*******************************************************************************
 3. Enumerations declarations
*******************************************************************************/

/** ****************************************************************************
 * Name        : CTTF_HRPD_PA_PPP_PIF_MSG_TYPE_ENUM_UINT16
 *
 * Description :
 *******************************************************************************/
enum CTTF_HRPD_PA_PPP_PIF_MSG_TYPE_ENUM
{
    ID_CTTF_PPP_HRPD_CLOSE_RESERVATIONS_IND                 = 0x38A0, /**< @sa CTTF_PPP_HRPD_CLOSE_RESERVATIONS_IND_STRU */
    ID_CTTF_PPP_HRPD_OPEN_RESERVATION_IND                   = 0x38A1, /**< @sa CTTF_PPP_HRPD_OPEN_RESERVATION_IND_STRU */
    ID_CTTF_PPP_HRPD_RESERVATIONS_IND                       = 0x38A2, /**< @sa CTTF_PPP_HRPD_RESERVATIONS_IND_STRU */
    ID_CTTF_PPP_HRPD_RESTART_NW_IF_IND                      = 0x38A3, /**< @sa CTTF_PPP_HRPD_RESTART_NW_IF_IND_STRU */
    ID_PPP_CTTF_HRPD_EMPA_RESTART_NW_IF_RSP                 = 0x38A4, /**< @sa PPP_CTTF_HRPD_EMPA_RESTART_NW_IF_RSP_STRU */
    ID_PPP_CTTF_HRPD_PA_CLOSE_STREAM_REQ                    = 0x38A5, /**< @sa PPP_CTTF_HRPD_PA_CLOSE_STREAM_REQ_STRU */
    ID_PPP_CTTF_HRPD_PA_OPEN_STREAM_REQ                     = 0x38A6, /**< @sa PPP_CTTF_HRPD_PA_OPEN_STREAM_REQ_STRU */
    ID_CTTF_PPP_HRPD_COMMITTED_IND                          = 0x38A7, /**< @sa CTTF_PPP_HRPD_COMMITTED_IND_STRU */
    ID_PPP_CTTF_HRPD_MFPA_QOS_REQ                           = 0x38A8, /**< @sa PPP_CTTF_HRPD_MFPA_QOS_REQ_STRU */
    ID_PPP_CTTF_HRPD_MFPA_QOS_CLOSE_REQ                     = 0x38A9, /**< @sa PPP_CTTF_HRPD_MFPA_QOS_CLOSE_REQ_STRU */
    ID_CTTF_PPP_HRPD_RESERVATION_DL_MSG                     = 0x38AA, /**< @sa CTTF_PPP_HRPD_RESERVATION_DL_MSG_STRU */
    ID_CTTF_PPP_HRPD_ACCESS_AUTH_IND                        = 0x38AB, /**< @sa CTTF_PPP_HRPD_ACCESS_AUTH_IND_STRU */
    ID_CTTF_HRPD_PA_PPP_PIF_MSG_TYPE_ENUM_BUTT              = 0x38AC
};
typedef VOS_UINT16 CTTF_HRPD_PA_PPP_PIF_MSG_TYPE_ENUM_UINT16;

/*******************************************************************************
 4. Message Header declaration
*******************************************************************************/

/*******************************************************************************
 5. Message declaration
*******************************************************************************/

/*******************************************************************************
 6. STRUCT and UNION declaration
*******************************************************************************/

/** ****************************************************************************
 * Name        : CTTF_HRPD_QOS_STRU
 *
 * Description : ucReservationLabel : The reservation label for which QoS shall
 * be negotiated.
 * ucPriority: Priority to be used in QoS negotiation. Piriority of the IP flow
 * [0..15]
 * ucNumProfileIds: Number of proposed profile Ids.
 * ausProfileId: Proposed (set of) ProfileId to be used in QoS negotiation.
 *
 * Maximum number of alternative Profile Ids is set to 4. We think no more than
 * 4 proposals is realistic. This is to reduce message size.
 *******************************************************************************/
typedef struct
{
    VOS_UINT8                           ucReservationLabel;
    VOS_UINT8                           ucPriority;
    VOS_UINT8                           ucNumProfileIds;                             /**< MAX number is CTTF_HRPD_MAX_NUM_PROFILE_IDS */
    VOS_UINT8                           aucReserved[1];
    VOS_UINT16                          ausProfileId[CTTF_HRPD_MAX_NUM_PROFILE_IDS];
} CTTF_HRPD_QOS_STRU;

/*******************************************************************************
 7. OTHER declarations
*******************************************************************************/

/** ****************************************************************************
 * Name        : CTTF_PPP_HRPD_CLOSE_RESERVATIONS_IND_STRU
 *
 * Description : This signal is sent from PA to PPP when condition is fulfilled
 * to close reservation based on Connection Closed Req received from CAS and
 * reservation attribute ReservationKKIdleStateRev set to 0x01 or 0x02.  A list
 * of reservations that shall be closed is included in the message.
 *
 * PA does not send this indication directly upon detected condition as
 * described above. Instead PA will wait (at the moment 20ms) before issuing
 * this signal. This is to fulfill the requirement for hard handoff where
 * connection close and traffic channel assignment are received in the same
 * security layer packet. See C.S0063-A v2.0 section 2.5.4.2.1.1.3.1.
 *
 * Note, it is only Rev reservations that shall be closed.
 *******************************************************************************/
typedef struct
{
    VOS_MSG_HEADER
    CTTF_HRPD_PA_PPP_PIF_MSG_TYPE_ENUM_UINT16               enMsgId;
    VOS_UINT16                                              usOpId;
    VOS_UINT8                                               ucNumRevReservToClose;
    VOS_UINT8                                               aucResv1[3];
    VOS_UINT8                                               aucRevReservationLabel[CTTF_HRPD_PA_MAX_NUM_RESERV_LABELS];
} CTTF_PPP_HRPD_CLOSE_RESERVATIONS_IND_STRU;

/** ****************************************************************************
 * Name        : CTTF_PPP_HRPD_OPEN_RESERVATION_IND_STRU
 *
 * Description : This signal is sent from PA to PPP when condition is fulfilled
 * to open reservation based on Connection Opened Req received from CAS and
 * reservation attribute ReservationKKIdleStateRev set to 0x02.  A list of
 * reservations that shall be opened is included in the message.
 *
 * Note, it is only Rev reservations that shall be opened.
 *******************************************************************************/
typedef struct
{
    VOS_MSG_HEADER
    CTTF_HRPD_PA_PPP_PIF_MSG_TYPE_ENUM_UINT16               enMsgId;
    VOS_UINT16                                              usOpId;
    VOS_UINT8                                               ucNumRevReservToOpen;
    VOS_UINT8                                               aucResv1[3];
    VOS_UINT8                                               aucRevReservationLabel[CTTF_HRPD_PA_MAX_NUM_RESERV_LABELS];
} CTTF_PPP_HRPD_OPEN_RESERVATION_IND_STRU;

/** ****************************************************************************
 * Name        : CTTF_PPP_HRPD_RESERVATIONS_IND_STRU
 *
 * Description : PA sends this message to PPP upon CAS commit. MAX number of
 * reservations supported by AT is signallied to AN during session negotiation
 * (MaxNumReservations Fwd/Rev: 0x0f, MaxNumOpenReservationsFwd/Rev: 0x0f). But
 * in case AN negotiates less reservations than AT proposes then this needs to
 * be known by PPP. For example, PPP shall take Max number of reservations into
 * account when adding reservations in QoS request. Max number of reservations
 * are configured for Reverse and Forward respectively.
 *
 * PA will inform PPP about the value stored in SCP database. Note that the
 * attribute value indicates one less than the actual number of reservations.
 *******************************************************************************/
typedef struct
{
    VOS_MSG_HEADER
    CTTF_HRPD_PA_PPP_PIF_MSG_TYPE_ENUM_UINT16               enMsgId;
    VOS_UINT16                                              usOpId;
    VOS_UINT8                                               ucMaxNumReservationsFwd;
    VOS_UINT8                                               ucMaxNumReservationsRev;
    VOS_UINT8                                               ucMaxNumOpenReservationsFwd;
    VOS_UINT8                                               ucMaxNumOpenReservationsRev;
} CTTF_PPP_HRPD_RESERVATIONS_IND_STRU;

/** ****************************************************************************
 * Name        : CTTF_PPP_HRPD_RESTART_NW_IF_IND_STRU
 *
 * Description : This signal is sent from PA to PPP when a Restart Network
 * Interface message is received from the AN. A Transaction Id is provided
 * which shall be echoed back to PA when PPP issues the response back to PA.
 * Note that restart network interface is only defined in EMPA.
 *
 * It is stated that the Restart Network Interface message can make AT to
 * restart Network interface and perform DHCP again.
 *
 * Test case exists, but it only checks if an Ack is sent back to the AN.
 *******************************************************************************/
typedef struct
{
    VOS_MSG_HEADER
    CTTF_HRPD_PA_PPP_PIF_MSG_TYPE_ENUM_UINT16               enMsgId;
    VOS_UINT16                                              usOpId;
    VOS_UINT8                                               ucTransactionId;
    VOS_UINT8                                               aucResvd[3];
} CTTF_PPP_HRPD_RESTART_NW_IF_IND_STRU;

/** ****************************************************************************
 * Name        : PPP_CTTF_HRPD_EMPA_RESTART_NW_IF_RSP_STRU
 *
 * Description : This signal is sent as a response from PPP to PA on the
 * CTTF_PPP_HRPD_RESTART_NW_IF_IND. A transaction Id parameter shall be
 * provided. The transaction Id shall match the one received in the
 * CTTF_PPP_HRPD_RESTART_NW_IF_IND. The transaction Id is used in the ack sent
 * back to the AN.
 *******************************************************************************/
typedef struct
{
    VOS_MSG_HEADER
    CTTF_HRPD_PA_PPP_PIF_MSG_TYPE_ENUM_UINT16               enMsgId;
    VOS_UINT16                                              usOpId;
    VOS_UINT8                                               ucTransactionId;
    VOS_UINT8                                               aucResvd[3];
} PPP_CTTF_HRPD_EMPA_RESTART_NW_IF_RSP_STRU;

/** ****************************************************************************
 * Name        : PPP_CTTF_HRPD_PA_CLOSE_STREAM_REQ_STRU
 *
 * Description : This signal is sent from PPP to PA when streams shall be
 * closed. PA will in turn send XoffReq for all the bounded streams to the AN.
 *******************************************************************************/
typedef struct
{
    VOS_MSG_HEADER
    CTTF_HRPD_PA_PPP_PIF_MSG_TYPE_ENUM_UINT16               enMsgId;
    VOS_UINT16                                              usOpId;
} PPP_CTTF_HRPD_PA_CLOSE_STREAM_REQ_STRU;

/** ****************************************************************************
 * Name        : PPP_CTTF_HRPD_PA_OPEN_STREAM_REQ_STRU
 *
 * Description : This signal is sent from PPP to PA when streams shall be
 * opened. PA will in turn send XonReq to AN for all the bounded streams.
 *******************************************************************************/
typedef struct
{
    VOS_MSG_HEADER
    CTTF_HRPD_PA_PPP_PIF_MSG_TYPE_ENUM_UINT16               enMsgId;
    VOS_UINT16                                              usOpId;
} PPP_CTTF_HRPD_PA_OPEN_STREAM_REQ_STRU;

/** ****************************************************************************
 * Name        : CTTF_PPP_HRPD_COMMITTED_IND_STRU
 *
 * Description : Notifies PPP about application types that has been negotiated.
 * One application type per stream. There are 4 streams but stream 0 is always
 * bound to signaling. Thus, we can have different Packet applications bound to
 * stream 1, 2 and 3.
 *******************************************************************************/
typedef struct
{
    VOS_MSG_HEADER
    CTTF_HRPD_PA_PPP_PIF_MSG_TYPE_ENUM_UINT16               enMsgId;
    VOS_UINT16                                              usOpId;
    CTTF_HRPD_PA_APPLICATION_TYPE_ENUM_UINT16               enApplicationType[3];
    VOS_UINT8                                               aucRsvd[2];
} CTTF_PPP_HRPD_COMMITTED_IND_STRU;

/** ****************************************************************************
 * Name        : PPP_CTTF_HRPD_MFPA_QOS_REQ_STRU
 *
 * Description : This signal shall be sent to PA when an applications requesing
 * QoS is started. QoS negotiation will be performed between the AN and PA.
 * Note, this signal is applicable for both MFPA and EMPA.
 *
 * -  ucStreamNumber: Relates to the stream number for the MFPA. We assume
 *    there will only be one stream mapped to MFPA, but we include this
 *    parameter in case it will be needed. PPP gets the stream / MFPA mapping
 *    in ghe CTTF_PPP_HRPD_COMMITTED_IND.
 * -  ucNumFwdReservations: Specifies the number of Fwd reservations
 *    configured.
 * -  ucNumRevReservations: Specifies the number of Rev reservations
 *    configured.
 * -  astFwdReservations: Array of configuration parameters needed in QoS
 *    negotiation for Fwd.
 * -  astRevReservations: Array of configuration parameters needed in QoS
 *    negotiation for Rev.
 * Referemce: see testcase 18.27 in C.S0044-D
 *
 * QoS negotiation will be performed upon reception of this signal. PA will
 * assemble QoS BLOB and forward request to SCP. SCP will perform the actual
 * negotiation. GAUP protocol will be used. AN will then send FlowNN parameters
 * to SCP. SCP will notify PA and MAC. PA and MAC reads the updated parameters
 * from the SCP database.
 *
 * Note, currently there is no way for PA to know if QoS is completed or not.
 * Thus, PA can not notify PPP about this.
 *******************************************************************************/
typedef struct
{
    VOS_MSG_HEADER
    CTTF_HRPD_PA_PPP_PIF_MSG_TYPE_ENUM_UINT16               enMsgId;
    VOS_UINT16                                              usOpId;
    VOS_UINT8                                               ucStreamNumber;                                                 /**< Relates to the stream number for the MFPA/EMPA */
    VOS_UINT8                                               ucNumFwdReservations;                                           /**< Number of reservation labels 1..CTTF_HRPD_MAX_NUM_RESERVATIONS_PER_QOS_REQ */
    VOS_UINT8                                               ucNumRevReservations;                                           /**< Number of reservation labels 1..CTTF_HRPD_MAX_NUM_RESERVATIONS_PER_QOS_REQ */
    VOS_UINT8                                               ausRsvd[1];
    CTTF_HRPD_QOS_STRU                                      astFwdReservations[CTTF_HRPD_MAX_NUM_RESERVATIONS_PER_QOS_REQ]; /**< Parameters for each reservation */
    CTTF_HRPD_QOS_STRU                                      astRevReservations[CTTF_HRPD_MAX_NUM_RESERVATIONS_PER_QOS_REQ]; /**< Parameters for each reservation */
} PPP_CTTF_HRPD_MFPA_QOS_REQ_STRU;

/** ****************************************************************************
 * Name        : PPP_CTTF_HRPD_MFPA_QOS_CLOSE_REQ_STRU
 *
 * Description : Closes QOS allocations. Note, this signal is applicable both
 * for MFPA and EMPA.
 *
 * See reference C.S0044-D 18.30. MFPA will upon this command send
 * ReservationKKQoSRequest(s) to AN with profile type set to NULL.
 *******************************************************************************/
typedef struct
{
    VOS_MSG_HEADER
    CTTF_HRPD_PA_PPP_PIF_MSG_TYPE_ENUM_UINT16               enMsgId;
    VOS_UINT16                                              usOpId;
    VOS_UINT8                                               ucNumFwdReservations;                                                /**< Number of reservation labels 1..Max reservations */
    VOS_UINT8                                               ucNumRevReservations;                                                /**< Number of reservation labels 1..Max reservations */
    VOS_UINT8                                               aucFwdReservationLabels[CTTF_HRPD_MAX_NUM_RESERVATIONS_PER_QOS_REQ];
    VOS_UINT8                                               aucRevReservationLabels[CTTF_HRPD_MAX_NUM_RESERVATIONS_PER_QOS_REQ];
} PPP_CTTF_HRPD_MFPA_QOS_CLOSE_REQ_STRU;

/** ****************************************************************************
 * Name        : CTTF_PPP_HRPD_RESERVATION_DL_MSG_STRU
 *
 * Description : PA forwards DL reservation messages from SNP to PPP. PA will
 * allocate more memory if needed (if message is longer than 4 bytes).
 *******************************************************************************/
typedef struct
{
    VOS_MSG_HEADER
    CTTF_HRPD_PA_PPP_PIF_MSG_TYPE_ENUM_UINT16               enMsgId;
    VOS_UINT16                                              usOpId;
    VOS_UINT16                                              usMsgLen;      /**< Length of reservation message to send in bytes */
    VOS_UINT8                                               aucReserv1[2];
    VOS_UINT8                                               aucData[4];    /**< Content of reservation messages */
} CTTF_PPP_HRPD_RESERVATION_DL_MSG_STRU;

/** ****************************************************************************
 * Name        : CTTF_PPP_HRPD_ACCESS_AUTH_IND_STRU
 *
 * Description : It's used to initiates PPP and LCP negotiations for access
 * authentication between AT and AN. It refers to section 2.4.1 in
 * A.S0008-A_v3.0.
 *
 * It's a different PPP session with session between AT and HSGW, which is used
 * on packet data service. It refers to section 3.1 and 4.1.2 in
 * A.S0008-A_v3.0.
 *******************************************************************************/
typedef struct
{
    VOS_MSG_HEADER
    CTTF_HRPD_PA_PPP_PIF_MSG_TYPE_ENUM_UINT16               enMsgId;
    VOS_UINT16                                              usOpId;
} CTTF_PPP_HRPD_ACCESS_AUTH_IND_STRU;

/*******************************************************************************
 8. Global  declaration
*******************************************************************************/

/*******************************************************************************
 9. Function declarations
*******************************************************************************/

/** ****************************************************************************
 * Name        : CTTF_HRPD_RPA_AddToRlpTxQueue
 *
 * Description : The function delivers data to CTTF_HRPD_RRLP. The function
 * adds data to the TX queue.
 *
 * @param[in,out] pstTxData
 *******************************************************************************/
VOS_VOID CTTF_HRPD_RPA_AddToRlpTxQueue(PPP_RLP_HRPD_TRANS_DATA_STRU *pstTxData);

/** ****************************************************************************
 * Name        : CTTF_HRPD_RPA_SendReservationMsgToSnp
 *
 * Description : PA function to be used by PPP when PPP sends message to SNP on
 * behalf of PA.
 *
 * @param[in,out] pstMsgData     Length in bytes
 *******************************************************************************/
VOS_VOID CTTF_HRPD_RPA_SendReservationMsgToSnp(SNPITF_MSG_DATA_STRU *pstMsgData);

#if ((VOS_OS_VER == VOS_WIN32) || (VOS_OS_VER == VOS_NUCLEUS))
#pragma pack()
#else
#pragma pack(0)
#endif

#ifdef __cplusplus
#if __cplusplus
}
#endif /* __cpluscplus */
#endif /* __cpluscplus */

#endif

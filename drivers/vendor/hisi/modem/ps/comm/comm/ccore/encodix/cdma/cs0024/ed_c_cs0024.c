/**************************************************************************
	Generated automatically by Codegenix(TM) - (c) 2000-2004 Dafocus
	EnDec version 1.0.154
	GENERATOR: ed-c
	http://www.Dafocus.it/
**************************************************************************/
/*lint -e959 -e530 -e774 -e572 -e778 -e525 -e539 -e701 -e123 -e438 -e119 -e506 -e529 -e550 -e666 -e713 -e719 -e730 -e734 -e744 -e801 -e801 -e813 -e830 -e40 */
#define ENCODIX_CS0024

#include "ed_c_cs0024.h"
#include "ed_lib.h"
#if ED_COMMON_CRC != 0x328E3625 && ED_VERSION != 10152 && ED_VERSION != 10153
#error Invalid Encodix library files linked; used those distributed with Encodix 1.0.154
#endif


/* Free function for variable-sized sequence c_Air_Multi_Flow_Packet_Application_Attributes_SupportedHigherLayerProtocols_data01_data_data02 */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_SupportedHigherLayerProtocols_data01_data_data02 (c_Air_Multi_Flow_Packet_Application_Attributes_SupportedHigherLayerProtocols_data01_data_data02* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_Air_Multi_Flow_Packet_Application_Attributes_SupportedHigherLayerProtocols_data01 */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_SupportedHigherLayerProtocols_data01 (c_Air_Multi_Flow_Packet_Application_Attributes_SupportedHigherLayerProtocols_data01* sp) {
	int i, i0;
	for (i=0; i<sp->items; i++) {
		for (i0=0; i0<sp->data[i]->data02.items; i0++) {
			EDFree (sp->data[i]->data02.data[i0]);
			sp->data[i]->data02.data[i0] = NULL;
		}
		if (sp->data[i]->data02.data) {EDFree (sp->data[i]->data02.data); sp->data[i]->data02.data = NULL; sp->data[i]->data02.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multi_Flow_Packet_Application_Attributes_SupportedHigherLayerProtocols */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_SupportedHigherLayerProtocols (c_Air_Multi_Flow_Packet_Application_Attributes_SupportedHigherLayerProtocols* sp) {
	int i0;
	int i1;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		for (i1=0; i1<sp->data01.data[i0]->data02.items; i1++) {
			EDFree (sp->data01.data[i0]->data02.data[i1]);
			sp->data01.data[i0]->data02.data[i1] = NULL;
		}
		if (sp->data01.data[i0]->data02.data) {EDFree (sp->data01.data[i0]->data02.data); sp->data01.data[i0]->data02.data = NULL; sp->data01.data[i0]->data02.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multi_Flow_Packet_Application_Attributes_ATSupportedQoSProfiles_data01 */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_ATSupportedQoSProfiles_data01 (c_Air_Multi_Flow_Packet_Application_Attributes_ATSupportedQoSProfiles_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->ProfileValue.value != NULL) {
			EDFree (sp->data[i]->ProfileValue.value);
			sp->data[i]->ProfileValue.value = NULL;
		}
		sp->data[i]->ProfileValue.usedBits = 0;
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multi_Flow_Packet_Application_Attributes_ATSupportedQoSProfiles */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_ATSupportedQoSProfiles (c_Air_Multi_Flow_Packet_Application_Attributes_ATSupportedQoSProfiles* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->ProfileValue.value != NULL) {
			EDFree (sp->data01.data[i0]->ProfileValue.value);
			sp->data01.data[i0]->ProfileValue.value = NULL;
		}
		sp->data01.data[i0]->ProfileValue.usedBits = 0;
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multi_Flow_Packet_Application_Attributes_ANSupportedQoSProfiles_data01 */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_ANSupportedQoSProfiles_data01 (c_Air_Multi_Flow_Packet_Application_Attributes_ANSupportedQoSProfiles_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->ProfileValue.value != NULL) {
			EDFree (sp->data[i]->ProfileValue.value);
			sp->data[i]->ProfileValue.value = NULL;
		}
		sp->data[i]->ProfileValue.usedBits = 0;
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multi_Flow_Packet_Application_Attributes_ANSupportedQoSProfiles */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_ANSupportedQoSProfiles (c_Air_Multi_Flow_Packet_Application_Attributes_ANSupportedQoSProfiles* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->ProfileValue.value != NULL) {
			EDFree (sp->data01.data[i0]->ProfileValue.value);
			sp->data01.data[i0]->ProfileValue.value = NULL;
		}
		sp->data01.data[i0]->ProfileValue.usedBits = 0;
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multi_Flow_Packet_Application_Attributes_MaxRLPFlows_data01 */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_MaxRLPFlows_data01 (c_Air_Multi_Flow_Packet_Application_Attributes_MaxRLPFlows_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multi_Flow_Packet_Application_Attributes_MaxRLPFlows */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_MaxRLPFlows (c_Air_Multi_Flow_Packet_Application_Attributes_MaxRLPFlows* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multi_Flow_Packet_Application_Attributes_MaxReservations_data01 */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_MaxReservations_data01 (c_Air_Multi_Flow_Packet_Application_Attributes_MaxReservations_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multi_Flow_Packet_Application_Attributes_MaxReservations */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_MaxReservations (c_Air_Multi_Flow_Packet_Application_Attributes_MaxReservations* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationFwd_data01_data_data02 */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationFwd_data01_data_data02 (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationFwd_data01_data_data02* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->RLPID.value != NULL) {
			EDFree (sp->data[i]->RLPID.value);
			sp->data[i]->RLPID.value = NULL;
		}
		sp->data[i]->RLPID.usedBits = 0;
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationFwd_data01 */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationFwd_data01 (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationFwd_data01* sp) {
	int i, i0;
	for (i=0; i<sp->items; i++) {
		for (i0=0; i0<sp->data[i]->data02.items; i0++) {
			if (sp->data[i]->data02.data[i0]->RLPID.value != NULL) {
				EDFree (sp->data[i]->data02.data[i0]->RLPID.value);
				sp->data[i]->data02.data[i0]->RLPID.value = NULL;
			}
			sp->data[i]->data02.data[i0]->RLPID.usedBits = 0;
			EDFree (sp->data[i]->data02.data[i0]);
			sp->data[i]->data02.data[i0] = NULL;
		}
		if (sp->data[i]->data02.data) {EDFree (sp->data[i]->data02.data); sp->data[i]->data02.data = NULL; sp->data[i]->data02.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationFwd */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationFwd (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationFwd* sp) {
	int i0;
	int i1;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		for (i1=0; i1<sp->data01.data[i0]->data02.items; i1++) {
			if (sp->data01.data[i0]->data02.data[i1]->RLPID.value != NULL) {
				EDFree (sp->data01.data[i0]->data02.data[i1]->RLPID.value);
				sp->data01.data[i0]->data02.data[i1]->RLPID.value = NULL;
			}
			sp->data01.data[i0]->data02.data[i1]->RLPID.usedBits = 0;
			EDFree (sp->data01.data[i0]->data02.data[i1]);
			sp->data01.data[i0]->data02.data[i1] = NULL;
		}
		if (sp->data01.data[i0]->data02.data) {EDFree (sp->data01.data[i0]->data02.data); sp->data01.data[i0]->data02.data = NULL; sp->data01.data[i0]->data02.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationRev_data01_data_data02 */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationRev_data01_data_data02 (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationRev_data01_data_data02* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->RLPID.value != NULL) {
			EDFree (sp->data[i]->RLPID.value);
			sp->data[i]->RLPID.value = NULL;
		}
		sp->data[i]->RLPID.usedBits = 0;
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationRev_data01 */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationRev_data01 (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationRev_data01* sp) {
	int i, i0;
	for (i=0; i<sp->items; i++) {
		for (i0=0; i0<sp->data[i]->data02.items; i0++) {
			if (sp->data[i]->data02.data[i0]->RLPID.value != NULL) {
				EDFree (sp->data[i]->data02.data[i0]->RLPID.value);
				sp->data[i]->data02.data[i0]->RLPID.value = NULL;
			}
			sp->data[i]->data02.data[i0]->RLPID.usedBits = 0;
			EDFree (sp->data[i]->data02.data[i0]);
			sp->data[i]->data02.data[i0] = NULL;
		}
		if (sp->data[i]->data02.data) {EDFree (sp->data[i]->data02.data); sp->data[i]->data02.data = NULL; sp->data[i]->data02.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationRev */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationRev (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationRev* sp) {
	int i0;
	int i1;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		for (i1=0; i1<sp->data01.data[i0]->data02.items; i1++) {
			if (sp->data01.data[i0]->data02.data[i1]->RLPID.value != NULL) {
				EDFree (sp->data01.data[i0]->data02.data[i1]->RLPID.value);
				sp->data01.data[i0]->data02.data[i1]->RLPID.value = NULL;
			}
			sp->data01.data[i0]->data02.data[i1]->RLPID.usedBits = 0;
			EDFree (sp->data01.data[i0]->data02.data[i1]);
			sp->data01.data[i0]->data02.data[i1] = NULL;
		}
		if (sp->data01.data[i0]->data02.data) {EDFree (sp->data01.data[i0]->data02.data); sp->data01.data[i0]->data02.data = NULL; sp->data01.data[i0]->data02.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersFwd_data01 */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersFwd_data01 (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersFwd_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersFwd */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersFwd (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersFwd* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersRev_data01 */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersRev_data01 (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersRev_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersRev */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersRev (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersRev* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationFwd_data01_data_data02 */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationFwd_data01_data_data02 (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationFwd_data01_data_data02* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationFwd_data01 */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationFwd_data01 (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationFwd_data01* sp) {
	int i, i0;
	for (i=0; i<sp->items; i++) {
		for (i0=0; i0<sp->data[i]->data02.items; i0++) {
			EDFree (sp->data[i]->data02.data[i0]);
			sp->data[i]->data02.data[i0] = NULL;
		}
		if (sp->data[i]->data02.data) {EDFree (sp->data[i]->data02.data); sp->data[i]->data02.data = NULL; sp->data[i]->data02.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationFwd */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationFwd (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationFwd* sp) {
	int i0;
	int i1;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		for (i1=0; i1<sp->data01.data[i0]->data02.items; i1++) {
			EDFree (sp->data01.data[i0]->data02.data[i1]);
			sp->data01.data[i0]->data02.data[i1] = NULL;
		}
		if (sp->data01.data[i0]->data02.data) {EDFree (sp->data01.data[i0]->data02.data); sp->data01.data[i0]->data02.data = NULL; sp->data01.data[i0]->data02.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationRev_data01_data_data02 */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationRev_data01_data_data02 (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationRev_data01_data_data02* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationRev_data01 */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationRev_data01 (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationRev_data01* sp) {
	int i, i0;
	for (i=0; i<sp->items; i++) {
		for (i0=0; i0<sp->data[i]->data02.items; i0++) {
			EDFree (sp->data[i]->data02.data[i0]);
			sp->data[i]->data02.data[i0] = NULL;
		}
		if (sp->data[i]->data02.data) {EDFree (sp->data[i]->data02.data); sp->data[i]->data02.data = NULL; sp->data[i]->data02.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationRev */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationRev (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationRev* sp) {
	int i0;
	int i1;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		for (i1=0; i1<sp->data01.data[i0]->data02.items; i1++) {
			EDFree (sp->data01.data[i0]->data02.data[i1]);
			sp->data01.data[i0]->data02.data[i1] = NULL;
		}
		if (sp->data01.data[i0]->data02.data) {EDFree (sp->data01.data[i0]->data02.data); sp->data01.data[i0]->data02.data = NULL; sp->data01.data[i0]->data02.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestFwd_data01 */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestFwd_data01 (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestFwd_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->ProfileValue.value != NULL) {
			EDFree (sp->data[i]->ProfileValue.value);
			sp->data[i]->ProfileValue.value = NULL;
		}
		sp->data[i]->ProfileValue.usedBits = 0;
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestFwd */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestFwd (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestFwd* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->ProfileValue.value != NULL) {
			EDFree (sp->data01.data[i0]->ProfileValue.value);
			sp->data01.data[i0]->ProfileValue.value = NULL;
		}
		sp->data01.data[i0]->ProfileValue.usedBits = 0;
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestRev_data01 */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestRev_data01 (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestRev_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->ProfileValue.value != NULL) {
			EDFree (sp->data[i]->ProfileValue.value);
			sp->data[i]->ProfileValue.value = NULL;
		}
		sp->data[i]->ProfileValue.usedBits = 0;
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestRev */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestRev (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestRev* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->ProfileValue.value != NULL) {
			EDFree (sp->data01.data[i0]->ProfileValue.value);
			sp->data01.data[i0]->ProfileValue.value = NULL;
		}
		sp->data01.data[i0]->ProfileValue.usedBits = 0;
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseFwd_data01 */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseFwd_data01 (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseFwd_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->ProfileValue.value != NULL) {
			EDFree (sp->data[i]->ProfileValue.value);
			sp->data[i]->ProfileValue.value = NULL;
		}
		sp->data[i]->ProfileValue.usedBits = 0;
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseFwd */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseFwd (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseFwd* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->ProfileValue.value != NULL) {
			EDFree (sp->data01.data[i0]->ProfileValue.value);
			sp->data01.data[i0]->ProfileValue.value = NULL;
		}
		sp->data01.data[i0]->ProfileValue.usedBits = 0;
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseRev_data01 */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseRev_data01 (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseRev_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->ProfileValue.value != NULL) {
			EDFree (sp->data[i]->ProfileValue.value);
			sp->data[i]->ProfileValue.value = NULL;
		}
		sp->data[i]->ProfileValue.usedBits = 0;
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseRev */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseRev (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseRev* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->ProfileValue.value != NULL) {
			EDFree (sp->data01.data[i0]->ProfileValue.value);
			sp->data01.data[i0]->ProfileValue.value = NULL;
		}
		sp->data01.data[i0]->ProfileValue.usedBits = 0;
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Default_Stream_Protocol_Attributes_StreamConfiguration_data01 */
void FREE_c_Air_Default_Stream_Protocol_Attributes_StreamConfiguration_data01 (c_Air_Default_Stream_Protocol_Attributes_StreamConfiguration_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Default_Stream_Protocol_Attributes_StreamConfiguration */
void FREE_c_Air_Default_Stream_Protocol_Attributes_StreamConfiguration (c_Air_Default_Stream_Protocol_Attributes_StreamConfiguration* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Default_Session_Configuration_Protocol_Attributes_PriorSession_data01 */
void FREE_c_Air_Default_Session_Configuration_Protocol_Attributes_PriorSession_data01 (c_Air_Default_Session_Configuration_Protocol_Attributes_PriorSession_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->UATI_Present) {
			EDFree (sp->data[i]->UATI);
		}
		if (sp->data[i]->SecurityPacketLength_Present) {
		}
		if (sp->data[i]->SecurityPacket.value != NULL) {
			EDFree (sp->data[i]->SecurityPacket.value);
			sp->data[i]->SecurityPacket.value = NULL;
		}
		sp->data[i]->SecurityPacket.usedBits = 0;
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Default_Session_Configuration_Protocol_Attributes_PriorSession */
void FREE_c_Air_Default_Session_Configuration_Protocol_Attributes_PriorSession (c_Air_Default_Session_Configuration_Protocol_Attributes_PriorSession* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->UATI_Present) {
			EDFree (sp->data01.data[i0]->UATI);
		}
		if (sp->data01.data[i0]->SecurityPacketLength_Present) {
		}
		if (sp->data01.data[i0]->SecurityPacket.value != NULL) {
			EDFree (sp->data01.data[i0]->SecurityPacket.value);
			sp->data01.data[i0]->SecurityPacket.value = NULL;
		}
		sp->data01.data[i0]->SecurityPacket.usedBits = 0;
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Default_Session_Configuration_Protocol_Attributes_ATSupportedApplicationSubtypes_data01_data_data02 */
void FREE_c_Air_Default_Session_Configuration_Protocol_Attributes_ATSupportedApplicationSubtypes_data01_data_data02 (c_Air_Default_Session_Configuration_Protocol_Attributes_ATSupportedApplicationSubtypes_data01_data_data02* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_Air_Default_Session_Configuration_Protocol_Attributes_ATSupportedApplicationSubtypes_data01 */
void FREE_c_Air_Default_Session_Configuration_Protocol_Attributes_ATSupportedApplicationSubtypes_data01 (c_Air_Default_Session_Configuration_Protocol_Attributes_ATSupportedApplicationSubtypes_data01* sp) {
	int i, i0;
	for (i=0; i<sp->items; i++) {
		for (i0=0; i0<sp->data[i]->data02.items; i0++) {
			EDFree (sp->data[i]->data02.data[i0]);
			sp->data[i]->data02.data[i0] = NULL;
		}
		if (sp->data[i]->data02.data) {EDFree (sp->data[i]->data02.data); sp->data[i]->data02.data = NULL; sp->data[i]->data02.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Default_Session_Configuration_Protocol_Attributes_ATSupportedApplicationSubtypes */
void FREE_c_Air_Default_Session_Configuration_Protocol_Attributes_ATSupportedApplicationSubtypes (c_Air_Default_Session_Configuration_Protocol_Attributes_ATSupportedApplicationSubtypes* sp) {
	int i0;
	int i1;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		for (i1=0; i1<sp->data01.data[i0]->data02.items; i1++) {
			EDFree (sp->data01.data[i0]->data02.data[i1]);
			sp->data01.data[i0]->data02.data[i1] = NULL;
		}
		if (sp->data01.data[i0]->data02.data) {EDFree (sp->data01.data[i0]->data02.data); sp->data01.data[i0]->data02.data = NULL; sp->data01.data[i0]->data02.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Default_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01 */
void FREE_c_Air_Default_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01 (c_Air_Default_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->PreferredControlChannelCycle_Present) {
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Default_Idle_State_Protocol_Attributes_PreferredControlChannelCycle */
void FREE_c_Air_Default_Idle_State_Protocol_Attributes_PreferredControlChannelCycle (c_Air_Default_Idle_State_Protocol_Attributes_PreferredControlChannelCycle* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->PreferredControlChannelCycle_Present) {
		}
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Enhanced_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01 */
void FREE_c_Air_Enhanced_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01 (c_Air_Enhanced_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->PreferredControlChannelCycle_Present) {
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Enhanced_Idle_State_Protocol_Attributes_PreferredControlChannelCycle */
void FREE_c_Air_Enhanced_Idle_State_Protocol_Attributes_PreferredControlChannelCycle (c_Air_Enhanced_Idle_State_Protocol_Attributes_PreferredControlChannelCycle* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->PreferredControlChannelCycle_Present) {
		}
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Enhanced_Idle_State_Protocol_Attributes_SlottedMode_data01 */
void FREE_c_Air_Enhanced_Idle_State_Protocol_Attributes_SlottedMode_data01 (c_Air_Enhanced_Idle_State_Protocol_Attributes_SlottedMode_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Enhanced_Idle_State_Protocol_Attributes_SlottedMode */
void FREE_c_Air_Enhanced_Idle_State_Protocol_Attributes_SlottedMode (c_Air_Enhanced_Idle_State_Protocol_Attributes_SlottedMode* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Enhanced_Idle_State_Protocol_Attributes_PagingMask_data01_data_data02 */
void FREE_c_Air_Enhanced_Idle_State_Protocol_Attributes_PagingMask_data01_data_data02 (c_Air_Enhanced_Idle_State_Protocol_Attributes_PagingMask_data01_data_data02* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_Air_Enhanced_Idle_State_Protocol_Attributes_PagingMask_data01 */
void FREE_c_Air_Enhanced_Idle_State_Protocol_Attributes_PagingMask_data01 (c_Air_Enhanced_Idle_State_Protocol_Attributes_PagingMask_data01* sp) {
	int i, i0;
	for (i=0; i<sp->items; i++) {
		for (i0=0; i0<sp->data[i]->data02.items; i0++) {
			EDFree (sp->data[i]->data02.data[i0]);
			sp->data[i]->data02.data[i0] = NULL;
		}
		if (sp->data[i]->data02.data) {EDFree (sp->data[i]->data02.data); sp->data[i]->data02.data = NULL; sp->data[i]->data02.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Enhanced_Idle_State_Protocol_Attributes_PagingMask */
void FREE_c_Air_Enhanced_Idle_State_Protocol_Attributes_PagingMask (c_Air_Enhanced_Idle_State_Protocol_Attributes_PagingMask* sp) {
	int i0;
	int i1;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		for (i1=0; i1<sp->data01.data[i0]->data02.items; i1++) {
			EDFree (sp->data01.data[i0]->data02.data[i1]);
			sp->data01.data[i0]->data02.data[i1] = NULL;
		}
		if (sp->data01.data[i0]->data02.data) {EDFree (sp->data01.data[i0]->data02.data); sp->data01.data[i0]->data02.data = NULL; sp->data01.data[i0]->data02.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Quick_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01 */
void FREE_c_Air_Quick_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01 (c_Air_Quick_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->PreferredControlChannelCycle_Present) {
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Quick_Idle_State_Protocol_Attributes_PreferredControlChannelCycle */
void FREE_c_Air_Quick_Idle_State_Protocol_Attributes_PreferredControlChannelCycle (c_Air_Quick_Idle_State_Protocol_Attributes_PreferredControlChannelCycle* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->PreferredControlChannelCycle_Present) {
		}
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Quick_Idle_State_Protocol_Attributes_SlottedMode_data01 */
void FREE_c_Air_Quick_Idle_State_Protocol_Attributes_SlottedMode_data01 (c_Air_Quick_Idle_State_Protocol_Attributes_SlottedMode_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Quick_Idle_State_Protocol_Attributes_SlottedMode */
void FREE_c_Air_Quick_Idle_State_Protocol_Attributes_SlottedMode (c_Air_Quick_Idle_State_Protocol_Attributes_SlottedMode* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Quick_Idle_State_Protocol_Attributes_PagingMask_data01_data_data02 */
void FREE_c_Air_Quick_Idle_State_Protocol_Attributes_PagingMask_data01_data_data02 (c_Air_Quick_Idle_State_Protocol_Attributes_PagingMask_data01_data_data02* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_Air_Quick_Idle_State_Protocol_Attributes_PagingMask_data01 */
void FREE_c_Air_Quick_Idle_State_Protocol_Attributes_PagingMask_data01 (c_Air_Quick_Idle_State_Protocol_Attributes_PagingMask_data01* sp) {
	int i, i0;
	for (i=0; i<sp->items; i++) {
		for (i0=0; i0<sp->data[i]->data02.items; i0++) {
			EDFree (sp->data[i]->data02.data[i0]);
			sp->data[i]->data02.data[i0] = NULL;
		}
		if (sp->data[i]->data02.data) {EDFree (sp->data[i]->data02.data); sp->data[i]->data02.data = NULL; sp->data[i]->data02.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Quick_Idle_State_Protocol_Attributes_PagingMask */
void FREE_c_Air_Quick_Idle_State_Protocol_Attributes_PagingMask (c_Air_Quick_Idle_State_Protocol_Attributes_PagingMask* sp) {
	int i0;
	int i1;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		for (i1=0; i1<sp->data01.data[i0]->data02.items; i1++) {
			EDFree (sp->data01.data[i0]->data02.data[i1]);
			sp->data01.data[i0]->data02.data[i1] = NULL;
		}
		if (sp->data01.data[i0]->data02.data) {EDFree (sp->data01.data[i0]->data02.data); sp->data01.data[i0]->data02.data = NULL; sp->data01.data[i0]->data02.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Quick_Idle_State_Protocol_Attributes_QuickPaging_data01 */
void FREE_c_Air_Quick_Idle_State_Protocol_Attributes_QuickPaging_data01 (c_Air_Quick_Idle_State_Protocol_Attributes_QuickPaging_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Quick_Idle_State_Protocol_Attributes_QuickPaging */
void FREE_c_Air_Quick_Idle_State_Protocol_Attributes_QuickPaging (c_Air_Quick_Idle_State_Protocol_Attributes_QuickPaging* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Default_Route_Update_Protocol_Attributes_SearchParameters_data01 */
void FREE_c_Air_Default_Route_Update_Protocol_Attributes_SearchParameters_data01 (c_Air_Default_Route_Update_Protocol_Attributes_SearchParameters_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Default_Route_Update_Protocol_Attributes_SearchParameters */
void FREE_c_Air_Default_Route_Update_Protocol_Attributes_SearchParameters (c_Air_Default_Route_Update_Protocol_Attributes_SearchParameters* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Default_Route_Update_Protocol_Attributes_SetManagementSameChannelParameters_data01 */
void FREE_c_Air_Default_Route_Update_Protocol_Attributes_SetManagementSameChannelParameters_data01 (c_Air_Default_Route_Update_Protocol_Attributes_SetManagementSameChannelParameters_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->SoftSlope_Present) {
		}
		if (sp->data[i]->AddIntercept_Present) {
		}
		if (sp->data[i]->DropIntercept_Present) {
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Default_Route_Update_Protocol_Attributes_SetManagementSameChannelParameters */
void FREE_c_Air_Default_Route_Update_Protocol_Attributes_SetManagementSameChannelParameters (c_Air_Default_Route_Update_Protocol_Attributes_SetManagementSameChannelParameters* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->SoftSlope_Present) {
		}
		if (sp->data01.data[i0]->AddIntercept_Present) {
		}
		if (sp->data01.data[i0]->DropIntercept_Present) {
		}
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Default_Route_Update_Protocol_Attributes_SetManagementDifferentChannelParameters_data01 */
void FREE_c_Air_Default_Route_Update_Protocol_Attributes_SetManagementDifferentChannelParameters_data01 (c_Air_Default_Route_Update_Protocol_Attributes_SetManagementDifferentChannelParameters_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->SoftSlope_Present) {
		}
		if (sp->data[i]->AddIntercept_Present) {
		}
		if (sp->data[i]->DropIntercept_Present) {
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Default_Route_Update_Protocol_Attributes_SetManagementDifferentChannelParameters */
void FREE_c_Air_Default_Route_Update_Protocol_Attributes_SetManagementDifferentChannelParameters (c_Air_Default_Route_Update_Protocol_Attributes_SetManagementDifferentChannelParameters* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->SoftSlope_Present) {
		}
		if (sp->data01.data[i0]->AddIntercept_Present) {
		}
		if (sp->data01.data[i0]->DropIntercept_Present) {
		}
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data_data03 */
void FREE_c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data_data03 (c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data_data03* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02 */
void FREE_c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02 (c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02* sp) {
	int i, i0;
	for (i=0; i<sp->items; i++) {
		for (i0=0; i0<sp->data[i]->data03.items; i0++) {
			EDFree (sp->data[i]->data03.data[i0]);
			sp->data[i]->data03.data[i0] = NULL;
		}
		if (sp->data[i]->data03.data) {EDFree (sp->data[i]->data03.data); sp->data[i]->data03.data = NULL; sp->data[i]->data03.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01 */
void FREE_c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01 (c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01* sp) {
	int i, i0, i1;
	for (i=0; i<sp->items; i++) {
		for (i0=0; i0<sp->data[i]->data02.items; i0++) {
			for (i1=0; i1<sp->data[i]->data02.data[i0]->data03.items; i1++) {
				EDFree (sp->data[i]->data02.data[i0]->data03.data[i1]);
				sp->data[i]->data02.data[i0]->data03.data[i1] = NULL;
			}
			if (sp->data[i]->data02.data[i0]->data03.data) {EDFree (sp->data[i]->data02.data[i0]->data03.data); sp->data[i]->data02.data[i0]->data03.data = NULL; sp->data[i]->data02.data[i0]->data03.allocatedItems=0; /*FR02A*/}
			EDFree (sp->data[i]->data02.data[i0]);
			sp->data[i]->data02.data[i0] = NULL;
		}
		if (sp->data[i]->data02.data) {EDFree (sp->data[i]->data02.data); sp->data[i]->data02.data = NULL; sp->data[i]->data02.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels */
void FREE_c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels (c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels* sp) {
	int i0;
	int i1;
	int i2;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		for (i1=0; i1<sp->data01.data[i0]->data02.items; i1++) {
			for (i2=0; i2<sp->data01.data[i0]->data02.data[i1]->data03.items; i2++) {
				EDFree (sp->data01.data[i0]->data02.data[i1]->data03.data[i2]);
				sp->data01.data[i0]->data02.data[i1]->data03.data[i2] = NULL;
			}
			if (sp->data01.data[i0]->data02.data[i1]->data03.data) {EDFree (sp->data01.data[i0]->data02.data[i1]->data03.data); sp->data01.data[i0]->data02.data[i1]->data03.data = NULL; sp->data01.data[i0]->data02.data[i1]->data03.allocatedItems=0; /*FR02A*/}
			EDFree (sp->data01.data[i0]->data02.data[i1]);
			sp->data01.data[i0]->data02.data[i1] = NULL;
		}
		if (sp->data01.data[i0]->data02.data) {EDFree (sp->data01.data[i0]->data02.data); sp->data01.data[i0]->data02.data = NULL; sp->data01.data[i0]->data02.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multicarrier_Route_Update_Protocol_Attributes_SearchParameters_data01 */
void FREE_c_Air_Multicarrier_Route_Update_Protocol_Attributes_SearchParameters_data01 (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SearchParameters_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multicarrier_Route_Update_Protocol_Attributes_SearchParameters */
void FREE_c_Air_Multicarrier_Route_Update_Protocol_Attributes_SearchParameters (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SearchParameters* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multicarrier_Route_Update_Protocol_Attributes_SetManagementParameters_data01 */
void FREE_c_Air_Multicarrier_Route_Update_Protocol_Attributes_SetManagementParameters_data01 (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SetManagementParameters_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->SoftSlope_Present) {
		}
		if (sp->data[i]->AddIntercept_Present) {
		}
		if (sp->data[i]->DropIntercept_Present) {
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multicarrier_Route_Update_Protocol_Attributes_SetManagementParameters */
void FREE_c_Air_Multicarrier_Route_Update_Protocol_Attributes_SetManagementParameters (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SetManagementParameters* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->SoftSlope_Present) {
		}
		if (sp->data01.data[i0]->AddIntercept_Present) {
		}
		if (sp->data01.data[i0]->DropIntercept_Present) {
		}
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data_data03 */
void FREE_c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data_data03 (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data_data03* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02 */
void FREE_c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02 (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02* sp) {
	int i, i0;
	for (i=0; i<sp->items; i++) {
		for (i0=0; i0<sp->data[i]->data03.items; i0++) {
			EDFree (sp->data[i]->data03.data[i0]);
			sp->data[i]->data03.data[i0] = NULL;
		}
		if (sp->data[i]->data03.data) {EDFree (sp->data[i]->data03.data); sp->data[i]->data03.data = NULL; sp->data[i]->data03.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01 */
void FREE_c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01 (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01* sp) {
	int i, i0, i1;
	for (i=0; i<sp->items; i++) {
		for (i0=0; i0<sp->data[i]->data02.items; i0++) {
			for (i1=0; i1<sp->data[i]->data02.data[i0]->data03.items; i1++) {
				EDFree (sp->data[i]->data02.data[i0]->data03.data[i1]);
				sp->data[i]->data02.data[i0]->data03.data[i1] = NULL;
			}
			if (sp->data[i]->data02.data[i0]->data03.data) {EDFree (sp->data[i]->data02.data[i0]->data03.data); sp->data[i]->data02.data[i0]->data03.data = NULL; sp->data[i]->data02.data[i0]->data03.allocatedItems=0; /*FR02A*/}
			EDFree (sp->data[i]->data02.data[i0]);
			sp->data[i]->data02.data[i0] = NULL;
		}
		if (sp->data[i]->data02.data) {EDFree (sp->data[i]->data02.data); sp->data[i]->data02.data = NULL; sp->data[i]->data02.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels */
void FREE_c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels* sp) {
	int i0;
	int i1;
	int i2;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		for (i1=0; i1<sp->data01.data[i0]->data02.items; i1++) {
			for (i2=0; i2<sp->data01.data[i0]->data02.data[i1]->data03.items; i2++) {
				EDFree (sp->data01.data[i0]->data02.data[i1]->data03.data[i2]);
				sp->data01.data[i0]->data02.data[i1]->data03.data[i2] = NULL;
			}
			if (sp->data01.data[i0]->data02.data[i1]->data03.data) {EDFree (sp->data01.data[i0]->data02.data[i1]->data03.data); sp->data01.data[i0]->data02.data[i1]->data03.data = NULL; sp->data01.data[i0]->data02.data[i1]->data03.allocatedItems=0; /*FR02A*/}
			EDFree (sp->data01.data[i0]->data02.data[i1]);
			sp->data01.data[i0]->data02.data[i1] = NULL;
		}
		if (sp->data01.data[i0]->data02.data) {EDFree (sp->data01.data[i0]->data02.data); sp->data01.data[i0]->data02.data = NULL; sp->data01.data[i0]->data02.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedDRXPatterns_data01_data_data02 */
void FREE_c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedDRXPatterns_data01_data_data02 (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedDRXPatterns_data01_data_data02* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedDRXPatterns_data01 */
void FREE_c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedDRXPatterns_data01 (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedDRXPatterns_data01* sp) {
	int i, i0;
	for (i=0; i<sp->items; i++) {
		for (i0=0; i0<sp->data[i]->data02.items; i0++) {
			EDFree (sp->data[i]->data02.data[i0]);
			sp->data[i]->data02.data[i0] = NULL;
		}
		if (sp->data[i]->data02.data) {EDFree (sp->data[i]->data02.data); sp->data[i]->data02.data = NULL; sp->data[i]->data02.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedDRXPatterns */
void FREE_c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedDRXPatterns (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedDRXPatterns* sp) {
	int i0;
	int i1;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		for (i1=0; i1<sp->data01.data[i0]->data02.items; i1++) {
			EDFree (sp->data01.data[i0]->data02.data[i1]);
			sp->data01.data[i0]->data02.data[i1] = NULL;
		}
		if (sp->data01.data[i0]->data02.data) {EDFree (sp->data01.data[i0]->data02.data); sp->data01.data[i0]->data02.data = NULL; sp->data01.data[i0]->data02.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Default_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration_data01 */
void FREE_c_Air_Default_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration_data01 (c_Air_Default_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Default_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration */
void FREE_c_Air_Default_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration (c_Air_Default_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Default_Access_Channel_MAC_Protocol_Attributes_PowerParameters_data01 */
void FREE_c_Air_Default_Access_Channel_MAC_Protocol_Attributes_PowerParameters_data01 (c_Air_Default_Access_Channel_MAC_Protocol_Attributes_PowerParameters_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Default_Access_Channel_MAC_Protocol_Attributes_PowerParameters */
void FREE_c_Air_Default_Access_Channel_MAC_Protocol_Attributes_PowerParameters (c_Air_Default_Access_Channel_MAC_Protocol_Attributes_PowerParameters* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration_data01 */
void FREE_c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration_data01 (c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration */
void FREE_c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration (c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01 */
void FREE_c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01 (c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays */
void FREE_c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays (c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCLock_data01 */
void FREE_c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCLock_data01 (c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCLock_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCLock */
void FREE_c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCLock (c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCLock* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01 */
void FREE_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01 (c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays */
void FREE_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays (c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCTranslationOffset_data01 */
void FREE_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCTranslationOffset_data01 (c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCTranslationOffset_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCTranslationOffset */
void FREE_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCTranslationOffset (c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCTranslationOffset* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01 */
void FREE_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01 (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays */
void FREE_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ATSupportedPacketFormats_data01 */
void FREE_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ATSupportedPacketFormats_data01 (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ATSupportedPacketFormats_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ATSupportedPacketFormats */
void FREE_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ATSupportedPacketFormats (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ATSupportedPacketFormats* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_TentativeDRCtoTxDRCMap_data01 */
void FREE_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_TentativeDRCtoTxDRCMap_data01 (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_TentativeDRCtoTxDRCMap_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_TentativeDRCtoTxDRCMap */
void FREE_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_TentativeDRCtoTxDRCMap (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_TentativeDRCtoTxDRCMap* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ExtendedSpans_data01 */
void FREE_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ExtendedSpans_data01 (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ExtendedSpans_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->PERTargetSpan_Present) {
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ExtendedSpans */
void FREE_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ExtendedSpans (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ExtendedSpans* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->PERTargetSpan_Present) {
		}
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters_data01 */
void FREE_c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters_data01 (c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters */
void FREE_c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters (c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters_data01 */
void FREE_c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters_data01 (c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters */
void FREE_c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters (c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters_data01 */
void FREE_c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters_data01 (c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters */
void FREE_c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters (c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters_data01 */
void FREE_c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters_data01 (c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters */
void FREE_c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters (c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters_data01 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters_data01 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPackets_data01 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPackets_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPackets_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPackets */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPackets (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPackets* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload_data01 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrength_data01_data_data02 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrength_data01_data_data02 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrength_data01_data_data02* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrength_data01 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrength_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrength_data01* sp) {
	int i, i0;
	for (i=0; i<sp->items; i++) {
		for (i0=0; i0<sp->data[i]->data02.items; i0++) {
			EDFree (sp->data[i]->data02.data[i0]);
			sp->data[i]->data02.data[i0] = NULL;
		}
		if (sp->data[i]->data02.data) {EDFree (sp->data[i]->data02.data); sp->data[i]->data02.data = NULL; sp->data[i]->data02.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrength */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrength (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrength* sp) {
	int i0;
	int i1;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		for (i1=0; i1<sp->data01.data[i0]->data02.items; i1++) {
			EDFree (sp->data01.data[i0]->data02.data[i1]);
			sp->data01.data[i0]->data02.data[i1] = NULL;
		}
		if (sp->data01.data[i0]->data02.data) {EDFree (sp->data01.data[i0]->data02.data); sp->data01.data[i0]->data02.data = NULL; sp->data01.data[i0]->data02.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128_data01 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256_data01 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512_data01 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768_data01 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024_data01 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536_data01 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048_data01 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072_data01 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096_data01 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144_data01 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192_data01 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288_data01 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters_data01 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters_data01 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2Pmax_data01_data_data02 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2Pmax_data01_data_data02 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2Pmax_data01_data_data02* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2Pmax_data01 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2Pmax_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2Pmax_data01* sp) {
	int i, i0;
	for (i=0; i<sp->items; i++) {
		for (i0=0; i0<sp->data[i]->data02.items; i0++) {
			EDFree (sp->data[i]->data02.data[i0]);
			sp->data[i]->data02.data[i0] = NULL;
		}
		if (sp->data[i]->data02.data) {EDFree (sp->data[i]->data02.data); sp->data[i]->data02.data = NULL; sp->data[i]->data02.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2Pmax */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2Pmax (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2Pmax* sp) {
	int i0;
	int i1;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		for (i1=0; i1<sp->data01.data[i0]->data02.items; i1++) {
			EDFree (sp->data01.data[i0]->data02.data[i1]);
			sp->data01.data[i0]->data02.data[i1] = NULL;
		}
		if (sp->data01.data[i0]->data02.data) {EDFree (sp->data01.data[i0]->data02.data); sp->data01.data[i0]->data02.data = NULL; sp->data01.data[i0]->data02.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows_data01 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data_data02 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data_data02 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data_data02* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01* sp) {
	int i, i0;
	for (i=0; i<sp->items; i++) {
		for (i0=0; i0<sp->data[i]->data02.items; i0++) {
			EDFree (sp->data[i]->data02.data[i0]);
			sp->data[i]->data02.data[i0] = NULL;
		}
		if (sp->data[i]->data02.data) {EDFree (sp->data[i]->data02.data); sp->data[i]->data02.data = NULL; sp->data[i]->data02.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN* sp) {
	int i0;
	int i1;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		for (i1=0; i1<sp->data01.data[i0]->data02.items; i1++) {
			EDFree (sp->data01.data[i0]->data02.data[i1]);
			sp->data01.data[i0]->data02.data[i1] = NULL;
		}
		if (sp->data01.data[i0]->data02.data) {EDFree (sp->data01.data[i0]->data02.data); sp->data01.data[i0]->data02.data = NULL; sp->data01.data[i0]->data02.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_T2PAxis */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_T2PAxis (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_T2PAxis* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_FRABAxis */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_FRABAxis (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_FRABAxis* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_BucketFactorT2PAxisFRABAxis */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_BucketFactorT2PAxisFRABAxis (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_BucketFactorT2PAxisFRABAxis* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->T2PAxis.data) {EDFree (sp->data[i]->T2PAxis.data); sp->data[i]->T2PAxis.data = NULL; sp->data[i]->T2PAxis.allocatedItems=0; /*FR02A*/}
		if (sp->data[i]->FRABAxis.data) {EDFree (sp->data[i]->FRABAxis.data); sp->data[i]->FRABAxis.data = NULL; sp->data[i]->FRABAxis.allocatedItems=0; /*FR02A*/}
		if (sp->data[i]->BucketFactorT2PAxisFRABAxis.data) {EDFree (sp->data[i]->BucketFactorT2PAxisFRABAxis.data); sp->data[i]->BucketFactorT2PAxisFRABAxis.data = NULL; sp->data[i]->BucketFactorT2PAxisFRABAxis.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->T2PAxis.data) {EDFree (sp->data01.data[i0]->T2PAxis.data); sp->data01.data[i0]->T2PAxis.data = NULL; sp->data01.data[i0]->T2PAxis.allocatedItems=0; /*FR02A*/}
		if (sp->data01.data[i0]->FRABAxis.data) {EDFree (sp->data01.data[i0]->FRABAxis.data); sp->data01.data[i0]->FRABAxis.data = NULL; sp->data01.data[i0]->FRABAxis.allocatedItems=0; /*FR02A*/}
		if (sp->data01.data[i0]->BucketFactorT2PAxisFRABAxis.data) {EDFree (sp->data01.data[i0]->BucketFactorT2PAxisFRABAxis.data); sp->data01.data[i0]->BucketFactorT2PAxisFRABAxis.data = NULL; sp->data01.data[i0]->BucketFactorT2PAxisFRABAxis.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeNN_data01 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeNN_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeNN_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeNN */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeNN (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeNN* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data02 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data02 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data02* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data03 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data03 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data03* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data04 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data04 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data04* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01 */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01* sp) {
	int i, i0;
	for (i=0; i<sp->items; i++) {
		for (i0=0; i0<sp->data[i]->data02.items; i0++) {
			EDFree (sp->data[i]->data02.data[i0]);
			sp->data[i]->data02.data[i0] = NULL;
		}
		if (sp->data[i]->data02.data) {EDFree (sp->data[i]->data02.data); sp->data[i]->data02.data = NULL; sp->data[i]->data02.allocatedItems=0; /*FR02A*/}
		for (i0=0; i0<sp->data[i]->data03.items; i0++) {
			EDFree (sp->data[i]->data03.data[i0]);
			sp->data[i]->data03.data[i0] = NULL;
		}
		if (sp->data[i]->data03.data) {EDFree (sp->data[i]->data03.data); sp->data[i]->data03.data = NULL; sp->data[i]->data03.allocatedItems=0; /*FR02A*/}
		for (i0=0; i0<sp->data[i]->data04.items; i0++) {
			EDFree (sp->data[i]->data04.data[i0]);
			sp->data[i]->data04.data[i0] = NULL;
		}
		if (sp->data[i]->data04.data) {EDFree (sp->data[i]->data04.data); sp->data[i]->data04.data = NULL; sp->data[i]->data04.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN* sp) {
	int i0;
	int i1;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		for (i1=0; i1<sp->data01.data[i0]->data02.items; i1++) {
			EDFree (sp->data01.data[i0]->data02.data[i1]);
			sp->data01.data[i0]->data02.data[i1] = NULL;
		}
		if (sp->data01.data[i0]->data02.data) {EDFree (sp->data01.data[i0]->data02.data); sp->data01.data[i0]->data02.data = NULL; sp->data01.data[i0]->data02.allocatedItems=0; /*FR02A*/}
		for (i1=0; i1<sp->data01.data[i0]->data03.items; i1++) {
			EDFree (sp->data01.data[i0]->data03.data[i1]);
			sp->data01.data[i0]->data03.data[i1] = NULL;
		}
		if (sp->data01.data[i0]->data03.data) {EDFree (sp->data01.data[i0]->data03.data); sp->data01.data[i0]->data03.data = NULL; sp->data01.data[i0]->data03.allocatedItems=0; /*FR02A*/}
		for (i1=0; i1<sp->data01.data[i0]->data04.items; i1++) {
			EDFree (sp->data01.data[i0]->data04.data[i1]);
			sp->data01.data[i0]->data04.data[i1] = NULL;
		}
		if (sp->data01.data[i0]->data04.data) {EDFree (sp->data01.data[i0]->data04.data); sp->data01.data[i0]->data04.data = NULL; sp->data01.data[i0]->data04.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters_data01 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters_data01 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload_data01 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128_data01 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256_data01 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512_data01 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768_data01 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024_data01 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536_data01 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048_data01 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072_data01 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096_data01 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144_data01 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192_data01 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288_data01 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters_data01 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters_data01 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows_data01 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data_data02 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data_data02 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data_data02* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01* sp) {
	int i, i0;
	for (i=0; i<sp->items; i++) {
		for (i0=0; i0<sp->data[i]->data02.items; i0++) {
			EDFree (sp->data[i]->data02.data[i0]);
			sp->data[i]->data02.data[i0] = NULL;
		}
		if (sp->data[i]->data02.data) {EDFree (sp->data[i]->data02.data); sp->data[i]->data02.data = NULL; sp->data[i]->data02.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN* sp) {
	int i0;
	int i1;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		for (i1=0; i1<sp->data01.data[i0]->data02.items; i1++) {
			EDFree (sp->data01.data[i0]->data02.data[i1]);
			sp->data01.data[i0]->data02.data[i1] = NULL;
		}
		if (sp->data01.data[i0]->data02.data) {EDFree (sp->data01.data[i0]->data02.data); sp->data01.data[i0]->data02.data = NULL; sp->data01.data[i0]->data02.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data_data03_data_data04 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data_data03_data_data04 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data_data03_data_data04* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data_data03 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data_data03 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data_data03* sp) {
	int i, i0;
	for (i=0; i<sp->items; i++) {
		for (i0=0; i0<sp->data[i]->data04.items; i0++) {
			EDFree (sp->data[i]->data04.data[i0]);
			sp->data[i]->data04.data[i0] = NULL;
		}
		if (sp->data[i]->data04.data) {EDFree (sp->data[i]->data04.data); sp->data[i]->data04.data = NULL; sp->data[i]->data04.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02* sp) {
	int i, i0, i1;
	for (i=0; i<sp->items; i++) {
		for (i0=0; i0<sp->data[i]->data03.items; i0++) {
			for (i1=0; i1<sp->data[i]->data03.data[i0]->data04.items; i1++) {
				EDFree (sp->data[i]->data03.data[i0]->data04.data[i1]);
				sp->data[i]->data03.data[i0]->data04.data[i1] = NULL;
			}
			if (sp->data[i]->data03.data[i0]->data04.data) {EDFree (sp->data[i]->data03.data[i0]->data04.data); sp->data[i]->data03.data[i0]->data04.data = NULL; sp->data[i]->data03.data[i0]->data04.allocatedItems=0; /*FR02A*/}
			EDFree (sp->data[i]->data03.data[i0]);
			sp->data[i]->data03.data[i0] = NULL;
		}
		if (sp->data[i]->data03.data) {EDFree (sp->data[i]->data03.data); sp->data[i]->data03.data = NULL; sp->data[i]->data03.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01* sp) {
	int i, i0, i1, i2;
	for (i=0; i<sp->items; i++) {
		for (i0=0; i0<sp->data[i]->data02.items; i0++) {
			for (i1=0; i1<sp->data[i]->data02.data[i0]->data03.items; i1++) {
				for (i2=0; i2<sp->data[i]->data02.data[i0]->data03.data[i1]->data04.items; i2++) {
					EDFree (sp->data[i]->data02.data[i0]->data03.data[i1]->data04.data[i2]);
					sp->data[i]->data02.data[i0]->data03.data[i1]->data04.data[i2] = NULL;
				}
				if (sp->data[i]->data02.data[i0]->data03.data[i1]->data04.data) {EDFree (sp->data[i]->data02.data[i0]->data03.data[i1]->data04.data); sp->data[i]->data02.data[i0]->data03.data[i1]->data04.data = NULL; sp->data[i]->data02.data[i0]->data03.data[i1]->data04.allocatedItems=0; /*FR02A*/}
				EDFree (sp->data[i]->data02.data[i0]->data03.data[i1]);
				sp->data[i]->data02.data[i0]->data03.data[i1] = NULL;
			}
			if (sp->data[i]->data02.data[i0]->data03.data) {EDFree (sp->data[i]->data02.data[i0]->data03.data); sp->data[i]->data02.data[i0]->data03.data = NULL; sp->data[i]->data02.data[i0]->data03.allocatedItems=0; /*FR02A*/}
			EDFree (sp->data[i]->data02.data[i0]);
			sp->data[i]->data02.data[i0] = NULL;
		}
		if (sp->data[i]->data02.data) {EDFree (sp->data[i]->data02.data); sp->data[i]->data02.data = NULL; sp->data[i]->data02.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN* sp) {
	int i0;
	int i1;
	int i2;
	int i3;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		for (i1=0; i1<sp->data01.data[i0]->data02.items; i1++) {
			for (i2=0; i2<sp->data01.data[i0]->data02.data[i1]->data03.items; i2++) {
				for (i3=0; i3<sp->data01.data[i0]->data02.data[i1]->data03.data[i2]->data04.items; i3++) {
					EDFree (sp->data01.data[i0]->data02.data[i1]->data03.data[i2]->data04.data[i3]);
					sp->data01.data[i0]->data02.data[i1]->data03.data[i2]->data04.data[i3] = NULL;
				}
				if (sp->data01.data[i0]->data02.data[i1]->data03.data[i2]->data04.data) {EDFree (sp->data01.data[i0]->data02.data[i1]->data03.data[i2]->data04.data); sp->data01.data[i0]->data02.data[i1]->data03.data[i2]->data04.data = NULL; sp->data01.data[i0]->data02.data[i1]->data03.data[i2]->data04.allocatedItems=0; /*FR02A*/}
				EDFree (sp->data01.data[i0]->data02.data[i1]->data03.data[i2]);
				sp->data01.data[i0]->data02.data[i1]->data03.data[i2] = NULL;
			}
			if (sp->data01.data[i0]->data02.data[i1]->data03.data) {EDFree (sp->data01.data[i0]->data02.data[i1]->data03.data); sp->data01.data[i0]->data02.data[i1]->data03.data = NULL; sp->data01.data[i0]->data02.data[i1]->data03.allocatedItems=0; /*FR02A*/}
			EDFree (sp->data01.data[i0]->data02.data[i1]);
			sp->data01.data[i0]->data02.data[i1] = NULL;
		}
		if (sp->data01.data[i0]->data02.data) {EDFree (sp->data01.data[i0]->data02.data); sp->data01.data[i0]->data02.data = NULL; sp->data01.data[i0]->data02.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeConfigXX_data01 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeConfigXX_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeConfigXX_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeConfigXX */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeConfigXX (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeConfigXX* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data02 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data02 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data02* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data03 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data03 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data03* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data04 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data04 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data04* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01* sp) {
	int i, i0;
	for (i=0; i<sp->items; i++) {
		for (i0=0; i0<sp->data[i]->data02.items; i0++) {
			EDFree (sp->data[i]->data02.data[i0]);
			sp->data[i]->data02.data[i0] = NULL;
		}
		if (sp->data[i]->data02.data) {EDFree (sp->data[i]->data02.data); sp->data[i]->data02.data = NULL; sp->data[i]->data02.allocatedItems=0; /*FR02A*/}
		for (i0=0; i0<sp->data[i]->data03.items; i0++) {
			EDFree (sp->data[i]->data03.data[i0]);
			sp->data[i]->data03.data[i0] = NULL;
		}
		if (sp->data[i]->data03.data) {EDFree (sp->data[i]->data03.data); sp->data[i]->data03.data = NULL; sp->data[i]->data03.allocatedItems=0; /*FR02A*/}
		for (i0=0; i0<sp->data[i]->data04.items; i0++) {
			EDFree (sp->data[i]->data04.data[i0]);
			sp->data[i]->data04.data[i0] = NULL;
		}
		if (sp->data[i]->data04.data) {EDFree (sp->data[i]->data04.data); sp->data[i]->data04.data = NULL; sp->data[i]->data04.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX* sp) {
	int i0;
	int i1;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		for (i1=0; i1<sp->data01.data[i0]->data02.items; i1++) {
			EDFree (sp->data01.data[i0]->data02.data[i1]);
			sp->data01.data[i0]->data02.data[i1] = NULL;
		}
		if (sp->data01.data[i0]->data02.data) {EDFree (sp->data01.data[i0]->data02.data); sp->data01.data[i0]->data02.data = NULL; sp->data01.data[i0]->data02.allocatedItems=0; /*FR02A*/}
		for (i1=0; i1<sp->data01.data[i0]->data03.items; i1++) {
			EDFree (sp->data01.data[i0]->data03.data[i1]);
			sp->data01.data[i0]->data03.data[i1] = NULL;
		}
		if (sp->data01.data[i0]->data03.data) {EDFree (sp->data01.data[i0]->data03.data); sp->data01.data[i0]->data03.data = NULL; sp->data01.data[i0]->data03.allocatedItems=0; /*FR02A*/}
		for (i1=0; i1<sp->data01.data[i0]->data04.items; i1++) {
			EDFree (sp->data01.data[i0]->data04.data[i1]);
			sp->data01.data[i0]->data04.data[i1] = NULL;
		}
		if (sp->data01.data[i0]->data04.data) {EDFree (sp->data01.data[i0]->data04.data); sp->data01.data[i0]->data04.data = NULL; sp->data01.data[i0]->data04.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowConfigurationsNC_data01 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowConfigurationsNC_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowConfigurationsNC_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowConfigurationsNC */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowConfigurationsNC (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowConfigurationsNC* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedATConfigurationsCC_data01 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedATConfigurationsCC_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedATConfigurationsCC_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedATConfigurationsCC */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedATConfigurationsCC (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedATConfigurationsCC* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_DataTokenBucketNN_data01 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_DataTokenBucketNN_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_DataTokenBucketNN_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_DataTokenBucketNN */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_DataTokenBucketNN (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_DataTokenBucketNN* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPacketsCC_data01 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPacketsCC_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPacketsCC_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPacketsCC */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPacketsCC (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPacketsCC* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrengthConfigXX_data01_data_data02 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrengthConfigXX_data01_data_data02 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrengthConfigXX_data01_data_data02* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrengthConfigXX_data01 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrengthConfigXX_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrengthConfigXX_data01* sp) {
	int i, i0;
	for (i=0; i<sp->items; i++) {
		for (i0=0; i0<sp->data[i]->data02.items; i0++) {
			EDFree (sp->data[i]->data02.data[i0]);
			sp->data[i]->data02.data[i0] = NULL;
		}
		if (sp->data[i]->data02.data) {EDFree (sp->data[i]->data02.data); sp->data[i]->data02.data = NULL; sp->data[i]->data02.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrengthConfigXX */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrengthConfigXX (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrengthConfigXX* sp) {
	int i0;
	int i1;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		for (i1=0; i1<sp->data01.data[i0]->data02.items; i1++) {
			EDFree (sp->data01.data[i0]->data02.data[i1]);
			sp->data01.data[i0]->data02.data[i1] = NULL;
		}
		if (sp->data01.data[i0]->data02.data) {EDFree (sp->data01.data[i0]->data02.data); sp->data01.data[i0]->data02.data = NULL; sp->data01.data[i0]->data02.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2PmaxConfigXX_data01_data_data02 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2PmaxConfigXX_data01_data_data02 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2PmaxConfigXX_data01_data_data02* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2PmaxConfigXX_data01 */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2PmaxConfigXX_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2PmaxConfigXX_data01* sp) {
	int i, i0;
	for (i=0; i<sp->items; i++) {
		for (i0=0; i0<sp->data[i]->data02.items; i0++) {
			EDFree (sp->data[i]->data02.data[i0]);
			sp->data[i]->data02.data[i0] = NULL;
		}
		if (sp->data[i]->data02.data) {EDFree (sp->data[i]->data02.data); sp->data[i]->data02.data = NULL; sp->data[i]->data02.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2PmaxConfigXX */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2PmaxConfigXX (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2PmaxConfigXX* sp) {
	int i0;
	int i1;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		for (i1=0; i1<sp->data01.data[i0]->data02.items; i1++) {
			EDFree (sp->data01.data[i0]->data02.data[i1]);
			sp->data01.data[i0]->data02.data[i1] = NULL;
		}
		if (sp->data01.data[i0]->data02.data) {EDFree (sp->data01.data[i0]->data02.data); sp->data01.data[i0]->data02.data = NULL; sp->data01.data[i0]->data02.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data_data02_data_data03 */
void FREE_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data_data02_data_data03 (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data_data02_data_data03* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data_data02 */
void FREE_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data_data02 (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data_data02* sp) {
	int i, i0;
	for (i=0; i<sp->items; i++) {
		for (i0=0; i0<sp->data[i]->data03.items; i0++) {
			EDFree (sp->data[i]->data03.data[i0]);
			sp->data[i]->data03.data[i0] = NULL;
		}
		if (sp->data[i]->data03.data) {EDFree (sp->data[i]->data03.data); sp->data[i]->data03.data = NULL; sp->data[i]->data03.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01 */
void FREE_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01 (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01* sp) {
	int i, i0, i1;
	for (i=0; i<sp->items; i++) {
		for (i0=0; i0<sp->data[i]->data02.items; i0++) {
			for (i1=0; i1<sp->data[i]->data02.data[i0]->data03.items; i1++) {
				EDFree (sp->data[i]->data02.data[i0]->data03.data[i1]);
				sp->data[i]->data02.data[i0]->data03.data[i1] = NULL;
			}
			if (sp->data[i]->data02.data[i0]->data03.data) {EDFree (sp->data[i]->data02.data[i0]->data03.data); sp->data[i]->data02.data[i0]->data03.data = NULL; sp->data[i]->data02.data[i0]->data03.allocatedItems=0; /*FR02A*/}
			EDFree (sp->data[i]->data02.data[i0]);
			sp->data[i]->data02.data[i0] = NULL;
		}
		if (sp->data[i]->data02.data) {EDFree (sp->data[i]->data02.data); sp->data[i]->data02.data = NULL; sp->data[i]->data02.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower */
void FREE_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower* sp) {
	int i0;
	int i1;
	int i2;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		for (i1=0; i1<sp->data01.data[i0]->data02.items; i1++) {
			for (i2=0; i2<sp->data01.data[i0]->data02.data[i1]->data03.items; i2++) {
				EDFree (sp->data01.data[i0]->data02.data[i1]->data03.data[i2]);
				sp->data01.data[i0]->data02.data[i1]->data03.data[i2] = NULL;
			}
			if (sp->data01.data[i0]->data02.data[i1]->data03.data) {EDFree (sp->data01.data[i0]->data02.data[i1]->data03.data); sp->data01.data[i0]->data02.data[i1]->data03.data = NULL; sp->data01.data[i0]->data02.data[i1]->data03.allocatedItems=0; /*FR02A*/}
			EDFree (sp->data01.data[i0]->data02.data[i1]);
			sp->data01.data[i0]->data02.data[i1] = NULL;
		}
		if (sp->data01.data[i0]->data02.data) {EDFree (sp->data01.data[i0]->data02.data); sp->data01.data[i0]->data02.data = NULL; sp->data01.data[i0]->data02.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_ReversePilotTransmitSlots_data01 */
void FREE_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_ReversePilotTransmitSlots_data01 (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_ReversePilotTransmitSlots_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->ReversePilotTransmitSlotsDuration_Present) {
		}
		if (sp->data[i]->ReversePilotTransmitSlotsPeriod_Present) {
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_ReversePilotTransmitSlots */
void FREE_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_ReversePilotTransmitSlots (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_ReversePilotTransmitSlots* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->ReversePilotTransmitSlotsDuration_Present) {
		}
		if (sp->data01.data[i0]->ReversePilotTransmitSlotsPeriod_Present) {
		}
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Default_Packet_Application_Attributes_Values */
void FREE_c_Air_Default_Packet_Application_Attributes_Values (c_Air_Default_Packet_Application_Attributes_Values* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Default_Packet_Application_Attributes */
void FREE_c_Air_Default_Packet_Application_Attributes (c_Air_Default_Packet_Application_Attributes* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->Values.data) {EDFree (sp->Values.data); sp->Values.data = NULL; sp->Values.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_Air_Default_Packet_Application_Attributes_Response */
void FREE_c_Air_Default_Packet_Application_Attributes_Response (c_Air_Default_Packet_Application_Attributes_Response* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_Air_Multi_Flow_Packet_Application_Attributes_Values */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_Values (c_Air_Multi_Flow_Packet_Application_Attributes_Values* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for union c_Air_Multi_Flow_Packet_Application_Attributes_complex */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_complex (c_Air_Multi_Flow_Packet_Application_Attributes_complex* sp) {
	switch (sp->Present) {
		case U_c_Air_Multi_Flow_Packet_Application_Attributes_complex_SupportedHigherLayerProtocols: {
			FREE_c_Air_Multi_Flow_Packet_Application_Attributes_SupportedHigherLayerProtocols (sp->u.SupportedHigherLayerProtocols);
			EDFree (sp->u.SupportedHigherLayerProtocols);

			break;
		}
		case U_c_Air_Multi_Flow_Packet_Application_Attributes_complex_ATSupportedQoSProfiles: {
			FREE_c_Air_Multi_Flow_Packet_Application_Attributes_ATSupportedQoSProfiles (sp->u.ATSupportedQoSProfiles);
			EDFree (sp->u.ATSupportedQoSProfiles);

			break;
		}
		case U_c_Air_Multi_Flow_Packet_Application_Attributes_complex_ANSupportedQoSProfiles: {
			FREE_c_Air_Multi_Flow_Packet_Application_Attributes_ANSupportedQoSProfiles (sp->u.ANSupportedQoSProfiles);
			EDFree (sp->u.ANSupportedQoSProfiles);

			break;
		}
		case U_c_Air_Multi_Flow_Packet_Application_Attributes_complex_MaxRLPFlows: {
			FREE_c_Air_Multi_Flow_Packet_Application_Attributes_MaxRLPFlows (sp->u.MaxRLPFlows);
			EDFree (sp->u.MaxRLPFlows);

			break;
		}
		case U_c_Air_Multi_Flow_Packet_Application_Attributes_complex_MaxReservations: {
			FREE_c_Air_Multi_Flow_Packet_Application_Attributes_MaxReservations (sp->u.MaxReservations);
			EDFree (sp->u.MaxReservations);

			break;
		}
		case U_c_Air_Multi_Flow_Packet_Application_Attributes_complex_FlowNNIdentificationFwd: {
			FREE_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationFwd (sp->u.FlowNNIdentificationFwd);
			EDFree (sp->u.FlowNNIdentificationFwd);

			break;
		}
		case U_c_Air_Multi_Flow_Packet_Application_Attributes_complex_FlowNNIdentificationRev: {
			FREE_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationRev (sp->u.FlowNNIdentificationRev);
			EDFree (sp->u.FlowNNIdentificationRev);

			break;
		}
		case U_c_Air_Multi_Flow_Packet_Application_Attributes_complex_FlowNNTimersFwd: {
			FREE_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersFwd (sp->u.FlowNNTimersFwd);
			EDFree (sp->u.FlowNNTimersFwd);

			break;
		}
		case U_c_Air_Multi_Flow_Packet_Application_Attributes_complex_FlowNNTimersRev: {
			FREE_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersRev (sp->u.FlowNNTimersRev);
			EDFree (sp->u.FlowNNTimersRev);

			break;
		}
		case U_c_Air_Multi_Flow_Packet_Application_Attributes_complex_FlowNNReservationFwd: {
			FREE_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationFwd (sp->u.FlowNNReservationFwd);
			EDFree (sp->u.FlowNNReservationFwd);

			break;
		}
		case U_c_Air_Multi_Flow_Packet_Application_Attributes_complex_FlowNNReservationRev: {
			FREE_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationRev (sp->u.FlowNNReservationRev);
			EDFree (sp->u.FlowNNReservationRev);

			break;
		}
		case U_c_Air_Multi_Flow_Packet_Application_Attributes_complex_ReservationKKQoSRequestFwd: {
			FREE_c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestFwd (sp->u.ReservationKKQoSRequestFwd);
			EDFree (sp->u.ReservationKKQoSRequestFwd);

			break;
		}
		case U_c_Air_Multi_Flow_Packet_Application_Attributes_complex_ReservationKKQoSRequestRev: {
			FREE_c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestRev (sp->u.ReservationKKQoSRequestRev);
			EDFree (sp->u.ReservationKKQoSRequestRev);

			break;
		}
		case U_c_Air_Multi_Flow_Packet_Application_Attributes_complex_ReservationKKQoSResponseFwd: {
			FREE_c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseFwd (sp->u.ReservationKKQoSResponseFwd);
			EDFree (sp->u.ReservationKKQoSResponseFwd);

			break;
		}
		case U_c_Air_Multi_Flow_Packet_Application_Attributes_complex_ReservationKKQoSResponseRev: {
			FREE_c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseRev (sp->u.ReservationKKQoSResponseRev);
			EDFree (sp->u.ReservationKKQoSResponseRev);

			break;
		}

		default:;
	}
	sp->Present = U_c_Air_Multi_Flow_Packet_Application_Attributes_complex_NONE;
}

/* Free function for struct c_Air_Multi_Flow_Packet_Application_Attributes */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes (c_Air_Multi_Flow_Packet_Application_Attributes* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->Values.data) {EDFree (sp->Values.data); sp->Values.data = NULL; sp->Values.allocatedItems=0; /*FR02A*/}
	FREE_c_Air_Multi_Flow_Packet_Application_Attributes_complex (&(sp->complex));

}

/* Free function for struct c_Air_Multi_Flow_Packet_Application_Attributes_Response */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_Response (c_Air_Multi_Flow_Packet_Application_Attributes_Response* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for union c_Air_Default_Stream_Protocol_Attributes_complex */
void FREE_c_Air_Default_Stream_Protocol_Attributes_complex (c_Air_Default_Stream_Protocol_Attributes_complex* sp) {
	switch (sp->Present) {
		case U_c_Air_Default_Stream_Protocol_Attributes_complex_StreamConfiguration: {
			FREE_c_Air_Default_Stream_Protocol_Attributes_StreamConfiguration (sp->u.StreamConfiguration);
			EDFree (sp->u.StreamConfiguration);

			break;
		}

		default:;
	}
	sp->Present = U_c_Air_Default_Stream_Protocol_Attributes_complex_NONE;
}

/* Free function for struct c_Air_Default_Stream_Protocol_Attributes */
void FREE_c_Air_Default_Stream_Protocol_Attributes (c_Air_Default_Stream_Protocol_Attributes* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Default_Stream_Protocol_Attributes_complex (&(sp->complex));

}

/* Free function for struct c_Air_Default_Stream_Protocol_Attributes_Response */
void FREE_c_Air_Default_Stream_Protocol_Attributes_Response (c_Air_Default_Stream_Protocol_Attributes_Response* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_Air_Generic_Virtual_Stream_Protocol_Attributes_Values */
void FREE_c_Air_Generic_Virtual_Stream_Protocol_Attributes_Values (c_Air_Generic_Virtual_Stream_Protocol_Attributes_Values* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Generic_Virtual_Stream_Protocol_Attributes */
void FREE_c_Air_Generic_Virtual_Stream_Protocol_Attributes (c_Air_Generic_Virtual_Stream_Protocol_Attributes* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->Values.data) {EDFree (sp->Values.data); sp->Values.data = NULL; sp->Values.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_Air_Generic_Virtual_Stream_Protocol_Attributes_Response */
void FREE_c_Air_Generic_Virtual_Stream_Protocol_Attributes_Response (c_Air_Generic_Virtual_Stream_Protocol_Attributes_Response* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_Air_Default_Session_Management_Protocol_Attributes_Values */
void FREE_c_Air_Default_Session_Management_Protocol_Attributes_Values (c_Air_Default_Session_Management_Protocol_Attributes_Values* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Default_Session_Management_Protocol_Attributes */
void FREE_c_Air_Default_Session_Management_Protocol_Attributes (c_Air_Default_Session_Management_Protocol_Attributes* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->Values.data) {EDFree (sp->Values.data); sp->Values.data = NULL; sp->Values.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_Air_Default_Session_Management_Protocol_Attributes_Response */
void FREE_c_Air_Default_Session_Management_Protocol_Attributes_Response (c_Air_Default_Session_Management_Protocol_Attributes_Response* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_Air_Default_Address_Management_Protocol_Attributes_Values */
void FREE_c_Air_Default_Address_Management_Protocol_Attributes_Values (c_Air_Default_Address_Management_Protocol_Attributes_Values* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Default_Address_Management_Protocol_Attributes */
void FREE_c_Air_Default_Address_Management_Protocol_Attributes (c_Air_Default_Address_Management_Protocol_Attributes* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->Values.data) {EDFree (sp->Values.data); sp->Values.data = NULL; sp->Values.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_Air_Default_Address_Management_Protocol_Attributes_Response */
void FREE_c_Air_Default_Address_Management_Protocol_Attributes_Response (c_Air_Default_Address_Management_Protocol_Attributes_Response* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_Air_Default_Session_Configuration_Protocol_Attributes_Values */
void FREE_c_Air_Default_Session_Configuration_Protocol_Attributes_Values (c_Air_Default_Session_Configuration_Protocol_Attributes_Values* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for union c_Air_Default_Session_Configuration_Protocol_Attributes_complex */
void FREE_c_Air_Default_Session_Configuration_Protocol_Attributes_complex (c_Air_Default_Session_Configuration_Protocol_Attributes_complex* sp) {
	switch (sp->Present) {
		case U_c_Air_Default_Session_Configuration_Protocol_Attributes_complex_PriorSession: {
			FREE_c_Air_Default_Session_Configuration_Protocol_Attributes_PriorSession (sp->u.PriorSession);
			EDFree (sp->u.PriorSession);

			break;
		}
		case U_c_Air_Default_Session_Configuration_Protocol_Attributes_complex_ATSupportedApplicationSubtypes: {
			FREE_c_Air_Default_Session_Configuration_Protocol_Attributes_ATSupportedApplicationSubtypes (sp->u.ATSupportedApplicationSubtypes);
			EDFree (sp->u.ATSupportedApplicationSubtypes);

			break;
		}

		default:;
	}
	sp->Present = U_c_Air_Default_Session_Configuration_Protocol_Attributes_complex_NONE;
}

/* Free function for struct c_Air_Default_Session_Configuration_Protocol_Attributes */
void FREE_c_Air_Default_Session_Configuration_Protocol_Attributes (c_Air_Default_Session_Configuration_Protocol_Attributes* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->Values.data) {EDFree (sp->Values.data); sp->Values.data = NULL; sp->Values.allocatedItems=0; /*FR02A*/}
	FREE_c_Air_Default_Session_Configuration_Protocol_Attributes_complex (&(sp->complex));

}

/* Free function for struct c_Air_Default_Session_Configuration_Protocol_Attributes_Response */
void FREE_c_Air_Default_Session_Configuration_Protocol_Attributes_Response (c_Air_Default_Session_Configuration_Protocol_Attributes_Response* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_Air_Generic_Multimode_Capability_Discovery_Protocol_Attributes_Values */
void FREE_c_Air_Generic_Multimode_Capability_Discovery_Protocol_Attributes_Values (c_Air_Generic_Multimode_Capability_Discovery_Protocol_Attributes_Values* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Generic_Multimode_Capability_Discovery_Protocol_Attributes */
void FREE_c_Air_Generic_Multimode_Capability_Discovery_Protocol_Attributes (c_Air_Generic_Multimode_Capability_Discovery_Protocol_Attributes* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->Values.data) {EDFree (sp->Values.data); sp->Values.data = NULL; sp->Values.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_Air_Generic_Multimode_Capability_Discovery_Protocol_Attributes_Response */
void FREE_c_Air_Generic_Multimode_Capability_Discovery_Protocol_Attributes_Response (c_Air_Generic_Multimode_Capability_Discovery_Protocol_Attributes_Response* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_Air_Default_Air_Link_Management_Protocol_Attributes_Values */
void FREE_c_Air_Default_Air_Link_Management_Protocol_Attributes_Values (c_Air_Default_Air_Link_Management_Protocol_Attributes_Values* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Default_Air_Link_Management_Protocol_Attributes */
void FREE_c_Air_Default_Air_Link_Management_Protocol_Attributes (c_Air_Default_Air_Link_Management_Protocol_Attributes* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->Values.data) {EDFree (sp->Values.data); sp->Values.data = NULL; sp->Values.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_Air_Default_Air_Link_Management_Protocol_Attributes_Response */
void FREE_c_Air_Default_Air_Link_Management_Protocol_Attributes_Response (c_Air_Default_Air_Link_Management_Protocol_Attributes_Response* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for union c_Air_Default_Idle_State_Protocol_Attributes_complex */
void FREE_c_Air_Default_Idle_State_Protocol_Attributes_complex (c_Air_Default_Idle_State_Protocol_Attributes_complex* sp) {
	switch (sp->Present) {
		case U_c_Air_Default_Idle_State_Protocol_Attributes_complex_PreferredControlChannelCycle: {
			FREE_c_Air_Default_Idle_State_Protocol_Attributes_PreferredControlChannelCycle (sp->u.PreferredControlChannelCycle);
			EDFree (sp->u.PreferredControlChannelCycle);

			break;
		}

		default:;
	}
	sp->Present = U_c_Air_Default_Idle_State_Protocol_Attributes_complex_NONE;
}

/* Free function for struct c_Air_Default_Idle_State_Protocol_Attributes */
void FREE_c_Air_Default_Idle_State_Protocol_Attributes (c_Air_Default_Idle_State_Protocol_Attributes* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Default_Idle_State_Protocol_Attributes_complex (&(sp->complex));

}

/* Free function for struct c_Air_Default_Idle_State_Protocol_Attributes_Response */
void FREE_c_Air_Default_Idle_State_Protocol_Attributes_Response (c_Air_Default_Idle_State_Protocol_Attributes_Response* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_Air_Enhanced_Idle_State_Protocol_Attributes_Values */
void FREE_c_Air_Enhanced_Idle_State_Protocol_Attributes_Values (c_Air_Enhanced_Idle_State_Protocol_Attributes_Values* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for union c_Air_Enhanced_Idle_State_Protocol_Attributes_complex */
void FREE_c_Air_Enhanced_Idle_State_Protocol_Attributes_complex (c_Air_Enhanced_Idle_State_Protocol_Attributes_complex* sp) {
	switch (sp->Present) {
		case U_c_Air_Enhanced_Idle_State_Protocol_Attributes_complex_PreferredControlChannelCycle: {
			FREE_c_Air_Enhanced_Idle_State_Protocol_Attributes_PreferredControlChannelCycle (sp->u.PreferredControlChannelCycle);
			EDFree (sp->u.PreferredControlChannelCycle);

			break;
		}
		case U_c_Air_Enhanced_Idle_State_Protocol_Attributes_complex_SlottedMode: {
			FREE_c_Air_Enhanced_Idle_State_Protocol_Attributes_SlottedMode (sp->u.SlottedMode);
			EDFree (sp->u.SlottedMode);

			break;
		}
		case U_c_Air_Enhanced_Idle_State_Protocol_Attributes_complex_PagingMask: {
			FREE_c_Air_Enhanced_Idle_State_Protocol_Attributes_PagingMask (sp->u.PagingMask);
			EDFree (sp->u.PagingMask);

			break;
		}

		default:;
	}
	sp->Present = U_c_Air_Enhanced_Idle_State_Protocol_Attributes_complex_NONE;
}

/* Free function for struct c_Air_Enhanced_Idle_State_Protocol_Attributes */
void FREE_c_Air_Enhanced_Idle_State_Protocol_Attributes (c_Air_Enhanced_Idle_State_Protocol_Attributes* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->Values.data) {EDFree (sp->Values.data); sp->Values.data = NULL; sp->Values.allocatedItems=0; /*FR02A*/}
	FREE_c_Air_Enhanced_Idle_State_Protocol_Attributes_complex (&(sp->complex));

}

/* Free function for struct c_Air_Enhanced_Idle_State_Protocol_Attributes_Response */
void FREE_c_Air_Enhanced_Idle_State_Protocol_Attributes_Response (c_Air_Enhanced_Idle_State_Protocol_Attributes_Response* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_Air_Quick_Idle_State_Protocol_Attributes_Values */
void FREE_c_Air_Quick_Idle_State_Protocol_Attributes_Values (c_Air_Quick_Idle_State_Protocol_Attributes_Values* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for union c_Air_Quick_Idle_State_Protocol_Attributes_complex */
void FREE_c_Air_Quick_Idle_State_Protocol_Attributes_complex (c_Air_Quick_Idle_State_Protocol_Attributes_complex* sp) {
	switch (sp->Present) {
		case U_c_Air_Quick_Idle_State_Protocol_Attributes_complex_PreferredControlChannelCycle: {
			FREE_c_Air_Quick_Idle_State_Protocol_Attributes_PreferredControlChannelCycle (sp->u.PreferredControlChannelCycle);
			EDFree (sp->u.PreferredControlChannelCycle);

			break;
		}
		case U_c_Air_Quick_Idle_State_Protocol_Attributes_complex_SlottedMode: {
			FREE_c_Air_Quick_Idle_State_Protocol_Attributes_SlottedMode (sp->u.SlottedMode);
			EDFree (sp->u.SlottedMode);

			break;
		}
		case U_c_Air_Quick_Idle_State_Protocol_Attributes_complex_PagingMask: {
			FREE_c_Air_Quick_Idle_State_Protocol_Attributes_PagingMask (sp->u.PagingMask);
			EDFree (sp->u.PagingMask);

			break;
		}
		case U_c_Air_Quick_Idle_State_Protocol_Attributes_complex_QuickPaging: {
			FREE_c_Air_Quick_Idle_State_Protocol_Attributes_QuickPaging (sp->u.QuickPaging);
			EDFree (sp->u.QuickPaging);

			break;
		}

		default:;
	}
	sp->Present = U_c_Air_Quick_Idle_State_Protocol_Attributes_complex_NONE;
}

/* Free function for struct c_Air_Quick_Idle_State_Protocol_Attributes */
void FREE_c_Air_Quick_Idle_State_Protocol_Attributes (c_Air_Quick_Idle_State_Protocol_Attributes* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->Values.data) {EDFree (sp->Values.data); sp->Values.data = NULL; sp->Values.allocatedItems=0; /*FR02A*/}
	FREE_c_Air_Quick_Idle_State_Protocol_Attributes_complex (&(sp->complex));

}

/* Free function for struct c_Air_Quick_Idle_State_Protocol_Attributes_Response */
void FREE_c_Air_Quick_Idle_State_Protocol_Attributes_Response (c_Air_Quick_Idle_State_Protocol_Attributes_Response* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_Air_Default_Route_Update_Protocol_Attributes_Values */
void FREE_c_Air_Default_Route_Update_Protocol_Attributes_Values (c_Air_Default_Route_Update_Protocol_Attributes_Values* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for union c_Air_Default_Route_Update_Protocol_Attributes_complex */
void FREE_c_Air_Default_Route_Update_Protocol_Attributes_complex (c_Air_Default_Route_Update_Protocol_Attributes_complex* sp) {
	switch (sp->Present) {
		case U_c_Air_Default_Route_Update_Protocol_Attributes_complex_SearchParameters: {
			FREE_c_Air_Default_Route_Update_Protocol_Attributes_SearchParameters (sp->u.SearchParameters);
			EDFree (sp->u.SearchParameters);

			break;
		}
		case U_c_Air_Default_Route_Update_Protocol_Attributes_complex_SetManagementSameChannelParameters: {
			FREE_c_Air_Default_Route_Update_Protocol_Attributes_SetManagementSameChannelParameters (sp->u.SetManagementSameChannelParameters);
			EDFree (sp->u.SetManagementSameChannelParameters);

			break;
		}
		case U_c_Air_Default_Route_Update_Protocol_Attributes_complex_SetManagementDifferentChannelParameters: {
			FREE_c_Air_Default_Route_Update_Protocol_Attributes_SetManagementDifferentChannelParameters (sp->u.SetManagementDifferentChannelParameters);
			EDFree (sp->u.SetManagementDifferentChannelParameters);

			break;
		}
		case U_c_Air_Default_Route_Update_Protocol_Attributes_complex_SupportedCDMAChannels: {
			FREE_c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels (sp->u.SupportedCDMAChannels);
			EDFree (sp->u.SupportedCDMAChannels);

			break;
		}

		default:;
	}
	sp->Present = U_c_Air_Default_Route_Update_Protocol_Attributes_complex_NONE;
}

/* Free function for struct c_Air_Default_Route_Update_Protocol_Attributes */
void FREE_c_Air_Default_Route_Update_Protocol_Attributes (c_Air_Default_Route_Update_Protocol_Attributes* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->Values.data) {EDFree (sp->Values.data); sp->Values.data = NULL; sp->Values.allocatedItems=0; /*FR02A*/}
	FREE_c_Air_Default_Route_Update_Protocol_Attributes_complex (&(sp->complex));

}

/* Free function for struct c_Air_Default_Route_Update_Protocol_Attributes_Response */
void FREE_c_Air_Default_Route_Update_Protocol_Attributes_Response (c_Air_Default_Route_Update_Protocol_Attributes_Response* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_Air_Multicarrier_Route_Update_Protocol_Attributes_Values */
void FREE_c_Air_Multicarrier_Route_Update_Protocol_Attributes_Values (c_Air_Multicarrier_Route_Update_Protocol_Attributes_Values* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for union c_Air_Multicarrier_Route_Update_Protocol_Attributes_complex */
void FREE_c_Air_Multicarrier_Route_Update_Protocol_Attributes_complex (c_Air_Multicarrier_Route_Update_Protocol_Attributes_complex* sp) {
	switch (sp->Present) {
		case U_c_Air_Multicarrier_Route_Update_Protocol_Attributes_complex_SearchParameters: {
			FREE_c_Air_Multicarrier_Route_Update_Protocol_Attributes_SearchParameters (sp->u.SearchParameters);
			EDFree (sp->u.SearchParameters);

			break;
		}
		case U_c_Air_Multicarrier_Route_Update_Protocol_Attributes_complex_SetManagementParameters: {
			FREE_c_Air_Multicarrier_Route_Update_Protocol_Attributes_SetManagementParameters (sp->u.SetManagementParameters);
			EDFree (sp->u.SetManagementParameters);

			break;
		}
		case U_c_Air_Multicarrier_Route_Update_Protocol_Attributes_complex_SupportedCDMAChannels: {
			FREE_c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels (sp->u.SupportedCDMAChannels);
			EDFree (sp->u.SupportedCDMAChannels);

			break;
		}
		case U_c_Air_Multicarrier_Route_Update_Protocol_Attributes_complex_SupportedDRXPatterns: {
			FREE_c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedDRXPatterns (sp->u.SupportedDRXPatterns);
			EDFree (sp->u.SupportedDRXPatterns);

			break;
		}

		default:;
	}
	sp->Present = U_c_Air_Multicarrier_Route_Update_Protocol_Attributes_complex_NONE;
}

/* Free function for struct c_Air_Multicarrier_Route_Update_Protocol_Attributes */
void FREE_c_Air_Multicarrier_Route_Update_Protocol_Attributes (c_Air_Multicarrier_Route_Update_Protocol_Attributes* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->Values.data) {EDFree (sp->Values.data); sp->Values.data = NULL; sp->Values.allocatedItems=0; /*FR02A*/}
	FREE_c_Air_Multicarrier_Route_Update_Protocol_Attributes_complex (&(sp->complex));

}

/* Free function for struct c_Air_Multicarrier_Route_Update_Protocol_Attributes_Response */
void FREE_c_Air_Multicarrier_Route_Update_Protocol_Attributes_Response (c_Air_Multicarrier_Route_Update_Protocol_Attributes_Response* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_Air_Overhead_Messages_Protocol_Attributes_Values */
void FREE_c_Air_Overhead_Messages_Protocol_Attributes_Values (c_Air_Overhead_Messages_Protocol_Attributes_Values* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Overhead_Messages_Protocol_Attributes */
void FREE_c_Air_Overhead_Messages_Protocol_Attributes (c_Air_Overhead_Messages_Protocol_Attributes* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->Values.data) {EDFree (sp->Values.data); sp->Values.data = NULL; sp->Values.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_Air_Overhead_Messages_Protocol_Attributes_Response */
void FREE_c_Air_Overhead_Messages_Protocol_Attributes_Response (c_Air_Overhead_Messages_Protocol_Attributes_Response* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_Air_DH_Key_Exchange_Protocol_Attributes_Values */
void FREE_c_Air_DH_Key_Exchange_Protocol_Attributes_Values (c_Air_DH_Key_Exchange_Protocol_Attributes_Values* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_DH_Key_Exchange_Protocol_Attributes */
void FREE_c_Air_DH_Key_Exchange_Protocol_Attributes (c_Air_DH_Key_Exchange_Protocol_Attributes* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->Values.data) {EDFree (sp->Values.data); sp->Values.data = NULL; sp->Values.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_Air_DH_Key_Exchange_Protocol_Attributes_Response */
void FREE_c_Air_DH_Key_Exchange_Protocol_Attributes_Response (c_Air_DH_Key_Exchange_Protocol_Attributes_Response* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_Air_SHA_1_Authentication_Protocol_Attributes_Values */
void FREE_c_Air_SHA_1_Authentication_Protocol_Attributes_Values (c_Air_SHA_1_Authentication_Protocol_Attributes_Values* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_SHA_1_Authentication_Protocol_Attributes */
void FREE_c_Air_SHA_1_Authentication_Protocol_Attributes (c_Air_SHA_1_Authentication_Protocol_Attributes* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->Values.data) {EDFree (sp->Values.data); sp->Values.data = NULL; sp->Values.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_Air_SHA_1_Authentication_Protocol_Attributes_Response */
void FREE_c_Air_SHA_1_Authentication_Protocol_Attributes_Response (c_Air_SHA_1_Authentication_Protocol_Attributes_Response* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_Air_Enhanced_Control_Channel_MAC_Protocol_Attributes_Values */
void FREE_c_Air_Enhanced_Control_Channel_MAC_Protocol_Attributes_Values (c_Air_Enhanced_Control_Channel_MAC_Protocol_Attributes_Values* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Enhanced_Control_Channel_MAC_Protocol_Attributes */
void FREE_c_Air_Enhanced_Control_Channel_MAC_Protocol_Attributes (c_Air_Enhanced_Control_Channel_MAC_Protocol_Attributes* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->Values.data) {EDFree (sp->Values.data); sp->Values.data = NULL; sp->Values.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_Air_Enhanced_Control_Channel_MAC_Protocol_Attributes_Response */
void FREE_c_Air_Enhanced_Control_Channel_MAC_Protocol_Attributes_Response (c_Air_Enhanced_Control_Channel_MAC_Protocol_Attributes_Response* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for union c_Air_Default_Access_Channel_MAC_Protocol_Attributes_complex */
void FREE_c_Air_Default_Access_Channel_MAC_Protocol_Attributes_complex (c_Air_Default_Access_Channel_MAC_Protocol_Attributes_complex* sp) {
	switch (sp->Present) {
		case U_c_Air_Default_Access_Channel_MAC_Protocol_Attributes_complex_InitialConfiguration: {
			FREE_c_Air_Default_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration (sp->u.InitialConfiguration);
			EDFree (sp->u.InitialConfiguration);

			break;
		}
		case U_c_Air_Default_Access_Channel_MAC_Protocol_Attributes_complex_PowerParameters: {
			FREE_c_Air_Default_Access_Channel_MAC_Protocol_Attributes_PowerParameters (sp->u.PowerParameters);
			EDFree (sp->u.PowerParameters);

			break;
		}

		default:;
	}
	sp->Present = U_c_Air_Default_Access_Channel_MAC_Protocol_Attributes_complex_NONE;
}

/* Free function for struct c_Air_Default_Access_Channel_MAC_Protocol_Attributes */
void FREE_c_Air_Default_Access_Channel_MAC_Protocol_Attributes (c_Air_Default_Access_Channel_MAC_Protocol_Attributes* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Default_Access_Channel_MAC_Protocol_Attributes_complex (&(sp->complex));

}

/* Free function for struct c_Air_Default_Access_Channel_MAC_Protocol_Attributes_Response */
void FREE_c_Air_Default_Access_Channel_MAC_Protocol_Attributes_Response (c_Air_Default_Access_Channel_MAC_Protocol_Attributes_Response* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_Values */
void FREE_c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_Values (c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_Values* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for union c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_complex */
void FREE_c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_complex (c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_complex* sp) {
	switch (sp->Present) {
		case U_c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_complex_InitialConfiguration: {
			FREE_c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration (sp->u.InitialConfiguration);
			EDFree (sp->u.InitialConfiguration);

			break;
		}

		default:;
	}
	sp->Present = U_c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_complex_NONE;
}

/* Free function for struct c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes */
void FREE_c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes (c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->Values.data) {EDFree (sp->Values.data); sp->Values.data = NULL; sp->Values.allocatedItems=0; /*FR02A*/}
	FREE_c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_complex (&(sp->complex));

}

/* Free function for struct c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_Response */
void FREE_c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_Response (c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_Response* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_Values */
void FREE_c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_Values (c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_Values* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for union c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex */
void FREE_c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex (c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex* sp) {
	switch (sp->Present) {
		case U_c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex_HandoffDelays: {
			FREE_c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays (sp->u.HandoffDelays);
			EDFree (sp->u.HandoffDelays);

			break;
		}
		case U_c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex_DRCLock: {
			FREE_c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCLock (sp->u.DRCLock);
			EDFree (sp->u.DRCLock);

			break;
		}

		default:;
	}
	sp->Present = U_c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex_NONE;
}

/* Free function for struct c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes */
void FREE_c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes (c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->Values.data) {EDFree (sp->Values.data); sp->Values.data = NULL; sp->Values.allocatedItems=0; /*FR02A*/}
	FREE_c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex (&(sp->complex));

}

/* Free function for struct c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_Response */
void FREE_c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_Response (c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_Response* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_Values */
void FREE_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_Values (c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_Values* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for union c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex */
void FREE_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex (c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex* sp) {
	switch (sp->Present) {
		case U_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex_HandoffDelays: {
			FREE_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays (sp->u.HandoffDelays);
			EDFree (sp->u.HandoffDelays);

			break;
		}
		case U_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex_DRCTranslationOffset: {
			FREE_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCTranslationOffset (sp->u.DRCTranslationOffset);
			EDFree (sp->u.DRCTranslationOffset);

			break;
		}

		default:;
	}
	sp->Present = U_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex_NONE;
}

/* Free function for struct c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes */
void FREE_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes (c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->Values.data) {EDFree (sp->Values.data); sp->Values.data = NULL; sp->Values.allocatedItems=0; /*FR02A*/}
	FREE_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex (&(sp->complex));

}

/* Free function for struct c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_Response */
void FREE_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_Response (c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_Response* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_Values */
void FREE_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_Values (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_Values* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for union c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex */
void FREE_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex* sp) {
	switch (sp->Present) {
		case U_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex_HandoffDelays: {
			FREE_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays (sp->u.HandoffDelays);
			EDFree (sp->u.HandoffDelays);

			break;
		}
		case U_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex_ATSupportedPacketFormats: {
			FREE_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ATSupportedPacketFormats (sp->u.ATSupportedPacketFormats);
			EDFree (sp->u.ATSupportedPacketFormats);

			break;
		}
		case U_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex_TentativeDRCtoTxDRCMap: {
			FREE_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_TentativeDRCtoTxDRCMap (sp->u.TentativeDRCtoTxDRCMap);
			EDFree (sp->u.TentativeDRCtoTxDRCMap);

			break;
		}
		case U_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex_ExtendedSpans: {
			FREE_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ExtendedSpans (sp->u.ExtendedSpans);
			EDFree (sp->u.ExtendedSpans);

			break;
		}

		default:;
	}
	sp->Present = U_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex_NONE;
}

/* Free function for struct c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes */
void FREE_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->Values.data) {EDFree (sp->Values.data); sp->Values.data = NULL; sp->Values.allocatedItems=0; /*FR02A*/}
	FREE_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex (&(sp->complex));

}

/* Free function for struct c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_Response */
void FREE_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_Response (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_Response* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for union c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex */
void FREE_c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex (c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex* sp) {
	switch (sp->Present) {
		case U_c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters: {
			FREE_c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters (sp->u.PowerParameters);
			EDFree (sp->u.PowerParameters);

			break;
		}
		case U_c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_RateParameters: {
			FREE_c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters (sp->u.RateParameters);
			EDFree (sp->u.RateParameters);

			break;
		}

		default:;
	}
	sp->Present = U_c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_NONE;
}

/* Free function for struct c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes */
void FREE_c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes (c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex (&(sp->complex));

}

/* Free function for struct c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Response */
void FREE_c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Response (c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Response* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for union c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex */
void FREE_c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex (c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex* sp) {
	switch (sp->Present) {
		case U_c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters: {
			FREE_c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters (sp->u.PowerParameters);
			EDFree (sp->u.PowerParameters);

			break;
		}
		case U_c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_RateParameters: {
			FREE_c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters (sp->u.RateParameters);
			EDFree (sp->u.RateParameters);

			break;
		}

		default:;
	}
	sp->Present = U_c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_NONE;
}

/* Free function for struct c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes */
void FREE_c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes (c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex (&(sp->complex));

}

/* Free function for struct c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Response */
void FREE_c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Response (c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Response* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Values */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Values (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Values* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for union c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex* sp) {
	switch (sp->Present) {
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_AuxiliaryPilotChannelParameters: {
			FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters (sp->u.AuxiliaryPilotChannelParameters);
			EDFree (sp->u.AuxiliaryPilotChannelParameters);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_CommonPowerParameters: {
			FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters (sp->u.CommonPowerParameters);
			EDFree (sp->u.CommonPowerParameters);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_MaxNumSubPackets: {
			FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPackets (sp->u.MaxNumSubPackets);
			EDFree (sp->u.MaxNumSubPackets);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PermittedPayload: {
			FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload (sp->u.PermittedPayload);
			EDFree (sp->u.PermittedPayload);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PilotStrength: {
			FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrength (sp->u.PilotStrength);
			EDFree (sp->u.PilotStrength);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters128: {
			FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128 (sp->u.PowerParameters128);
			EDFree (sp->u.PowerParameters128);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters256: {
			FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256 (sp->u.PowerParameters256);
			EDFree (sp->u.PowerParameters256);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters512: {
			FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512 (sp->u.PowerParameters512);
			EDFree (sp->u.PowerParameters512);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters768: {
			FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768 (sp->u.PowerParameters768);
			EDFree (sp->u.PowerParameters768);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters1024: {
			FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024 (sp->u.PowerParameters1024);
			EDFree (sp->u.PowerParameters1024);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters1536: {
			FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536 (sp->u.PowerParameters1536);
			EDFree (sp->u.PowerParameters1536);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters2048: {
			FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048 (sp->u.PowerParameters2048);
			EDFree (sp->u.PowerParameters2048);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters3072: {
			FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072 (sp->u.PowerParameters3072);
			EDFree (sp->u.PowerParameters3072);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters4096: {
			FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096 (sp->u.PowerParameters4096);
			EDFree (sp->u.PowerParameters4096);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters6144: {
			FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144 (sp->u.PowerParameters6144);
			EDFree (sp->u.PowerParameters6144);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters8192: {
			FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192 (sp->u.PowerParameters8192);
			EDFree (sp->u.PowerParameters8192);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters12288: {
			FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288 (sp->u.PowerParameters12288);
			EDFree (sp->u.PowerParameters12288);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_RequestParameters: {
			FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters (sp->u.RequestParameters);
			EDFree (sp->u.RequestParameters);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_RRIChannelPowerParameters: {
			FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters (sp->u.RRIChannelPowerParameters);
			EDFree (sp->u.RRIChannelPowerParameters);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_TxT2Pmax: {
			FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2Pmax (sp->u.TxT2Pmax);
			EDFree (sp->u.TxT2Pmax);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_MaxMACFlows: {
			FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows (sp->u.MaxMACFlows);
			EDFree (sp->u.MaxMACFlows);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_AssociatedFlowsNN: {
			FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN (sp->u.AssociatedFlowsNN);
			EDFree (sp->u.AssociatedFlowsNN);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_BucketFactorNN: {
			FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN (sp->u.BucketFactorNN);
			EDFree (sp->u.BucketFactorNN);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_T2PInflowRangeNN: {
			FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeNN (sp->u.T2PInflowRangeNN);
			EDFree (sp->u.T2PInflowRangeNN);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_T2PTransitionFunctionNN: {
			FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN (sp->u.T2PTransitionFunctionNN);
			EDFree (sp->u.T2PTransitionFunctionNN);

			break;
		}

		default:;
	}
	sp->Present = U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_NONE;
}

/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->Values.data) {EDFree (sp->Values.data); sp->Values.data = NULL; sp->Values.allocatedItems=0; /*FR02A*/}
	FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex (&(sp->complex));

}

/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Response */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Response (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Response* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Values */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Values (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Values* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for union c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex* sp) {
	switch (sp->Present) {
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_AuxiliaryPilotChannelParameters: {
			FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters (sp->u.AuxiliaryPilotChannelParameters);
			EDFree (sp->u.AuxiliaryPilotChannelParameters);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_CommonPowerParameters: {
			FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters (sp->u.CommonPowerParameters);
			EDFree (sp->u.CommonPowerParameters);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PermittedPayload: {
			FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload (sp->u.PermittedPayload);
			EDFree (sp->u.PermittedPayload);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters128: {
			FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128 (sp->u.PowerParameters128);
			EDFree (sp->u.PowerParameters128);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters256: {
			FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256 (sp->u.PowerParameters256);
			EDFree (sp->u.PowerParameters256);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters512: {
			FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512 (sp->u.PowerParameters512);
			EDFree (sp->u.PowerParameters512);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters768: {
			FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768 (sp->u.PowerParameters768);
			EDFree (sp->u.PowerParameters768);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters1024: {
			FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024 (sp->u.PowerParameters1024);
			EDFree (sp->u.PowerParameters1024);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters1536: {
			FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536 (sp->u.PowerParameters1536);
			EDFree (sp->u.PowerParameters1536);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters2048: {
			FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048 (sp->u.PowerParameters2048);
			EDFree (sp->u.PowerParameters2048);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters3072: {
			FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072 (sp->u.PowerParameters3072);
			EDFree (sp->u.PowerParameters3072);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters4096: {
			FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096 (sp->u.PowerParameters4096);
			EDFree (sp->u.PowerParameters4096);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters6144: {
			FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144 (sp->u.PowerParameters6144);
			EDFree (sp->u.PowerParameters6144);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters8192: {
			FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192 (sp->u.PowerParameters8192);
			EDFree (sp->u.PowerParameters8192);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters12288: {
			FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288 (sp->u.PowerParameters12288);
			EDFree (sp->u.PowerParameters12288);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_RequestParameters: {
			FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters (sp->u.RequestParameters);
			EDFree (sp->u.RequestParameters);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_RRIChannelPowerParameters: {
			FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters (sp->u.RRIChannelPowerParameters);
			EDFree (sp->u.RRIChannelPowerParameters);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_MaxMACFlows: {
			FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows (sp->u.MaxMACFlows);
			EDFree (sp->u.MaxMACFlows);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_AssociatedFlowsNN: {
			FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN (sp->u.AssociatedFlowsNN);
			EDFree (sp->u.AssociatedFlowsNN);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_BucketFactorNN: {
			FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN (sp->u.BucketFactorNN);
			EDFree (sp->u.BucketFactorNN);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_T2PInflowRangeConfigXX: {
			FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeConfigXX (sp->u.T2PInflowRangeConfigXX);
			EDFree (sp->u.T2PInflowRangeConfigXX);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_T2PTransitionFunctionConfigXX: {
			FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX (sp->u.T2PTransitionFunctionConfigXX);
			EDFree (sp->u.T2PTransitionFunctionConfigXX);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_AssociatedFlowConfigurationsNC: {
			FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowConfigurationsNC (sp->u.AssociatedFlowConfigurationsNC);
			EDFree (sp->u.AssociatedFlowConfigurationsNC);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_AssociatedATConfigurationsCC: {
			FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedATConfigurationsCC (sp->u.AssociatedATConfigurationsCC);
			EDFree (sp->u.AssociatedATConfigurationsCC);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_DataTokenBucketNN: {
			FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_DataTokenBucketNN (sp->u.DataTokenBucketNN);
			EDFree (sp->u.DataTokenBucketNN);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_MaxNumSubPacketsCC: {
			FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPacketsCC (sp->u.MaxNumSubPacketsCC);
			EDFree (sp->u.MaxNumSubPacketsCC);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PilotStrengthConfigXX: {
			FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrengthConfigXX (sp->u.PilotStrengthConfigXX);
			EDFree (sp->u.PilotStrengthConfigXX);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_TxT2PmaxConfigXX: {
			FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2PmaxConfigXX (sp->u.TxT2PmaxConfigXX);
			EDFree (sp->u.TxT2PmaxConfigXX);

			break;
		}

		default:;
	}
	sp->Present = U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_NONE;
}

/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->Values.data) {EDFree (sp->Values.data); sp->Values.data = NULL; sp->Values.allocatedItems=0; /*FR02A*/}
	FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex (&(sp->complex));

}

/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Response */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Response (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Response* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_Values */
void FREE_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_Values (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_Values* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for union c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_complex */
void FREE_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_complex (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_complex* sp) {
	switch (sp->Present) {
		case U_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_complex_AdditionalCarriersInitTxPower: {
			FREE_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower (sp->u.AdditionalCarriersInitTxPower);
			EDFree (sp->u.AdditionalCarriersInitTxPower);

			break;
		}
		case U_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_complex_ReversePilotTransmitSlots: {
			FREE_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_ReversePilotTransmitSlots (sp->u.ReversePilotTransmitSlots);
			EDFree (sp->u.ReversePilotTransmitSlots);

			break;
		}

		default:;
	}
	sp->Present = U_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_complex_NONE;
}

/* Free function for struct c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes */
void FREE_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->Values.data) {EDFree (sp->Values.data); sp->Values.data = NULL; sp->Values.allocatedItems=0; /*FR02A*/}
	FREE_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_complex (&(sp->complex));

}

/* Free function for struct c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_Response */
void FREE_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_Response (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_Response* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_SIGAPP_SLP_INCFG_ConfigurationRequest_contents_data01 */
void FREE_c_SIGAPP_SLP_INCFG_ConfigurationRequest_contents_data01 (c_SIGAPP_SLP_INCFG_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data[i]->AttributeRecord.AttributeValue.value);
			sp->data[i]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_SIGAPP_SLP_INCFG_ConfigurationRequest_contents */
void FREE_c_SIGAPP_SLP_INCFG_ConfigurationRequest_contents (c_SIGAPP_SLP_INCFG_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data01.data[i0]->AttributeRecord.AttributeValue.value);
			sp->data01.data[i0]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data01.data[i0]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_SIGAPP_SLP_INCFG_ConfigurationResponse_contents_data01 */
void FREE_c_SIGAPP_SLP_INCFG_ConfigurationResponse_contents_data01 (c_SIGAPP_SLP_INCFG_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data[i]->AttributeRecord.AttributeValue.value);
			sp->data[i]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_SIGAPP_SLP_INCFG_ConfigurationResponse_contents */
void FREE_c_SIGAPP_SLP_INCFG_ConfigurationResponse_contents (c_SIGAPP_SLP_INCFG_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data01.data[i0]->AttributeRecord.AttributeValue.value);
			sp->data01.data[i0]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data01.data[i0]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_SIGAPP_SLP_Reset_contents */
void FREE_c_SIGAPP_SLP_Reset_contents (c_SIGAPP_SLP_Reset_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_SIGAPP_SLP_ResetAck_contents */
void FREE_c_SIGAPP_SLP_ResetAck_contents (c_SIGAPP_SLP_ResetAck_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_PKTAPP_DPA_INCFG_ConfigurationRequest_contents_data01 */
void FREE_c_PKTAPP_DPA_INCFG_ConfigurationRequest_contents_data01 (c_PKTAPP_DPA_INCFG_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Default_Packet_Application_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_PKTAPP_DPA_INCFG_ConfigurationRequest_contents */
void FREE_c_PKTAPP_DPA_INCFG_ConfigurationRequest_contents (c_PKTAPP_DPA_INCFG_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Default_Packet_Application_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_PKTAPP_DPA_INCFG_ConfigurationResponse_contents_data01 */
void FREE_c_PKTAPP_DPA_INCFG_ConfigurationResponse_contents_data01 (c_PKTAPP_DPA_INCFG_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Default_Packet_Application_Attributes_Response (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_PKTAPP_DPA_INCFG_ConfigurationResponse_contents */
void FREE_c_PKTAPP_DPA_INCFG_ConfigurationResponse_contents (c_PKTAPP_DPA_INCFG_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Default_Packet_Application_Attributes_Response (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_PKTAPP_RLP_INUSE_Nak_contents_data01 */
void FREE_c_PKTAPP_RLP_INUSE_Nak_contents_data01 (c_PKTAPP_RLP_INUSE_Nak_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_PKTAPP_RLP_INUSE_Nak_contents */
void FREE_c_PKTAPP_RLP_INUSE_Nak_contents (c_PKTAPP_RLP_INUSE_Nak_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_PKTAPP_LUP_INUSE_LocationNotification_contents */
void FREE_c_PKTAPP_LUP_INUSE_LocationNotification_contents (c_PKTAPP_LUP_INUSE_LocationNotification_contents* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->LocationValue_Present) {
		if (sp->LocationValue->value != NULL) {
			EDFree (sp->LocationValue->value);
			sp->LocationValue->value = NULL;
		}
		sp->LocationValue->usedBits = 0;
		EDFree (sp->LocationValue);
		sp->LocationValue_Present = ED_FALSE;
	}

}

void SETPRESENT_c_PKTAPP_LUP_INUSE_LocationNotification_contents_LocationValue (c_PKTAPP_LUP_INUSE_LocationNotification_contents* sp, ED_BOOLEAN present)
{
	/* Do nothing if already compliant to the request */
	if (sp->LocationValue_Present == present) return;
	sp->LocationValue_Present = present;
	if (present) {
		/*-->*/sp->LocationValue = (c_PKTAPP_LUP_INUSE_LocationNotification_contents_LocationValue*)EDAlloc (sizeof (c_PKTAPP_LUP_INUSE_LocationNotification_contents_LocationValue));
		sp->LocationValue->value = NULL;
		sp->LocationValue->usedBits = 0;
	} else {
		if (sp->LocationValue->value != NULL) {
			EDFree (sp->LocationValue->value);
			sp->LocationValue->value = NULL;
		}
		sp->LocationValue->usedBits = 0;
		EDFree (sp->LocationValue);
	}
}

/* Free function for struct c_PKTAPP_LUP_INUSE_LocationAssignment_contents */
void FREE_c_PKTAPP_LUP_INUSE_LocationAssignment_contents (c_PKTAPP_LUP_INUSE_LocationAssignment_contents* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->LocationValue.value != NULL) {
		EDFree (sp->LocationValue.value);
		sp->LocationValue.value = NULL;
	}
	sp->LocationValue.usedBits = 0;

}

/* Free function for struct c_PKTAPP_LUP_INUSE_LocationComplete_contents */
void FREE_c_PKTAPP_LUP_INUSE_LocationComplete_contents (c_PKTAPP_LUP_INUSE_LocationComplete_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_PKTAPP_FCP_INUSE_DataReady_contents */
void FREE_c_PKTAPP_FCP_INUSE_DataReady_contents (c_PKTAPP_FCP_INUSE_DataReady_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_PKTAPP_FCP_INUSE_DataReadyAck_contents */
void FREE_c_PKTAPP_FCP_INUSE_DataReadyAck_contents (c_PKTAPP_FCP_INUSE_DataReadyAck_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_MFPAPP_MFPA_INCFG_ConfigurationRequest_contents_data01 */
void FREE_c_MFPAPP_MFPA_INCFG_ConfigurationRequest_contents_data01 (c_MFPAPP_MFPA_INCFG_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Multi_Flow_Packet_Application_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MFPAPP_MFPA_INCFG_ConfigurationRequest_contents */
void FREE_c_MFPAPP_MFPA_INCFG_ConfigurationRequest_contents (c_MFPAPP_MFPA_INCFG_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Multi_Flow_Packet_Application_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_MFPAPP_MFPA_INCFG_ConfigurationResponse_contents_data01 */
void FREE_c_MFPAPP_MFPA_INCFG_ConfigurationResponse_contents_data01 (c_MFPAPP_MFPA_INCFG_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Multi_Flow_Packet_Application_Attributes_Response (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MFPAPP_MFPA_INCFG_ConfigurationResponse_contents */
void FREE_c_MFPAPP_MFPA_INCFG_ConfigurationResponse_contents (c_MFPAPP_MFPA_INCFG_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Multi_Flow_Packet_Application_Attributes_Response (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_MFPAPP_RLP_INUSE_ResetTxIndication_contents */
void FREE_c_MFPAPP_RLP_INUSE_ResetTxIndication_contents (c_MFPAPP_RLP_INUSE_ResetTxIndication_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_MFPAPP_RLP_INUSE_ResetRxIndication_contents */
void FREE_c_MFPAPP_RLP_INUSE_ResetRxIndication_contents (c_MFPAPP_RLP_INUSE_ResetRxIndication_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_MFPAPP_RLP_INUSE_ResetTxIndicationAck_contents */
void FREE_c_MFPAPP_RLP_INUSE_ResetTxIndicationAck_contents (c_MFPAPP_RLP_INUSE_ResetTxIndicationAck_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_MFPAPP_RLP_INUSE_ResetTxComplete_contents */
void FREE_c_MFPAPP_RLP_INUSE_ResetTxComplete_contents (c_MFPAPP_RLP_INUSE_ResetTxComplete_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_MFPAPP_RLP_INUSE_ResetRxComplete_contents */
void FREE_c_MFPAPP_RLP_INUSE_ResetRxComplete_contents (c_MFPAPP_RLP_INUSE_ResetRxComplete_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_MFPAPP_RLP_INUSE_Nak_contents_data01 */
void FREE_c_MFPAPP_RLP_INUSE_Nak_contents_data01 (c_MFPAPP_RLP_INUSE_Nak_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->FirstErased.value != NULL) {
			EDFree (sp->data[i]->FirstErased.value);
			sp->data[i]->FirstErased.value = NULL;
		}
		sp->data[i]->FirstErased.usedBits = 0;
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MFPAPP_RLP_INUSE_Nak_contents */
void FREE_c_MFPAPP_RLP_INUSE_Nak_contents (c_MFPAPP_RLP_INUSE_Nak_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->FirstErased.value != NULL) {
			EDFree (sp->data01.data[i0]->FirstErased.value);
			sp->data01.data[i0]->FirstErased.value = NULL;
		}
		sp->data01.data[i0]->FirstErased.usedBits = 0;
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_MFPAPP_RLP_INUSE_ReservationOnRequest_contents_data01 */
void FREE_c_MFPAPP_RLP_INUSE_ReservationOnRequest_contents_data01 (c_MFPAPP_RLP_INUSE_ReservationOnRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MFPAPP_RLP_INUSE_ReservationOnRequest_contents */
void FREE_c_MFPAPP_RLP_INUSE_ReservationOnRequest_contents (c_MFPAPP_RLP_INUSE_ReservationOnRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_MFPAPP_RLP_INUSE_ReservationOffRequest_contents_data01 */
void FREE_c_MFPAPP_RLP_INUSE_ReservationOffRequest_contents_data01 (c_MFPAPP_RLP_INUSE_ReservationOffRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MFPAPP_RLP_INUSE_ReservationOffRequest_contents */
void FREE_c_MFPAPP_RLP_INUSE_ReservationOffRequest_contents (c_MFPAPP_RLP_INUSE_ReservationOffRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_MFPAPP_RLP_INUSE_ReservationAccept_contents */
void FREE_c_MFPAPP_RLP_INUSE_ReservationAccept_contents (c_MFPAPP_RLP_INUSE_ReservationAccept_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_MFPAPP_RLP_INUSE_ReservationReject_contents_data01 */
void FREE_c_MFPAPP_RLP_INUSE_ReservationReject_contents_data01 (c_MFPAPP_RLP_INUSE_ReservationReject_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MFPAPP_RLP_INUSE_ReservationReject_contents */
void FREE_c_MFPAPP_RLP_INUSE_ReservationReject_contents (c_MFPAPP_RLP_INUSE_ReservationReject_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_MFPAPP_RLP_INUSE_RevReservationOn_contents_data01 */
void FREE_c_MFPAPP_RLP_INUSE_RevReservationOn_contents_data01 (c_MFPAPP_RLP_INUSE_RevReservationOn_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MFPAPP_RLP_INUSE_RevReservationOn_contents */
void FREE_c_MFPAPP_RLP_INUSE_RevReservationOn_contents (c_MFPAPP_RLP_INUSE_RevReservationOn_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_MFPAPP_RLP_INUSE_RevReservationOff_contents_data01 */
void FREE_c_MFPAPP_RLP_INUSE_RevReservationOff_contents_data01 (c_MFPAPP_RLP_INUSE_RevReservationOff_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MFPAPP_RLP_INUSE_RevReservationOff_contents */
void FREE_c_MFPAPP_RLP_INUSE_RevReservationOff_contents (c_MFPAPP_RLP_INUSE_RevReservationOff_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_MFPAPP_RLP_INUSE_FwdReservationOff_contents_data01 */
void FREE_c_MFPAPP_RLP_INUSE_FwdReservationOff_contents_data01 (c_MFPAPP_RLP_INUSE_FwdReservationOff_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MFPAPP_RLP_INUSE_FwdReservationOff_contents */
void FREE_c_MFPAPP_RLP_INUSE_FwdReservationOff_contents (c_MFPAPP_RLP_INUSE_FwdReservationOff_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_MFPAPP_RLP_INUSE_FwdReservationOn_contents_data01 */
void FREE_c_MFPAPP_RLP_INUSE_FwdReservationOn_contents_data01 (c_MFPAPP_RLP_INUSE_FwdReservationOn_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MFPAPP_RLP_INUSE_FwdReservationOn_contents */
void FREE_c_MFPAPP_RLP_INUSE_FwdReservationOn_contents (c_MFPAPP_RLP_INUSE_FwdReservationOn_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_MFPAPP_RLP_INUSE_FwdReservationAck_contents */
void FREE_c_MFPAPP_RLP_INUSE_FwdReservationAck_contents (c_MFPAPP_RLP_INUSE_FwdReservationAck_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_MFPAPP_RLP_INUSE_AttributeUpdateRequest_contents_data01 */
void FREE_c_MFPAPP_RLP_INUSE_AttributeUpdateRequest_contents_data01 (c_MFPAPP_RLP_INUSE_AttributeUpdateRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Multi_Flow_Packet_Application_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MFPAPP_RLP_INUSE_AttributeUpdateRequest_contents */
void FREE_c_MFPAPP_RLP_INUSE_AttributeUpdateRequest_contents (c_MFPAPP_RLP_INUSE_AttributeUpdateRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Multi_Flow_Packet_Application_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_MFPAPP_RLP_INUSE_AttributeUpdateAccept_contents */
void FREE_c_MFPAPP_RLP_INUSE_AttributeUpdateAccept_contents (c_MFPAPP_RLP_INUSE_AttributeUpdateAccept_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_MFPAPP_RLP_INUSE_AttributeUpdateReject_contents */
void FREE_c_MFPAPP_RLP_INUSE_AttributeUpdateReject_contents (c_MFPAPP_RLP_INUSE_AttributeUpdateReject_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_MFPAPP_DOSP_INUSE_DataOverSignaling_contents */
void FREE_c_MFPAPP_DOSP_INUSE_DataOverSignaling_contents (c_MFPAPP_DOSP_INUSE_DataOverSignaling_contents* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->HigherLayerPacket.value != NULL) {
		EDFree (sp->HigherLayerPacket.value);
		sp->HigherLayerPacket.value = NULL;
	}
	sp->HigherLayerPacket.usedBits = 0;

}

/* Free function for struct c_MFPAPP_DOSP_INUSE_DataOverSignalingAck_contents */
void FREE_c_MFPAPP_DOSP_INUSE_DataOverSignalingAck_contents (c_MFPAPP_DOSP_INUSE_DataOverSignalingAck_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_MFPAPP_LUP_INUSE_LocationNotification_contents */
void FREE_c_MFPAPP_LUP_INUSE_LocationNotification_contents (c_MFPAPP_LUP_INUSE_LocationNotification_contents* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->LocationValue_Present) {
		if (sp->LocationValue->value != NULL) {
			EDFree (sp->LocationValue->value);
			sp->LocationValue->value = NULL;
		}
		sp->LocationValue->usedBits = 0;
		EDFree (sp->LocationValue);
		sp->LocationValue_Present = ED_FALSE;
	}

}

void SETPRESENT_c_MFPAPP_LUP_INUSE_LocationNotification_contents_LocationValue (c_MFPAPP_LUP_INUSE_LocationNotification_contents* sp, ED_BOOLEAN present)
{
	/* Do nothing if already compliant to the request */
	if (sp->LocationValue_Present == present) return;
	sp->LocationValue_Present = present;
	if (present) {
		/*-->*/sp->LocationValue = (c_MFPAPP_LUP_INUSE_LocationNotification_contents_LocationValue*)EDAlloc (sizeof (c_MFPAPP_LUP_INUSE_LocationNotification_contents_LocationValue));
		sp->LocationValue->value = NULL;
		sp->LocationValue->usedBits = 0;
	} else {
		if (sp->LocationValue->value != NULL) {
			EDFree (sp->LocationValue->value);
			sp->LocationValue->value = NULL;
		}
		sp->LocationValue->usedBits = 0;
		EDFree (sp->LocationValue);
	}
}

/* Free function for struct c_MFPAPP_LUP_INUSE_LocationAssignment_contents */
void FREE_c_MFPAPP_LUP_INUSE_LocationAssignment_contents (c_MFPAPP_LUP_INUSE_LocationAssignment_contents* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->LocationValue.value != NULL) {
		EDFree (sp->LocationValue.value);
		sp->LocationValue.value = NULL;
	}
	sp->LocationValue.usedBits = 0;

}

/* Free function for struct c_MFPAPP_LUP_INUSE_LocationComplete_contents */
void FREE_c_MFPAPP_LUP_INUSE_LocationComplete_contents (c_MFPAPP_LUP_INUSE_LocationComplete_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_MFPAPP_LUP_INUSE_StorageBLOBNotification_contents */
void FREE_c_MFPAPP_LUP_INUSE_StorageBLOBNotification_contents (c_MFPAPP_LUP_INUSE_StorageBLOBNotification_contents* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->StorageBLOB_Present) {
		if (sp->StorageBLOB->value != NULL) {
			EDFree (sp->StorageBLOB->value);
			sp->StorageBLOB->value = NULL;
		}
		sp->StorageBLOB->usedBits = 0;
		EDFree (sp->StorageBLOB);
		sp->StorageBLOB_Present = ED_FALSE;
	}

}

void SETPRESENT_c_MFPAPP_LUP_INUSE_StorageBLOBNotification_contents_StorageBLOB (c_MFPAPP_LUP_INUSE_StorageBLOBNotification_contents* sp, ED_BOOLEAN present)
{
	/* Do nothing if already compliant to the request */
	if (sp->StorageBLOB_Present == present) return;
	sp->StorageBLOB_Present = present;
	if (present) {
		/*-->*/sp->StorageBLOB = (c_MFPAPP_LUP_INUSE_StorageBLOBNotification_contents_StorageBLOB*)EDAlloc (sizeof (c_MFPAPP_LUP_INUSE_StorageBLOBNotification_contents_StorageBLOB));
		sp->StorageBLOB->value = NULL;
		sp->StorageBLOB->usedBits = 0;
	} else {
		if (sp->StorageBLOB->value != NULL) {
			EDFree (sp->StorageBLOB->value);
			sp->StorageBLOB->value = NULL;
		}
		sp->StorageBLOB->usedBits = 0;
		EDFree (sp->StorageBLOB);
	}
}

/* Free function for struct c_MFPAPP_LUP_INUSE_StorageBLOBAssignment_contents */
void FREE_c_MFPAPP_LUP_INUSE_StorageBLOBAssignment_contents (c_MFPAPP_LUP_INUSE_StorageBLOBAssignment_contents* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->StorageBLOB.value != NULL) {
		EDFree (sp->StorageBLOB.value);
		sp->StorageBLOB.value = NULL;
	}
	sp->StorageBLOB.usedBits = 0;

}

/* Free function for struct c_MFPAPP_LUP_INUSE_StorageBLOBComplete_contents */
void FREE_c_MFPAPP_LUP_INUSE_StorageBLOBComplete_contents (c_MFPAPP_LUP_INUSE_StorageBLOBComplete_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_MFPAPP_FCP_INUSE_DataReady_contents */
void FREE_c_MFPAPP_FCP_INUSE_DataReady_contents (c_MFPAPP_FCP_INUSE_DataReady_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_MFPAPP_FCP_INUSE_DataReadyAck_contents */
void FREE_c_MFPAPP_FCP_INUSE_DataReadyAck_contents (c_MFPAPP_FCP_INUSE_DataReadyAck_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_STREAM_DSP_INCFG_ConfigurationRequest_contents_data01 */
void FREE_c_STREAM_DSP_INCFG_ConfigurationRequest_contents_data01 (c_STREAM_DSP_INCFG_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Default_Stream_Protocol_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_STREAM_DSP_INCFG_ConfigurationRequest_contents */
void FREE_c_STREAM_DSP_INCFG_ConfigurationRequest_contents (c_STREAM_DSP_INCFG_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Default_Stream_Protocol_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_STREAM_DSP_INCFG_ConfigurationResponse_contents_data01 */
void FREE_c_STREAM_DSP_INCFG_ConfigurationResponse_contents_data01 (c_STREAM_DSP_INCFG_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Default_Stream_Protocol_Attributes_Response (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_STREAM_DSP_INCFG_ConfigurationResponse_contents */
void FREE_c_STREAM_DSP_INCFG_ConfigurationResponse_contents (c_STREAM_DSP_INCFG_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Default_Stream_Protocol_Attributes_Response (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_STREAM_GVSP_INCFG_ConfigurationRequest_contents_data01 */
void FREE_c_STREAM_GVSP_INCFG_ConfigurationRequest_contents_data01 (c_STREAM_GVSP_INCFG_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Generic_Virtual_Stream_Protocol_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_STREAM_GVSP_INCFG_ConfigurationRequest_contents */
void FREE_c_STREAM_GVSP_INCFG_ConfigurationRequest_contents (c_STREAM_GVSP_INCFG_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Generic_Virtual_Stream_Protocol_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_STREAM_GVSP_INCFG_ConfigurationResponse_contents_data01 */
void FREE_c_STREAM_GVSP_INCFG_ConfigurationResponse_contents_data01 (c_STREAM_GVSP_INCFG_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Generic_Virtual_Stream_Protocol_Attributes_Response (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_STREAM_GVSP_INCFG_ConfigurationResponse_contents */
void FREE_c_STREAM_GVSP_INCFG_ConfigurationResponse_contents (c_STREAM_GVSP_INCFG_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Generic_Virtual_Stream_Protocol_Attributes_Response (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_SESSION_DSMP_INCFG_ConfigurationRequest_contents_data01 */
void FREE_c_SESSION_DSMP_INCFG_ConfigurationRequest_contents_data01 (c_SESSION_DSMP_INCFG_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Default_Session_Management_Protocol_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_SESSION_DSMP_INCFG_ConfigurationRequest_contents */
void FREE_c_SESSION_DSMP_INCFG_ConfigurationRequest_contents (c_SESSION_DSMP_INCFG_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Default_Session_Management_Protocol_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_SESSION_DSMP_INCFG_ConfigurationResponse_contents_data01 */
void FREE_c_SESSION_DSMP_INCFG_ConfigurationResponse_contents_data01 (c_SESSION_DSMP_INCFG_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Default_Session_Management_Protocol_Attributes_Response (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_SESSION_DSMP_INCFG_ConfigurationResponse_contents */
void FREE_c_SESSION_DSMP_INCFG_ConfigurationResponse_contents (c_SESSION_DSMP_INCFG_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Default_Session_Management_Protocol_Attributes_Response (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_SESSION_DSMP_INUSE_SessionClose_contents */
void FREE_c_SESSION_DSMP_INUSE_SessionClose_contents (c_SESSION_DSMP_INUSE_SessionClose_contents* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->MoreInfo.value != NULL) {
		EDFree (sp->MoreInfo.value);
		sp->MoreInfo.value = NULL;
	}
	sp->MoreInfo.usedBits = 0;

}

/* Free function for struct c_SESSION_DSMP_INUSE_KeepAliveRequest_contents */
void FREE_c_SESSION_DSMP_INUSE_KeepAliveRequest_contents (c_SESSION_DSMP_INUSE_KeepAliveRequest_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_SESSION_DSMP_INUSE_KeepAliveResponse_contents */
void FREE_c_SESSION_DSMP_INUSE_KeepAliveResponse_contents (c_SESSION_DSMP_INUSE_KeepAliveResponse_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_SESSION_DAMP_INCFG_ConfigurationRequest_contents_data01 */
void FREE_c_SESSION_DAMP_INCFG_ConfigurationRequest_contents_data01 (c_SESSION_DAMP_INCFG_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Default_Address_Management_Protocol_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_SESSION_DAMP_INCFG_ConfigurationRequest_contents */
void FREE_c_SESSION_DAMP_INCFG_ConfigurationRequest_contents (c_SESSION_DAMP_INCFG_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Default_Address_Management_Protocol_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_SESSION_DAMP_INCFG_ConfigurationResponse_contents_data01 */
void FREE_c_SESSION_DAMP_INCFG_ConfigurationResponse_contents_data01 (c_SESSION_DAMP_INCFG_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Default_Address_Management_Protocol_Attributes_Response (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_SESSION_DAMP_INCFG_ConfigurationResponse_contents */
void FREE_c_SESSION_DAMP_INCFG_ConfigurationResponse_contents (c_SESSION_DAMP_INCFG_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Default_Address_Management_Protocol_Attributes_Response (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_SESSION_DAMP_INUSE_UATIRequest_contents */
void FREE_c_SESSION_DAMP_INUSE_UATIRequest_contents (c_SESSION_DAMP_INUSE_UATIRequest_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_SESSION_DAMP_INUSE_UATIAssignment_contents */
void FREE_c_SESSION_DAMP_INUSE_UATIAssignment_contents (c_SESSION_DAMP_INUSE_UATIAssignment_contents* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->UATI104_Present) {
		EDFree (sp->UATI104);
		sp->UATI104_Present = ED_FALSE;
	}

}

void SETPRESENT_c_SESSION_DAMP_INUSE_UATIAssignment_contents_UATI104 (c_SESSION_DAMP_INUSE_UATIAssignment_contents* sp, ED_BOOLEAN present)
{
	/* Do nothing if already compliant to the request */
	if (sp->UATI104_Present == present) return;
	sp->UATI104_Present = present;
	if (present) {
		/*-->*/sp->UATI104 = (ED_BYTE*)EDAlloc ((size_t)13);
		ED_RESET_MEM (sp->UATI104, 13);
	} else {
		EDFree (sp->UATI104);
	}
}

/* Free function for struct c_SESSION_DAMP_INUSE_UATIComplete_contents */
void FREE_c_SESSION_DAMP_INUSE_UATIComplete_contents (c_SESSION_DAMP_INUSE_UATIComplete_contents* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->UpperOldUATI.value != NULL) {
		EDFree (sp->UpperOldUATI.value);
		sp->UpperOldUATI.value = NULL;
	}
	sp->UpperOldUATI.usedBits = 0;

}

/* Free function for struct c_SESSION_DAMP_INUSE_HardwareIDRequest_contents */
void FREE_c_SESSION_DAMP_INUSE_HardwareIDRequest_contents (c_SESSION_DAMP_INUSE_HardwareIDRequest_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_SESSION_DAMP_INUSE_HardwareIDResponse_contents */
void FREE_c_SESSION_DAMP_INUSE_HardwareIDResponse_contents (c_SESSION_DAMP_INUSE_HardwareIDResponse_contents* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->HardwareIDValue.value != NULL) {
		EDFree (sp->HardwareIDValue.value);
		sp->HardwareIDValue.value = NULL;
	}
	sp->HardwareIDValue.usedBits = 0;

}

/* Free function for variable-sized sequence c_SESSION_DAMP_INUSE_AttributeUpdateRequest_contents_data01 */
void FREE_c_SESSION_DAMP_INUSE_AttributeUpdateRequest_contents_data01 (c_SESSION_DAMP_INUSE_AttributeUpdateRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Default_Address_Management_Protocol_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_SESSION_DAMP_INUSE_AttributeUpdateRequest_contents */
void FREE_c_SESSION_DAMP_INUSE_AttributeUpdateRequest_contents (c_SESSION_DAMP_INUSE_AttributeUpdateRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Default_Address_Management_Protocol_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_SESSION_DAMP_INUSE_AttributeUpdateAccept_contents */
void FREE_c_SESSION_DAMP_INUSE_AttributeUpdateAccept_contents (c_SESSION_DAMP_INUSE_AttributeUpdateAccept_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_SESSION_DAMP_INUSE_AttributeUpdateReject_contents */
void FREE_c_SESSION_DAMP_INUSE_AttributeUpdateReject_contents (c_SESSION_DAMP_INUSE_AttributeUpdateReject_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_SESSION_DSCP_INUSE_ConfigurationComplete_contents */
void FREE_c_SESSION_DSCP_INUSE_ConfigurationComplete_contents (c_SESSION_DSCP_INUSE_ConfigurationComplete_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_SESSION_DSCP_INUSE_ConfigurationRequest_contents_data01 */
void FREE_c_SESSION_DSCP_INUSE_ConfigurationRequest_contents_data01 (c_SESSION_DSCP_INUSE_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Default_Session_Configuration_Protocol_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_SESSION_DSCP_INUSE_ConfigurationRequest_contents */
void FREE_c_SESSION_DSCP_INUSE_ConfigurationRequest_contents (c_SESSION_DSCP_INUSE_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Default_Session_Configuration_Protocol_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_SESSION_DSCP_INUSE_ConfigurationResponse_contents_data01 */
void FREE_c_SESSION_DSCP_INUSE_ConfigurationResponse_contents_data01 (c_SESSION_DSCP_INUSE_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Default_Session_Configuration_Protocol_Attributes_Response (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_SESSION_DSCP_INUSE_ConfigurationResponse_contents */
void FREE_c_SESSION_DSCP_INUSE_ConfigurationResponse_contents (c_SESSION_DSCP_INUSE_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Default_Session_Configuration_Protocol_Attributes_Response (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_SESSION_DSCP_INUSE_SoftConfigurationComplete_contents */
void FREE_c_SESSION_DSCP_INUSE_SoftConfigurationComplete_contents (c_SESSION_DSCP_INUSE_SoftConfigurationComplete_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_SESSION_DSCP_INUSE_LockConfiguration_contents */
void FREE_c_SESSION_DSCP_INUSE_LockConfiguration_contents (c_SESSION_DSCP_INUSE_LockConfiguration_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_SESSION_DSCP_INUSE_LockConfigurationAck_contents */
void FREE_c_SESSION_DSCP_INUSE_LockConfigurationAck_contents (c_SESSION_DSCP_INUSE_LockConfigurationAck_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_SESSION_DSCP_INUSE_UnLockConfiguration_contents */
void FREE_c_SESSION_DSCP_INUSE_UnLockConfiguration_contents (c_SESSION_DSCP_INUSE_UnLockConfiguration_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_SESSION_DSCP_INUSE_UnLockConfigurationAck_contents */
void FREE_c_SESSION_DSCP_INUSE_UnLockConfigurationAck_contents (c_SESSION_DSCP_INUSE_UnLockConfigurationAck_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_SESSION_DSCP_INUSE_DeletePersonality_contents_data01 */
void FREE_c_SESSION_DSCP_INUSE_DeletePersonality_contents_data01 (c_SESSION_DSCP_INUSE_DeletePersonality_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_SESSION_DSCP_INUSE_DeletePersonality_contents */
void FREE_c_SESSION_DSCP_INUSE_DeletePersonality_contents (c_SESSION_DSCP_INUSE_DeletePersonality_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_SESSION_DSCP_INUSE_DeletePersonalityAck_contents */
void FREE_c_SESSION_DSCP_INUSE_DeletePersonalityAck_contents (c_SESSION_DSCP_INUSE_DeletePersonalityAck_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_SESSION_DSCP_INUSE_AttributeUpdateRequest_contents_data01 */
void FREE_c_SESSION_DSCP_INUSE_AttributeUpdateRequest_contents_data01 (c_SESSION_DSCP_INUSE_AttributeUpdateRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Default_Session_Configuration_Protocol_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_SESSION_DSCP_INUSE_AttributeUpdateRequest_contents */
void FREE_c_SESSION_DSCP_INUSE_AttributeUpdateRequest_contents (c_SESSION_DSCP_INUSE_AttributeUpdateRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Default_Session_Configuration_Protocol_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_SESSION_DSCP_INUSE_AttributeUpdateAccept_contents */
void FREE_c_SESSION_DSCP_INUSE_AttributeUpdateAccept_contents (c_SESSION_DSCP_INUSE_AttributeUpdateAccept_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_SESSION_DSCP_INUSE_AttributeUpdateReject_contents */
void FREE_c_SESSION_DSCP_INUSE_AttributeUpdateReject_contents (c_SESSION_DSCP_INUSE_AttributeUpdateReject_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_SESSION_GMCDP_INCFG_ConfigurationRequest_contents_data01 */
void FREE_c_SESSION_GMCDP_INCFG_ConfigurationRequest_contents_data01 (c_SESSION_GMCDP_INCFG_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Generic_Multimode_Capability_Discovery_Protocol_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_SESSION_GMCDP_INCFG_ConfigurationRequest_contents */
void FREE_c_SESSION_GMCDP_INCFG_ConfigurationRequest_contents (c_SESSION_GMCDP_INCFG_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Generic_Multimode_Capability_Discovery_Protocol_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_SESSION_GMCDP_INCFG_ConfigurationResponse_contents_data01 */
void FREE_c_SESSION_GMCDP_INCFG_ConfigurationResponse_contents_data01 (c_SESSION_GMCDP_INCFG_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Generic_Multimode_Capability_Discovery_Protocol_Attributes_Response (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_SESSION_GMCDP_INCFG_ConfigurationResponse_contents */
void FREE_c_SESSION_GMCDP_INCFG_ConfigurationResponse_contents (c_SESSION_GMCDP_INCFG_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Generic_Multimode_Capability_Discovery_Protocol_Attributes_Response (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_CONN_DALMP_INCFG_ConfigurationRequest_contents_data01 */
void FREE_c_CONN_DALMP_INCFG_ConfigurationRequest_contents_data01 (c_CONN_DALMP_INCFG_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Default_Air_Link_Management_Protocol_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_CONN_DALMP_INCFG_ConfigurationRequest_contents */
void FREE_c_CONN_DALMP_INCFG_ConfigurationRequest_contents (c_CONN_DALMP_INCFG_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Default_Air_Link_Management_Protocol_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_CONN_DALMP_INCFG_ConfigurationResponse_contents_data01 */
void FREE_c_CONN_DALMP_INCFG_ConfigurationResponse_contents_data01 (c_CONN_DALMP_INCFG_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Default_Air_Link_Management_Protocol_Attributes_Response (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_CONN_DALMP_INCFG_ConfigurationResponse_contents */
void FREE_c_CONN_DALMP_INCFG_ConfigurationResponse_contents (c_CONN_DALMP_INCFG_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Default_Air_Link_Management_Protocol_Attributes_Response (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_CONN_DALMP_INUSE_Redirect_contents_data01 */
void FREE_c_CONN_DALMP_INUSE_Redirect_contents_data01 (c_CONN_DALMP_INUSE_Redirect_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_CONN_DALMP_INUSE_Redirect_contents */
void FREE_c_CONN_DALMP_INUSE_Redirect_contents (c_CONN_DALMP_INUSE_Redirect_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_CONN_DALMP_INUSE_ConnectionFailureReport_contents_data01 */
void FREE_c_CONN_DALMP_INUSE_ConnectionFailureReport_contents_data01 (c_CONN_DALMP_INUSE_ConnectionFailureReport_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->Latitude_Present) {
		}
		if (sp->data[i]->Longitude_Present) {
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_CONN_DALMP_INUSE_ConnectionFailureReport_contents */
void FREE_c_CONN_DALMP_INUSE_ConnectionFailureReport_contents (c_CONN_DALMP_INUSE_ConnectionFailureReport_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->Latitude_Present) {
		}
		if (sp->data01.data[i0]->Longitude_Present) {
		}
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_CONN_DALMP_INUSE_ConnectionFailureReportAck_contents */
void FREE_c_CONN_DALMP_INUSE_ConnectionFailureReportAck_contents (c_CONN_DALMP_INUSE_ConnectionFailureReportAck_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_CONN_DINSP_INCFG_ConfigurationRequest_contents_data01 */
void FREE_c_CONN_DINSP_INCFG_ConfigurationRequest_contents_data01 (c_CONN_DINSP_INCFG_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data[i]->AttributeRecord.AttributeValue.value);
			sp->data[i]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_CONN_DINSP_INCFG_ConfigurationRequest_contents */
void FREE_c_CONN_DINSP_INCFG_ConfigurationRequest_contents (c_CONN_DINSP_INCFG_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data01.data[i0]->AttributeRecord.AttributeValue.value);
			sp->data01.data[i0]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data01.data[i0]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_CONN_DINSP_INCFG_ConfigurationResponse_contents_data01 */
void FREE_c_CONN_DINSP_INCFG_ConfigurationResponse_contents_data01 (c_CONN_DINSP_INCFG_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data[i]->AttributeRecord.AttributeValue.value);
			sp->data[i]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_CONN_DINSP_INCFG_ConfigurationResponse_contents */
void FREE_c_CONN_DINSP_INCFG_ConfigurationResponse_contents (c_CONN_DINSP_INCFG_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data01.data[i0]->AttributeRecord.AttributeValue.value);
			sp->data01.data[i0]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data01.data[i0]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_CONN_DINSP_INUSE_Sync_contents */
void FREE_c_CONN_DINSP_INUSE_Sync_contents (c_CONN_DINSP_INUSE_Sync_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_CONN_DIDSP_INCFG_ConfigurationRequest_contents_data01 */
void FREE_c_CONN_DIDSP_INCFG_ConfigurationRequest_contents_data01 (c_CONN_DIDSP_INCFG_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Default_Idle_State_Protocol_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_CONN_DIDSP_INCFG_ConfigurationRequest_contents */
void FREE_c_CONN_DIDSP_INCFG_ConfigurationRequest_contents (c_CONN_DIDSP_INCFG_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Default_Idle_State_Protocol_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_CONN_DIDSP_INCFG_ConfigurationResponse_contents_data01 */
void FREE_c_CONN_DIDSP_INCFG_ConfigurationResponse_contents_data01 (c_CONN_DIDSP_INCFG_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Default_Idle_State_Protocol_Attributes_Response (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_CONN_DIDSP_INCFG_ConfigurationResponse_contents */
void FREE_c_CONN_DIDSP_INCFG_ConfigurationResponse_contents (c_CONN_DIDSP_INCFG_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Default_Idle_State_Protocol_Attributes_Response (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_CONN_DIDSP_INUSE_ConnectionRequest_contents */
void FREE_c_CONN_DIDSP_INUSE_ConnectionRequest_contents (c_CONN_DIDSP_INUSE_ConnectionRequest_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_CONN_DIDSP_INUSE_ConnectionDeny_contents */
void FREE_c_CONN_DIDSP_INUSE_ConnectionDeny_contents (c_CONN_DIDSP_INUSE_ConnectionDeny_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_CONN_EISP_INCFG_ConfigurationRequest_contents_data01 */
void FREE_c_CONN_EISP_INCFG_ConfigurationRequest_contents_data01 (c_CONN_EISP_INCFG_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Enhanced_Idle_State_Protocol_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_CONN_EISP_INCFG_ConfigurationRequest_contents */
void FREE_c_CONN_EISP_INCFG_ConfigurationRequest_contents (c_CONN_EISP_INCFG_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Enhanced_Idle_State_Protocol_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_CONN_EISP_INCFG_ConfigurationResponse_contents_data01 */
void FREE_c_CONN_EISP_INCFG_ConfigurationResponse_contents_data01 (c_CONN_EISP_INCFG_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Enhanced_Idle_State_Protocol_Attributes_Response (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_CONN_EISP_INCFG_ConfigurationResponse_contents */
void FREE_c_CONN_EISP_INCFG_ConfigurationResponse_contents (c_CONN_EISP_INCFG_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Enhanced_Idle_State_Protocol_Attributes_Response (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_CONN_EISP_INUSE_Page_contents */
void FREE_c_CONN_EISP_INUSE_Page_contents (c_CONN_EISP_INUSE_Page_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_CONN_EISP_INUSE_ConnectionRequest_contents_data01 */
void FREE_c_CONN_EISP_INUSE_ConnectionRequest_contents_data01 (c_CONN_EISP_INUSE_ConnectionRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_CONN_EISP_INUSE_ConnectionRequest_contents */
void FREE_c_CONN_EISP_INUSE_ConnectionRequest_contents (c_CONN_EISP_INUSE_ConnectionRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_CONN_EISP_INUSE_ConnectionDeny_contents */
void FREE_c_CONN_EISP_INUSE_ConnectionDeny_contents (c_CONN_EISP_INUSE_ConnectionDeny_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_CONN_EISP_INUSE_AttributeUpdateRequest_contents_data01 */
void FREE_c_CONN_EISP_INUSE_AttributeUpdateRequest_contents_data01 (c_CONN_EISP_INUSE_AttributeUpdateRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Enhanced_Idle_State_Protocol_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_CONN_EISP_INUSE_AttributeUpdateRequest_contents */
void FREE_c_CONN_EISP_INUSE_AttributeUpdateRequest_contents (c_CONN_EISP_INUSE_AttributeUpdateRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Enhanced_Idle_State_Protocol_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_CONN_EISP_INUSE_AttributeUpdateAccept_contents */
void FREE_c_CONN_EISP_INUSE_AttributeUpdateAccept_contents (c_CONN_EISP_INUSE_AttributeUpdateAccept_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_CONN_EISP_INUSE_AttributeUpdateReject_contents */
void FREE_c_CONN_EISP_INUSE_AttributeUpdateReject_contents (c_CONN_EISP_INUSE_AttributeUpdateReject_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_CONN_QISP_INCFG_ConfigurationRequest_contents_data01 */
void FREE_c_CONN_QISP_INCFG_ConfigurationRequest_contents_data01 (c_CONN_QISP_INCFG_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Quick_Idle_State_Protocol_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_CONN_QISP_INCFG_ConfigurationRequest_contents */
void FREE_c_CONN_QISP_INCFG_ConfigurationRequest_contents (c_CONN_QISP_INCFG_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Quick_Idle_State_Protocol_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_CONN_QISP_INCFG_ConfigurationResponse_contents_data01 */
void FREE_c_CONN_QISP_INCFG_ConfigurationResponse_contents_data01 (c_CONN_QISP_INCFG_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Quick_Idle_State_Protocol_Attributes_Response (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_CONN_QISP_INCFG_ConfigurationResponse_contents */
void FREE_c_CONN_QISP_INCFG_ConfigurationResponse_contents (c_CONN_QISP_INCFG_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Quick_Idle_State_Protocol_Attributes_Response (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_CONN_QISP_INUSE_Page_contents */
void FREE_c_CONN_QISP_INUSE_Page_contents (c_CONN_QISP_INUSE_Page_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_CONN_QISP_INUSE_ConnectionRequest_contents_data01 */
void FREE_c_CONN_QISP_INUSE_ConnectionRequest_contents_data01 (c_CONN_QISP_INUSE_ConnectionRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_CONN_QISP_INUSE_ConnectionRequest_contents */
void FREE_c_CONN_QISP_INUSE_ConnectionRequest_contents (c_CONN_QISP_INUSE_ConnectionRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_CONN_QISP_INUSE_ConnectionDeny_contents */
void FREE_c_CONN_QISP_INUSE_ConnectionDeny_contents (c_CONN_QISP_INUSE_ConnectionDeny_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_CONN_QISP_INUSE_QuickPage_contents_data01 */
void FREE_c_CONN_QISP_INUSE_QuickPage_contents_data01 (c_CONN_QISP_INUSE_QuickPage_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_CONN_QISP_INUSE_QuickPage_contents */
void FREE_c_CONN_QISP_INUSE_QuickPage_contents (c_CONN_QISP_INUSE_QuickPage_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_CONN_QISP_INUSE_AttributeUpdateRequest_contents_data01 */
void FREE_c_CONN_QISP_INUSE_AttributeUpdateRequest_contents_data01 (c_CONN_QISP_INUSE_AttributeUpdateRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Quick_Idle_State_Protocol_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_CONN_QISP_INUSE_AttributeUpdateRequest_contents */
void FREE_c_CONN_QISP_INUSE_AttributeUpdateRequest_contents (c_CONN_QISP_INUSE_AttributeUpdateRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Quick_Idle_State_Protocol_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_CONN_QISP_INUSE_AttributeUpdateAccept_contents */
void FREE_c_CONN_QISP_INUSE_AttributeUpdateAccept_contents (c_CONN_QISP_INUSE_AttributeUpdateAccept_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_CONN_QISP_INUSE_AttributeUpdateReject_contents */
void FREE_c_CONN_QISP_INUSE_AttributeUpdateReject_contents (c_CONN_QISP_INUSE_AttributeUpdateReject_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_CONN_DCSP_INCFG_ConfigurationRequest_contents_data01 */
void FREE_c_CONN_DCSP_INCFG_ConfigurationRequest_contents_data01 (c_CONN_DCSP_INCFG_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data[i]->AttributeRecord.AttributeValue.value);
			sp->data[i]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_CONN_DCSP_INCFG_ConfigurationRequest_contents */
void FREE_c_CONN_DCSP_INCFG_ConfigurationRequest_contents (c_CONN_DCSP_INCFG_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data01.data[i0]->AttributeRecord.AttributeValue.value);
			sp->data01.data[i0]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data01.data[i0]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_CONN_DCSP_INCFG_ConfigurationResponse_contents_data01 */
void FREE_c_CONN_DCSP_INCFG_ConfigurationResponse_contents_data01 (c_CONN_DCSP_INCFG_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data[i]->AttributeRecord.AttributeValue.value);
			sp->data[i]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_CONN_DCSP_INCFG_ConfigurationResponse_contents */
void FREE_c_CONN_DCSP_INCFG_ConfigurationResponse_contents (c_CONN_DCSP_INCFG_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data01.data[i0]->AttributeRecord.AttributeValue.value);
			sp->data01.data[i0]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data01.data[i0]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_CONN_DCSP_INUSE_ConnectionClose_contents */
void FREE_c_CONN_DCSP_INUSE_ConnectionClose_contents (c_CONN_DCSP_INUSE_ConnectionClose_contents* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->SuspendTime_Present) {
		EDFree (sp->SuspendTime);
		sp->SuspendTime_Present = ED_FALSE;
	}

}

void SETPRESENT_c_CONN_DCSP_INUSE_ConnectionClose_contents_SuspendTime (c_CONN_DCSP_INUSE_ConnectionClose_contents* sp, ED_BOOLEAN present)
{
	/* Do nothing if already compliant to the request */
	if (sp->SuspendTime_Present == present) return;
	sp->SuspendTime_Present = present;
	if (present) {
		/*-->*/sp->SuspendTime = (ED_BYTE*)EDAlloc ((size_t)5);
		ED_RESET_MEM (sp->SuspendTime, 5);
	} else {
		EDFree (sp->SuspendTime);
	}
}

/* Free function for variable-sized sequence c_CONN_DRUP_INCFG_ConfigurationRequest_contents_data01 */
void FREE_c_CONN_DRUP_INCFG_ConfigurationRequest_contents_data01 (c_CONN_DRUP_INCFG_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Default_Route_Update_Protocol_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_CONN_DRUP_INCFG_ConfigurationRequest_contents */
void FREE_c_CONN_DRUP_INCFG_ConfigurationRequest_contents (c_CONN_DRUP_INCFG_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Default_Route_Update_Protocol_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_CONN_DRUP_INCFG_ConfigurationResponse_contents_data01 */
void FREE_c_CONN_DRUP_INCFG_ConfigurationResponse_contents_data01 (c_CONN_DRUP_INCFG_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Default_Route_Update_Protocol_Attributes_Response (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_CONN_DRUP_INCFG_ConfigurationResponse_contents */
void FREE_c_CONN_DRUP_INCFG_ConfigurationResponse_contents (c_CONN_DRUP_INCFG_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Default_Route_Update_Protocol_Attributes_Response (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_CONN_DRUP_INUSE_RouteUpdate_contents_data01 */
void FREE_c_CONN_DRUP_INUSE_RouteUpdate_contents_data01 (c_CONN_DRUP_INUSE_RouteUpdate_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->Channel_Present) {
			EDFree (sp->data[i]->Channel);
			sp->data[i]->Channel = NULL;
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_CONN_DRUP_INUSE_RouteUpdate_contents */
void FREE_c_CONN_DRUP_INUSE_RouteUpdate_contents (c_CONN_DRUP_INUSE_RouteUpdate_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->Channel_Present) {
			EDFree (sp->data01.data[i0]->Channel);
			sp->data01.data[i0]->Channel = NULL;
		}
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data01 */
void FREE_c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data01 (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data02 */
void FREE_c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data02 (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data02* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->RAChannelGain_Present) {
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data03 */
void FREE_c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data03 (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data03* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->MACIndexMSB_Present) {
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data04 */
void FREE_c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data04 (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data04* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->DSC_Present) {
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data05 */
void FREE_c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data05 (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data05* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->DeltaT2P_Present) {
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents */
void FREE_c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	if (sp->Channel_Present) {
		EDFree (sp->Channel);
		sp->Channel = NULL;
		sp->Channel_Present = ED_FALSE;
	}
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data02.items; i0++) {
		if (sp->data02.data[i0]->RAChannelGain_Present) {
		}
		EDFree (sp->data02.data[i0]);
		sp->data02.data[i0] = NULL;
	}
	if (sp->data02.data) {EDFree (sp->data02.data); sp->data02.data = NULL; sp->data02.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data03.items; i0++) {
		if (sp->data03.data[i0]->MACIndexMSB_Present) {
		}
		EDFree (sp->data03.data[i0]);
		sp->data03.data[i0] = NULL;
	}
	if (sp->data03.data) {EDFree (sp->data03.data); sp->data03.data = NULL; sp->data03.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data04.items; i0++) {
		if (sp->data04.data[i0]->DSC_Present) {
		}
		EDFree (sp->data04.data[i0]);
		sp->data04.data[i0] = NULL;
	}
	if (sp->data04.data) {EDFree (sp->data04.data); sp->data04.data = NULL; sp->data04.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data05.items; i0++) {
		if (sp->data05.data[i0]->DeltaT2P_Present) {
		}
		EDFree (sp->data05.data[i0]);
		sp->data05.data[i0] = NULL;
	}
	if (sp->data05.data) {EDFree (sp->data05.data); sp->data05.data = NULL; sp->data05.allocatedItems=0; /*FR02A*/}

}

void SETPRESENT_c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_Channel (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents* sp, ED_BOOLEAN present)
{
	/* Do nothing if already compliant to the request */
	if (sp->Channel_Present == present) return;
	sp->Channel_Present = present;
	if (present) {
		/*-->*/sp->Channel = (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_Channel*)EDAlloc (sizeof (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_Channel));
		ED_RESET_MEM (sp->Channel, sizeof (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_Channel));
		(sp->Channel->SystemType) = 0;
		(sp->Channel->BandClass) = 0;
		(sp->Channel->ChannelNumber) = 0;
	} else {
		EDFree (sp->Channel);
		sp->Channel = NULL;
	}
}

/* Free function for struct c_CONN_DRUP_INUSE_TrafficChannelComplete_contents */
void FREE_c_CONN_DRUP_INUSE_TrafficChannelComplete_contents (c_CONN_DRUP_INUSE_TrafficChannelComplete_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_CONN_DRUP_INUSE_NeighborList_contents_data01 */
void FREE_c_CONN_DRUP_INUSE_NeighborList_contents_data01 (c_CONN_DRUP_INUSE_NeighborList_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_CONN_DRUP_INUSE_NeighborList_contents_data02 */
void FREE_c_CONN_DRUP_INUSE_NeighborList_contents_data02 (c_CONN_DRUP_INUSE_NeighborList_contents_data02* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->Channel_Present) {
			EDFree (sp->data[i]->Channel);
			sp->data[i]->Channel = NULL;
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_CONN_DRUP_INUSE_NeighborList_contents_data03 */
void FREE_c_CONN_DRUP_INUSE_NeighborList_contents_data03 (c_CONN_DRUP_INUSE_NeighborList_contents_data03* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->SearchWindowSize_Present) {
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_CONN_DRUP_INUSE_NeighborList_contents_data04 */
void FREE_c_CONN_DRUP_INUSE_NeighborList_contents_data04 (c_CONN_DRUP_INUSE_NeighborList_contents_data04* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->SearchWindowOffset_Present) {
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_CONN_DRUP_INUSE_NeighborList_contents_data05 */
void FREE_c_CONN_DRUP_INUSE_NeighborList_contents_data05 (c_CONN_DRUP_INUSE_NeighborList_contents_data05* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->FPDCHSupported_Present) {
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_CONN_DRUP_INUSE_NeighborList_contents */
void FREE_c_CONN_DRUP_INUSE_NeighborList_contents (c_CONN_DRUP_INUSE_NeighborList_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data02.items; i0++) {
		if (sp->data02.data[i0]->Channel_Present) {
			EDFree (sp->data02.data[i0]->Channel);
			sp->data02.data[i0]->Channel = NULL;
		}
		EDFree (sp->data02.data[i0]);
		sp->data02.data[i0] = NULL;
	}
	if (sp->data02.data) {EDFree (sp->data02.data); sp->data02.data = NULL; sp->data02.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data03.items; i0++) {
		if (sp->data03.data[i0]->SearchWindowSize_Present) {
		}
		EDFree (sp->data03.data[i0]);
		sp->data03.data[i0] = NULL;
	}
	if (sp->data03.data) {EDFree (sp->data03.data); sp->data03.data = NULL; sp->data03.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data04.items; i0++) {
		if (sp->data04.data[i0]->SearchWindowOffset_Present) {
		}
		EDFree (sp->data04.data[i0]);
		sp->data04.data[i0] = NULL;
	}
	if (sp->data04.data) {EDFree (sp->data04.data); sp->data04.data = NULL; sp->data04.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data05.items; i0++) {
		if (sp->data05.data[i0]->FPDCHSupported_Present) {
		}
		EDFree (sp->data05.data[i0]);
		sp->data05.data[i0] = NULL;
	}
	if (sp->data05.data) {EDFree (sp->data05.data); sp->data05.data = NULL; sp->data05.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_CONN_DRUP_INUSE_AttributeOverride_contents_data01 */
void FREE_c_CONN_DRUP_INUSE_AttributeOverride_contents_data01 (c_CONN_DRUP_INUSE_AttributeOverride_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Default_Route_Update_Protocol_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_CONN_DRUP_INUSE_AttributeOverride_contents */
void FREE_c_CONN_DRUP_INUSE_AttributeOverride_contents (c_CONN_DRUP_INUSE_AttributeOverride_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Default_Route_Update_Protocol_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_CONN_DRUP_INUSE_AttributeOverrideResponse_contents */
void FREE_c_CONN_DRUP_INUSE_AttributeOverrideResponse_contents (c_CONN_DRUP_INUSE_AttributeOverrideResponse_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data01 */
void FREE_c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data01 (c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data02 */
void FREE_c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data02 (c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data02* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->SectorSearchWindowSize_Present) {
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data03 */
void FREE_c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data03 (c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data03* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->SectorSearchWindowOffset_Present) {
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_CONN_DRUP_INUSE_RouteUpdateRequest_contents */
void FREE_c_CONN_DRUP_INUSE_RouteUpdateRequest_contents (c_CONN_DRUP_INUSE_RouteUpdateRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	if (sp->Channel_Present) {
		EDFree (sp->Channel);
		sp->Channel = NULL;
		sp->Channel_Present = ED_FALSE;
	}
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data02.items; i0++) {
		if (sp->data02.data[i0]->SectorSearchWindowSize_Present) {
		}
		EDFree (sp->data02.data[i0]);
		sp->data02.data[i0] = NULL;
	}
	if (sp->data02.data) {EDFree (sp->data02.data); sp->data02.data = NULL; sp->data02.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data03.items; i0++) {
		if (sp->data03.data[i0]->SectorSearchWindowOffset_Present) {
		}
		EDFree (sp->data03.data[i0]);
		sp->data03.data[i0] = NULL;
	}
	if (sp->data03.data) {EDFree (sp->data03.data); sp->data03.data = NULL; sp->data03.allocatedItems=0; /*FR02A*/}

}

void SETPRESENT_c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_Channel (c_CONN_DRUP_INUSE_RouteUpdateRequest_contents* sp, ED_BOOLEAN present)
{
	/* Do nothing if already compliant to the request */
	if (sp->Channel_Present == present) return;
	sp->Channel_Present = present;
	if (present) {
		/*-->*/sp->Channel = (c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_Channel*)EDAlloc (sizeof (c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_Channel));
		ED_RESET_MEM (sp->Channel, sizeof (c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_Channel));
		(sp->Channel->SystemType) = 0;
		(sp->Channel->BandClass) = 0;
		(sp->Channel->ChannelNumber) = 0;
	} else {
		EDFree (sp->Channel);
		sp->Channel = NULL;
	}
}

/* Free function for variable-sized sequence c_CONN_DRUP_INUSE_AttributeUpdateRequest_contents_data01 */
void FREE_c_CONN_DRUP_INUSE_AttributeUpdateRequest_contents_data01 (c_CONN_DRUP_INUSE_AttributeUpdateRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Default_Route_Update_Protocol_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_CONN_DRUP_INUSE_AttributeUpdateRequest_contents */
void FREE_c_CONN_DRUP_INUSE_AttributeUpdateRequest_contents (c_CONN_DRUP_INUSE_AttributeUpdateRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Default_Route_Update_Protocol_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_CONN_DRUP_INUSE_AttributeUpdateAccept_contents */
void FREE_c_CONN_DRUP_INUSE_AttributeUpdateAccept_contents (c_CONN_DRUP_INUSE_AttributeUpdateAccept_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_CONN_DRUP_INUSE_AttributeUpdateReject_contents */
void FREE_c_CONN_DRUP_INUSE_AttributeUpdateReject_contents (c_CONN_DRUP_INUSE_AttributeUpdateReject_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_CONN_MRUP_INCFG_ConfigurationRequest_contents_data01 */
void FREE_c_CONN_MRUP_INCFG_ConfigurationRequest_contents_data01 (c_CONN_MRUP_INCFG_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Multicarrier_Route_Update_Protocol_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_CONN_MRUP_INCFG_ConfigurationRequest_contents */
void FREE_c_CONN_MRUP_INCFG_ConfigurationRequest_contents (c_CONN_MRUP_INCFG_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Multicarrier_Route_Update_Protocol_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_CONN_MRUP_INCFG_ConfigurationResponse_contents_data01 */
void FREE_c_CONN_MRUP_INCFG_ConfigurationResponse_contents_data01 (c_CONN_MRUP_INCFG_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Multicarrier_Route_Update_Protocol_Attributes_Response (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_CONN_MRUP_INCFG_ConfigurationResponse_contents */
void FREE_c_CONN_MRUP_INCFG_ConfigurationResponse_contents (c_CONN_MRUP_INCFG_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Multicarrier_Route_Update_Protocol_Attributes_Response (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_CONN_MRUP_INUSE_RouteUpdate_contents_data01 */
void FREE_c_CONN_MRUP_INUSE_RouteUpdate_contents_data01 (c_CONN_MRUP_INUSE_RouteUpdate_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->Channel_Present) {
			EDFree (sp->data[i]->Channel);
			sp->data[i]->Channel = NULL;
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_CONN_MRUP_INUSE_RouteUpdate_contents */
void FREE_c_CONN_MRUP_INUSE_RouteUpdate_contents (c_CONN_MRUP_INUSE_RouteUpdate_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->Channel_Present) {
			EDFree (sp->data01.data[i0]->Channel);
			sp->data01.data[i0]->Channel = NULL;
		}
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}
	if (sp->ReferencePilotChannel_Present) {
		EDFree (sp->ReferencePilotChannel);
		sp->ReferencePilotChannel = NULL;
		sp->ReferencePilotChannel_Present = ED_FALSE;
	}

}

void SETPRESENT_c_CONN_MRUP_INUSE_RouteUpdate_contents_ReferencePilotChannel (c_CONN_MRUP_INUSE_RouteUpdate_contents* sp, ED_BOOLEAN present)
{
	/* Do nothing if already compliant to the request */
	if (sp->ReferencePilotChannel_Present == present) return;
	sp->ReferencePilotChannel_Present = present;
	if (present) {
		/*-->*/sp->ReferencePilotChannel = (c_CONN_MRUP_INUSE_RouteUpdate_contents_ReferencePilotChannel*)EDAlloc (sizeof (c_CONN_MRUP_INUSE_RouteUpdate_contents_ReferencePilotChannel));
		ED_RESET_MEM (sp->ReferencePilotChannel, sizeof (c_CONN_MRUP_INUSE_RouteUpdate_contents_ReferencePilotChannel));
		(sp->ReferencePilotChannel->SystemType) = 0;
		(sp->ReferencePilotChannel->BandClass) = 0;
		(sp->ReferencePilotChannel->ChannelNumber) = 0;
	} else {
		EDFree (sp->ReferencePilotChannel);
		sp->ReferencePilotChannel = NULL;
	}
}

/* Free function for variable-sized sequence c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data01 */
void FREE_c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data01 (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data02 */
void FREE_c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data02 (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data02* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data04 */
void FREE_c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data04 (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data04* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->AssignedChannel_Present) {
			EDFree (sp->data[i]->AssignedChannel);
			sp->data[i]->AssignedChannel = NULL;
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data05 */
void FREE_c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data05 (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data05* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->ReverseBandClass_Present) {
		}
		if (sp->data[i]->ReverseChannelNumber_Present) {
		}
		if (sp->data[i]->ReverseChannelDroppingRank_Present) {
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data_data07 */
void FREE_c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data_data07 (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data_data07* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->ForwardTrafficMACIndex_Present) {
		}
		if (sp->data[i]->AssignedInterlaces_Present) {
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data_data08 */
void FREE_c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data_data08 (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data_data08* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->ReverseLinkMACIndex_Present) {
		}
		if (sp->data[i]->RABMACIndex_Present) {
		}
		if (sp->data[i]->DeltaT2P_Present) {
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06 */
void FREE_c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06 (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06* sp) {
	int i, i0;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->ForwardChannelIndexThisPilot_Present) {
		}
		if (sp->data[i]->PilotGroupID_Present) {
		}
		if (sp->data[i]->NumUniqueForwardTrafficMACIndices_Present) {
		}
		if (sp->data[i]->SchedulerTag_Present) {
		}
		if (sp->data[i]->AuxDRCCoverIncluded_Present) {
		}
		if (sp->data[i]->AuxDRCCover_Present) {
		}
		if (sp->data[i]->ForwardTrafficMACIndexPerInterlaceEnabled_Present) {
		}
		for (i0=0; i0<sp->data[i]->data07.items; i0++) {
			if (sp->data[i]->data07.data[i0]->ForwardTrafficMACIndex_Present) {
			}
			if (sp->data[i]->data07.data[i0]->AssignedInterlaces_Present) {
			}
			EDFree (sp->data[i]->data07.data[i0]);
			sp->data[i]->data07.data[i0] = NULL;
		}
		if (sp->data[i]->data07.data) {EDFree (sp->data[i]->data07.data); sp->data[i]->data07.data = NULL; sp->data[i]->data07.allocatedItems=0; /*FR02A*/}
		for (i0=0; i0<sp->data[i]->data08.items; i0++) {
			if (sp->data[i]->data08.data[i0]->ReverseLinkMACIndex_Present) {
			}
			if (sp->data[i]->data08.data[i0]->RABMACIndex_Present) {
			}
			if (sp->data[i]->data08.data[i0]->DeltaT2P_Present) {
			}
			EDFree (sp->data[i]->data08.data[i0]);
			sp->data[i]->data08.data[i0] = NULL;
		}
		if (sp->data[i]->data08.data) {EDFree (sp->data[i]->data08.data); sp->data[i]->data08.data = NULL; sp->data[i]->data08.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03 */
void FREE_c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03 (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03* sp) {
	int i, i0, i1;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->NumFwdChannelsThisSubActiveSet_Present) {
		}
		for (i0=0; i0<sp->data[i]->data04.items; i0++) {
			if (sp->data[i]->data04.data[i0]->AssignedChannel_Present) {
				EDFree (sp->data[i]->data04.data[i0]->AssignedChannel);
				sp->data[i]->data04.data[i0]->AssignedChannel = NULL;
			}
			EDFree (sp->data[i]->data04.data[i0]);
			sp->data[i]->data04.data[i0] = NULL;
		}
		if (sp->data[i]->data04.data) {EDFree (sp->data[i]->data04.data); sp->data[i]->data04.data = NULL; sp->data[i]->data04.allocatedItems=0; /*FR02A*/}
		if (sp->data[i]->FeedbackMultiplexingIndex_Present) {
		}
		if (sp->data[i]->FeedbackReverseChannelIndex_Present) {
		}
		if (sp->data[i]->DSCForThisSubActiveSetEnabled_Present) {
		}
		if (sp->data[i]->Next3FieldsSameAsBefore_Present) {
		}
		if (sp->data[i]->DRCLength_Present) {
		}
		if (sp->data[i]->DRCChannelGainBase_Present) {
		}
		if (sp->data[i]->ACKChannelGain_Present) {
		}
		if (sp->data[i]->NumReverseChannels_Present) {
		}
		for (i0=0; i0<sp->data[i]->data05.items; i0++) {
			if (sp->data[i]->data05.data[i0]->ReverseBandClass_Present) {
			}
			if (sp->data[i]->data05.data[i0]->ReverseChannelNumber_Present) {
			}
			if (sp->data[i]->data05.data[i0]->ReverseChannelDroppingRank_Present) {
			}
			EDFree (sp->data[i]->data05.data[i0]);
			sp->data[i]->data05.data[i0] = NULL;
		}
		if (sp->data[i]->data05.data) {EDFree (sp->data[i]->data05.data); sp->data[i]->data05.data = NULL; sp->data[i]->data05.allocatedItems=0; /*FR02A*/}
		for (i0=0; i0<sp->data[i]->data06.items; i0++) {
			if (sp->data[i]->data06.data[i0]->ForwardChannelIndexThisPilot_Present) {
			}
			if (sp->data[i]->data06.data[i0]->PilotGroupID_Present) {
			}
			if (sp->data[i]->data06.data[i0]->NumUniqueForwardTrafficMACIndices_Present) {
			}
			if (sp->data[i]->data06.data[i0]->SchedulerTag_Present) {
			}
			if (sp->data[i]->data06.data[i0]->AuxDRCCoverIncluded_Present) {
			}
			if (sp->data[i]->data06.data[i0]->AuxDRCCover_Present) {
			}
			if (sp->data[i]->data06.data[i0]->ForwardTrafficMACIndexPerInterlaceEnabled_Present) {
			}
			for (i1=0; i1<sp->data[i]->data06.data[i0]->data07.items; i1++) {
				if (sp->data[i]->data06.data[i0]->data07.data[i1]->ForwardTrafficMACIndex_Present) {
				}
				if (sp->data[i]->data06.data[i0]->data07.data[i1]->AssignedInterlaces_Present) {
				}
				EDFree (sp->data[i]->data06.data[i0]->data07.data[i1]);
				sp->data[i]->data06.data[i0]->data07.data[i1] = NULL;
			}
			if (sp->data[i]->data06.data[i0]->data07.data) {EDFree (sp->data[i]->data06.data[i0]->data07.data); sp->data[i]->data06.data[i0]->data07.data = NULL; sp->data[i]->data06.data[i0]->data07.allocatedItems=0; /*FR02A*/}
			for (i1=0; i1<sp->data[i]->data06.data[i0]->data08.items; i1++) {
				if (sp->data[i]->data06.data[i0]->data08.data[i1]->ReverseLinkMACIndex_Present) {
				}
				if (sp->data[i]->data06.data[i0]->data08.data[i1]->RABMACIndex_Present) {
				}
				if (sp->data[i]->data06.data[i0]->data08.data[i1]->DeltaT2P_Present) {
				}
				EDFree (sp->data[i]->data06.data[i0]->data08.data[i1]);
				sp->data[i]->data06.data[i0]->data08.data[i1] = NULL;
			}
			if (sp->data[i]->data06.data[i0]->data08.data) {EDFree (sp->data[i]->data06.data[i0]->data08.data); sp->data[i]->data06.data[i0]->data08.data = NULL; sp->data[i]->data06.data[i0]->data08.allocatedItems=0; /*FR02A*/}
			EDFree (sp->data[i]->data06.data[i0]);
			sp->data[i]->data06.data[i0] = NULL;
		}
		if (sp->data[i]->data06.data) {EDFree (sp->data[i]->data06.data); sp->data[i]->data06.data = NULL; sp->data[i]->data06.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents */
void FREE_c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents* sp) {
	int i0;
	int i1;
	int i2;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data02.items; i0++) {
		EDFree (sp->data02.data[i0]);
		sp->data02.data[i0] = NULL;
	}
	if (sp->data02.data) {EDFree (sp->data02.data); sp->data02.data = NULL; sp->data02.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data03.items; i0++) {
		if (sp->data03.data[i0]->NumFwdChannelsThisSubActiveSet_Present) {
		}
		for (i1=0; i1<sp->data03.data[i0]->data04.items; i1++) {
			if (sp->data03.data[i0]->data04.data[i1]->AssignedChannel_Present) {
				EDFree (sp->data03.data[i0]->data04.data[i1]->AssignedChannel);
				sp->data03.data[i0]->data04.data[i1]->AssignedChannel = NULL;
			}
			EDFree (sp->data03.data[i0]->data04.data[i1]);
			sp->data03.data[i0]->data04.data[i1] = NULL;
		}
		if (sp->data03.data[i0]->data04.data) {EDFree (sp->data03.data[i0]->data04.data); sp->data03.data[i0]->data04.data = NULL; sp->data03.data[i0]->data04.allocatedItems=0; /*FR02A*/}
		if (sp->data03.data[i0]->FeedbackMultiplexingIndex_Present) {
		}
		if (sp->data03.data[i0]->FeedbackReverseChannelIndex_Present) {
		}
		if (sp->data03.data[i0]->DSCForThisSubActiveSetEnabled_Present) {
		}
		if (sp->data03.data[i0]->Next3FieldsSameAsBefore_Present) {
		}
		if (sp->data03.data[i0]->DRCLength_Present) {
		}
		if (sp->data03.data[i0]->DRCChannelGainBase_Present) {
		}
		if (sp->data03.data[i0]->ACKChannelGain_Present) {
		}
		if (sp->data03.data[i0]->NumReverseChannels_Present) {
		}
		for (i1=0; i1<sp->data03.data[i0]->data05.items; i1++) {
			if (sp->data03.data[i0]->data05.data[i1]->ReverseBandClass_Present) {
			}
			if (sp->data03.data[i0]->data05.data[i1]->ReverseChannelNumber_Present) {
			}
			if (sp->data03.data[i0]->data05.data[i1]->ReverseChannelDroppingRank_Present) {
			}
			EDFree (sp->data03.data[i0]->data05.data[i1]);
			sp->data03.data[i0]->data05.data[i1] = NULL;
		}
		if (sp->data03.data[i0]->data05.data) {EDFree (sp->data03.data[i0]->data05.data); sp->data03.data[i0]->data05.data = NULL; sp->data03.data[i0]->data05.allocatedItems=0; /*FR02A*/}
		for (i1=0; i1<sp->data03.data[i0]->data06.items; i1++) {
			if (sp->data03.data[i0]->data06.data[i1]->ForwardChannelIndexThisPilot_Present) {
			}
			if (sp->data03.data[i0]->data06.data[i1]->PilotGroupID_Present) {
			}
			if (sp->data03.data[i0]->data06.data[i1]->NumUniqueForwardTrafficMACIndices_Present) {
			}
			if (sp->data03.data[i0]->data06.data[i1]->SchedulerTag_Present) {
			}
			if (sp->data03.data[i0]->data06.data[i1]->AuxDRCCoverIncluded_Present) {
			}
			if (sp->data03.data[i0]->data06.data[i1]->AuxDRCCover_Present) {
			}
			if (sp->data03.data[i0]->data06.data[i1]->ForwardTrafficMACIndexPerInterlaceEnabled_Present) {
			}
			for (i2=0; i2<sp->data03.data[i0]->data06.data[i1]->data07.items; i2++) {
				if (sp->data03.data[i0]->data06.data[i1]->data07.data[i2]->ForwardTrafficMACIndex_Present) {
				}
				if (sp->data03.data[i0]->data06.data[i1]->data07.data[i2]->AssignedInterlaces_Present) {
				}
				EDFree (sp->data03.data[i0]->data06.data[i1]->data07.data[i2]);
				sp->data03.data[i0]->data06.data[i1]->data07.data[i2] = NULL;
			}
			if (sp->data03.data[i0]->data06.data[i1]->data07.data) {EDFree (sp->data03.data[i0]->data06.data[i1]->data07.data); sp->data03.data[i0]->data06.data[i1]->data07.data = NULL; sp->data03.data[i0]->data06.data[i1]->data07.allocatedItems=0; /*FR02A*/}
			for (i2=0; i2<sp->data03.data[i0]->data06.data[i1]->data08.items; i2++) {
				if (sp->data03.data[i0]->data06.data[i1]->data08.data[i2]->ReverseLinkMACIndex_Present) {
				}
				if (sp->data03.data[i0]->data06.data[i1]->data08.data[i2]->RABMACIndex_Present) {
				}
				if (sp->data03.data[i0]->data06.data[i1]->data08.data[i2]->DeltaT2P_Present) {
				}
				EDFree (sp->data03.data[i0]->data06.data[i1]->data08.data[i2]);
				sp->data03.data[i0]->data06.data[i1]->data08.data[i2] = NULL;
			}
			if (sp->data03.data[i0]->data06.data[i1]->data08.data) {EDFree (sp->data03.data[i0]->data06.data[i1]->data08.data); sp->data03.data[i0]->data06.data[i1]->data08.data = NULL; sp->data03.data[i0]->data06.data[i1]->data08.allocatedItems=0; /*FR02A*/}
			EDFree (sp->data03.data[i0]->data06.data[i1]);
			sp->data03.data[i0]->data06.data[i1] = NULL;
		}
		if (sp->data03.data[i0]->data06.data) {EDFree (sp->data03.data[i0]->data06.data); sp->data03.data[i0]->data06.data = NULL; sp->data03.data[i0]->data06.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data03.data[i0]);
		sp->data03.data[i0] = NULL;
	}
	if (sp->data03.data) {EDFree (sp->data03.data); sp->data03.data = NULL; sp->data03.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_CONN_MRUP_INUSE_TrafficChannelComplete_contents */
void FREE_c_CONN_MRUP_INUSE_TrafficChannelComplete_contents (c_CONN_MRUP_INUSE_TrafficChannelComplete_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_CONN_MRUP_INUSE_NeighborList_contents_data01 */
void FREE_c_CONN_MRUP_INUSE_NeighborList_contents_data01 (c_CONN_MRUP_INUSE_NeighborList_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_CONN_MRUP_INUSE_NeighborList_contents_data02 */
void FREE_c_CONN_MRUP_INUSE_NeighborList_contents_data02 (c_CONN_MRUP_INUSE_NeighborList_contents_data02* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->Channel_Present) {
			EDFree (sp->data[i]->Channel);
			sp->data[i]->Channel = NULL;
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_CONN_MRUP_INUSE_NeighborList_contents_data03 */
void FREE_c_CONN_MRUP_INUSE_NeighborList_contents_data03 (c_CONN_MRUP_INUSE_NeighborList_contents_data03* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->SearchWindowSize_Present) {
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_CONN_MRUP_INUSE_NeighborList_contents_data04 */
void FREE_c_CONN_MRUP_INUSE_NeighborList_contents_data04 (c_CONN_MRUP_INUSE_NeighborList_contents_data04* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->SearchWindowOffset_Present) {
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_CONN_MRUP_INUSE_NeighborList_contents_data05 */
void FREE_c_CONN_MRUP_INUSE_NeighborList_contents_data05 (c_CONN_MRUP_INUSE_NeighborList_contents_data05* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->FPDCHSupported_Present) {
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_CONN_MRUP_INUSE_NeighborList_contents_data06 */
void FREE_c_CONN_MRUP_INUSE_NeighborList_contents_data06 (c_CONN_MRUP_INUSE_NeighborList_contents_data06* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->PilotGroupID_Present) {
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_CONN_MRUP_INUSE_NeighborList_contents */
void FREE_c_CONN_MRUP_INUSE_NeighborList_contents (c_CONN_MRUP_INUSE_NeighborList_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data02.items; i0++) {
		if (sp->data02.data[i0]->Channel_Present) {
			EDFree (sp->data02.data[i0]->Channel);
			sp->data02.data[i0]->Channel = NULL;
		}
		EDFree (sp->data02.data[i0]);
		sp->data02.data[i0] = NULL;
	}
	if (sp->data02.data) {EDFree (sp->data02.data); sp->data02.data = NULL; sp->data02.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data03.items; i0++) {
		if (sp->data03.data[i0]->SearchWindowSize_Present) {
		}
		EDFree (sp->data03.data[i0]);
		sp->data03.data[i0] = NULL;
	}
	if (sp->data03.data) {EDFree (sp->data03.data); sp->data03.data = NULL; sp->data03.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data04.items; i0++) {
		if (sp->data04.data[i0]->SearchWindowOffset_Present) {
		}
		EDFree (sp->data04.data[i0]);
		sp->data04.data[i0] = NULL;
	}
	if (sp->data04.data) {EDFree (sp->data04.data); sp->data04.data = NULL; sp->data04.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data05.items; i0++) {
		if (sp->data05.data[i0]->FPDCHSupported_Present) {
		}
		EDFree (sp->data05.data[i0]);
		sp->data05.data[i0] = NULL;
	}
	if (sp->data05.data) {EDFree (sp->data05.data); sp->data05.data = NULL; sp->data05.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data06.items; i0++) {
		if (sp->data06.data[i0]->PilotGroupID_Present) {
		}
		EDFree (sp->data06.data[i0]);
		sp->data06.data[i0] = NULL;
	}
	if (sp->data06.data) {EDFree (sp->data06.data); sp->data06.data = NULL; sp->data06.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data01 */
void FREE_c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data01 (c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data02 */
void FREE_c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data02 (c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data02* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->SectorSearchWindowSize_Present) {
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data03 */
void FREE_c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data03 (c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data03* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->SectorSearchWindowOffset_Present) {
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_CONN_MRUP_INUSE_RouteUpdateRequest_contents */
void FREE_c_CONN_MRUP_INUSE_RouteUpdateRequest_contents (c_CONN_MRUP_INUSE_RouteUpdateRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	if (sp->Channel_Present) {
		EDFree (sp->Channel);
		sp->Channel = NULL;
		sp->Channel_Present = ED_FALSE;
	}
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data02.items; i0++) {
		if (sp->data02.data[i0]->SectorSearchWindowSize_Present) {
		}
		EDFree (sp->data02.data[i0]);
		sp->data02.data[i0] = NULL;
	}
	if (sp->data02.data) {EDFree (sp->data02.data); sp->data02.data = NULL; sp->data02.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data03.items; i0++) {
		if (sp->data03.data[i0]->SectorSearchWindowOffset_Present) {
		}
		EDFree (sp->data03.data[i0]);
		sp->data03.data[i0] = NULL;
	}
	if (sp->data03.data) {EDFree (sp->data03.data); sp->data03.data = NULL; sp->data03.allocatedItems=0; /*FR02A*/}

}

void SETPRESENT_c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_Channel (c_CONN_MRUP_INUSE_RouteUpdateRequest_contents* sp, ED_BOOLEAN present)
{
	/* Do nothing if already compliant to the request */
	if (sp->Channel_Present == present) return;
	sp->Channel_Present = present;
	if (present) {
		/*-->*/sp->Channel = (c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_Channel*)EDAlloc (sizeof (c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_Channel));
		ED_RESET_MEM (sp->Channel, sizeof (c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_Channel));
		(sp->Channel->SystemType) = 0;
		(sp->Channel->BandClass) = 0;
		(sp->Channel->ChannelNumber) = 0;
	} else {
		EDFree (sp->Channel);
		sp->Channel = NULL;
	}
}

/* Free function for variable-sized sequence c_CONN_MRUP_INUSE_AttributeUpdateRequest_contents_data01 */
void FREE_c_CONN_MRUP_INUSE_AttributeUpdateRequest_contents_data01 (c_CONN_MRUP_INUSE_AttributeUpdateRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Multicarrier_Route_Update_Protocol_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_CONN_MRUP_INUSE_AttributeUpdateRequest_contents */
void FREE_c_CONN_MRUP_INUSE_AttributeUpdateRequest_contents (c_CONN_MRUP_INUSE_AttributeUpdateRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Multicarrier_Route_Update_Protocol_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_CONN_MRUP_INUSE_AttributeUpdateAccept_contents */
void FREE_c_CONN_MRUP_INUSE_AttributeUpdateAccept_contents (c_CONN_MRUP_INUSE_AttributeUpdateAccept_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_CONN_MRUP_INUSE_AttributeUpdateReject_contents */
void FREE_c_CONN_MRUP_INUSE_AttributeUpdateReject_contents (c_CONN_MRUP_INUSE_AttributeUpdateReject_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_CONN_DPCP_INCFG_ConfigurationRequest_contents_data01 */
void FREE_c_CONN_DPCP_INCFG_ConfigurationRequest_contents_data01 (c_CONN_DPCP_INCFG_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data[i]->AttributeRecord.AttributeValue.value);
			sp->data[i]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_CONN_DPCP_INCFG_ConfigurationRequest_contents */
void FREE_c_CONN_DPCP_INCFG_ConfigurationRequest_contents (c_CONN_DPCP_INCFG_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data01.data[i0]->AttributeRecord.AttributeValue.value);
			sp->data01.data[i0]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data01.data[i0]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_CONN_DPCP_INCFG_ConfigurationResponse_contents_data01 */
void FREE_c_CONN_DPCP_INCFG_ConfigurationResponse_contents_data01 (c_CONN_DPCP_INCFG_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data[i]->AttributeRecord.AttributeValue.value);
			sp->data[i]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_CONN_DPCP_INCFG_ConfigurationResponse_contents */
void FREE_c_CONN_DPCP_INCFG_ConfigurationResponse_contents (c_CONN_DPCP_INCFG_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data01.data[i0]->AttributeRecord.AttributeValue.value);
			sp->data01.data[i0]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data01.data[i0]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_CONN_OMP_INCFG_ConfigurationRequest_contents_data01 */
void FREE_c_CONN_OMP_INCFG_ConfigurationRequest_contents_data01 (c_CONN_OMP_INCFG_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Overhead_Messages_Protocol_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_CONN_OMP_INCFG_ConfigurationRequest_contents */
void FREE_c_CONN_OMP_INCFG_ConfigurationRequest_contents (c_CONN_OMP_INCFG_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Overhead_Messages_Protocol_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_CONN_OMP_INCFG_ConfigurationResponse_contents_data01 */
void FREE_c_CONN_OMP_INCFG_ConfigurationResponse_contents_data01 (c_CONN_OMP_INCFG_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Overhead_Messages_Protocol_Attributes_Response (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_CONN_OMP_INCFG_ConfigurationResponse_contents */
void FREE_c_CONN_OMP_INCFG_ConfigurationResponse_contents (c_CONN_OMP_INCFG_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Overhead_Messages_Protocol_Attributes_Response (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_CONN_OMP_INUSE_QuickConfig_contents_data01 */
void FREE_c_CONN_OMP_INUSE_QuickConfig_contents_data01 (c_CONN_OMP_INUSE_QuickConfig_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_CONN_OMP_INUSE_QuickConfig_contents_data02 */
void FREE_c_CONN_OMP_INUSE_QuickConfig_contents_data02 (c_CONN_OMP_INUSE_QuickConfig_contents_data02* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->ForwardTrafficValid127To64_Present) {
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_CONN_OMP_INUSE_QuickConfig_contents_data03 */
void FREE_c_CONN_OMP_INUSE_QuickConfig_contents_data03 (c_CONN_OMP_INUSE_QuickConfig_contents_data03* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->ForwardTrafficValid130To383_Present) {
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_CONN_OMP_INUSE_QuickConfig_contents */
void FREE_c_CONN_OMP_INUSE_QuickConfig_contents (c_CONN_OMP_INUSE_QuickConfig_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data02.items; i0++) {
		if (sp->data02.data[i0]->ForwardTrafficValid127To64_Present) {
		}
		EDFree (sp->data02.data[i0]);
		sp->data02.data[i0] = NULL;
	}
	if (sp->data02.data) {EDFree (sp->data02.data); sp->data02.data = NULL; sp->data02.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data03.items; i0++) {
		if (sp->data03.data[i0]->ForwardTrafficValid130To383_Present) {
		}
		EDFree (sp->data03.data[i0]);
		sp->data03.data[i0] = NULL;
	}
	if (sp->data03.data) {EDFree (sp->data03.data); sp->data03.data = NULL; sp->data03.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_CONN_OMP_INUSE_SectorParameters_contents_data01 */
void FREE_c_CONN_OMP_INUSE_SectorParameters_contents_data01 (c_CONN_OMP_INUSE_SectorParameters_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_CONN_OMP_INUSE_SectorParameters_contents_data02 */
void FREE_c_CONN_OMP_INUSE_SectorParameters_contents_data02 (c_CONN_OMP_INUSE_SectorParameters_contents_data02* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_CONN_OMP_INUSE_SectorParameters_contents_data03 */
void FREE_c_CONN_OMP_INUSE_SectorParameters_contents_data03 (c_CONN_OMP_INUSE_SectorParameters_contents_data03* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->NeighborChannel_Present) {
			EDFree (sp->data[i]->NeighborChannel);
			sp->data[i]->NeighborChannel = NULL;
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_CONN_OMP_INUSE_SectorParameters_contents_data04 */
void FREE_c_CONN_OMP_INUSE_SectorParameters_contents_data04 (c_CONN_OMP_INUSE_SectorParameters_contents_data04* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->NeighborSearchWindowSize_Present) {
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_CONN_OMP_INUSE_SectorParameters_contents_data05 */
void FREE_c_CONN_OMP_INUSE_SectorParameters_contents_data05 (c_CONN_OMP_INUSE_SectorParameters_contents_data05* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->NeighborSearchWindowOffset_Present) {
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_CONN_OMP_INUSE_SectorParameters_contents_data06 */
void FREE_c_CONN_OMP_INUSE_SectorParameters_contents_data06 (c_CONN_OMP_INUSE_SectorParameters_contents_data06* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_CONN_OMP_INUSE_SectorParameters_contents_data07 */
void FREE_c_CONN_OMP_INUSE_SectorParameters_contents_data07 (c_CONN_OMP_INUSE_SectorParameters_contents_data07* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->AccessHashingChannelMask.value != NULL) {
			EDFree (sp->data[i]->AccessHashingChannelMask.value);
			sp->data[i]->AccessHashingChannelMask.value = NULL;
		}
		sp->data[i]->AccessHashingChannelMask.usedBits = 0;
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_CONN_OMP_INUSE_SectorParameters_contents_data08 */
void FREE_c_CONN_OMP_INUSE_SectorParameters_contents_data08 (c_CONN_OMP_INUSE_SectorParameters_contents_data08* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->FPDCHSupported_Present) {
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_CONN_OMP_INUSE_SectorParameters_contents_data09 */
void FREE_c_CONN_OMP_INUSE_SectorParameters_contents_data09 (c_CONN_OMP_INUSE_SectorParameters_contents_data09* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_CONN_OMP_INUSE_SectorParameters_contents_data10 */
void FREE_c_CONN_OMP_INUSE_SectorParameters_contents_data10 (c_CONN_OMP_INUSE_SectorParameters_contents_data10* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->PilotGroupIDIncluded_Present) {
		}
		if (sp->data[i]->PilotGroupID_Present) {
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_CONN_OMP_INUSE_SectorParameters_contents_data11 */
void FREE_c_CONN_OMP_INUSE_SectorParameters_contents_data11 (c_CONN_OMP_INUSE_SectorParameters_contents_data11* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->ReverseBandClass_Present) {
		}
		if (sp->data[i]->ReverseChannelNumber_Present) {
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_CONN_OMP_INUSE_SectorParameters_contents */
void FREE_c_CONN_OMP_INUSE_SectorParameters_contents (c_CONN_OMP_INUSE_SectorParameters_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data02.items; i0++) {
		EDFree (sp->data02.data[i0]);
		sp->data02.data[i0] = NULL;
	}
	if (sp->data02.data) {EDFree (sp->data02.data); sp->data02.data = NULL; sp->data02.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data03.items; i0++) {
		if (sp->data03.data[i0]->NeighborChannel_Present) {
			EDFree (sp->data03.data[i0]->NeighborChannel);
			sp->data03.data[i0]->NeighborChannel = NULL;
		}
		EDFree (sp->data03.data[i0]);
		sp->data03.data[i0] = NULL;
	}
	if (sp->data03.data) {EDFree (sp->data03.data); sp->data03.data = NULL; sp->data03.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data04.items; i0++) {
		if (sp->data04.data[i0]->NeighborSearchWindowSize_Present) {
		}
		EDFree (sp->data04.data[i0]);
		sp->data04.data[i0] = NULL;
	}
	if (sp->data04.data) {EDFree (sp->data04.data); sp->data04.data = NULL; sp->data04.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data05.items; i0++) {
		if (sp->data05.data[i0]->NeighborSearchWindowOffset_Present) {
		}
		EDFree (sp->data05.data[i0]);
		sp->data05.data[i0] = NULL;
	}
	if (sp->data05.data) {EDFree (sp->data05.data); sp->data05.data = NULL; sp->data05.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data06.items; i0++) {
		EDFree (sp->data06.data[i0]);
		sp->data06.data[i0] = NULL;
	}
	if (sp->data06.data) {EDFree (sp->data06.data); sp->data06.data = NULL; sp->data06.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data07.items; i0++) {
		if (sp->data07.data[i0]->AccessHashingChannelMask.value != NULL) {
			EDFree (sp->data07.data[i0]->AccessHashingChannelMask.value);
			sp->data07.data[i0]->AccessHashingChannelMask.value = NULL;
		}
		sp->data07.data[i0]->AccessHashingChannelMask.usedBits = 0;
		EDFree (sp->data07.data[i0]);
		sp->data07.data[i0] = NULL;
	}
	if (sp->data07.data) {EDFree (sp->data07.data); sp->data07.data = NULL; sp->data07.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data08.items; i0++) {
		if (sp->data08.data[i0]->FPDCHSupported_Present) {
		}
		EDFree (sp->data08.data[i0]);
		sp->data08.data[i0] = NULL;
	}
	if (sp->data08.data) {EDFree (sp->data08.data); sp->data08.data = NULL; sp->data08.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data09.items; i0++) {
		EDFree (sp->data09.data[i0]);
		sp->data09.data[i0] = NULL;
	}
	if (sp->data09.data) {EDFree (sp->data09.data); sp->data09.data = NULL; sp->data09.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data10.items; i0++) {
		if (sp->data10.data[i0]->PilotGroupIDIncluded_Present) {
		}
		if (sp->data10.data[i0]->PilotGroupID_Present) {
		}
		EDFree (sp->data10.data[i0]);
		sp->data10.data[i0] = NULL;
	}
	if (sp->data10.data) {EDFree (sp->data10.data); sp->data10.data = NULL; sp->data10.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data11.items; i0++) {
		if (sp->data11.data[i0]->ReverseBandClass_Present) {
		}
		if (sp->data11.data[i0]->ReverseChannelNumber_Present) {
		}
		EDFree (sp->data11.data[i0]);
		sp->data11.data[i0] = NULL;
	}
	if (sp->data11.data) {EDFree (sp->data11.data); sp->data11.data = NULL; sp->data11.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_SECURITY_DSP_INCFG_ConfigurationRequest_contents_data01 */
void FREE_c_SECURITY_DSP_INCFG_ConfigurationRequest_contents_data01 (c_SECURITY_DSP_INCFG_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data[i]->AttributeRecord.AttributeValue.value);
			sp->data[i]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_SECURITY_DSP_INCFG_ConfigurationRequest_contents */
void FREE_c_SECURITY_DSP_INCFG_ConfigurationRequest_contents (c_SECURITY_DSP_INCFG_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data01.data[i0]->AttributeRecord.AttributeValue.value);
			sp->data01.data[i0]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data01.data[i0]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_SECURITY_DSP_INCFG_ConfigurationResponse_contents_data01 */
void FREE_c_SECURITY_DSP_INCFG_ConfigurationResponse_contents_data01 (c_SECURITY_DSP_INCFG_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data[i]->AttributeRecord.AttributeValue.value);
			sp->data[i]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_SECURITY_DSP_INCFG_ConfigurationResponse_contents */
void FREE_c_SECURITY_DSP_INCFG_ConfigurationResponse_contents (c_SECURITY_DSP_INCFG_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data01.data[i0]->AttributeRecord.AttributeValue.value);
			sp->data01.data[i0]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data01.data[i0]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_SECURITY_GSP_INCFG_ConfigurationRequest_contents_data01 */
void FREE_c_SECURITY_GSP_INCFG_ConfigurationRequest_contents_data01 (c_SECURITY_GSP_INCFG_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data[i]->AttributeRecord.AttributeValue.value);
			sp->data[i]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_SECURITY_GSP_INCFG_ConfigurationRequest_contents */
void FREE_c_SECURITY_GSP_INCFG_ConfigurationRequest_contents (c_SECURITY_GSP_INCFG_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data01.data[i0]->AttributeRecord.AttributeValue.value);
			sp->data01.data[i0]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data01.data[i0]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_SECURITY_GSP_INCFG_ConfigurationResponse_contents_data01 */
void FREE_c_SECURITY_GSP_INCFG_ConfigurationResponse_contents_data01 (c_SECURITY_GSP_INCFG_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data[i]->AttributeRecord.AttributeValue.value);
			sp->data[i]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_SECURITY_GSP_INCFG_ConfigurationResponse_contents */
void FREE_c_SECURITY_GSP_INCFG_ConfigurationResponse_contents (c_SECURITY_GSP_INCFG_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data01.data[i0]->AttributeRecord.AttributeValue.value);
			sp->data01.data[i0]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data01.data[i0]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_SECURITY_DKEP_INCFG_ConfigurationRequest_contents_data01 */
void FREE_c_SECURITY_DKEP_INCFG_ConfigurationRequest_contents_data01 (c_SECURITY_DKEP_INCFG_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data[i]->AttributeRecord.AttributeValue.value);
			sp->data[i]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_SECURITY_DKEP_INCFG_ConfigurationRequest_contents */
void FREE_c_SECURITY_DKEP_INCFG_ConfigurationRequest_contents (c_SECURITY_DKEP_INCFG_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data01.data[i0]->AttributeRecord.AttributeValue.value);
			sp->data01.data[i0]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data01.data[i0]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_SECURITY_DKEP_INCFG_ConfigurationResponse_contents_data01 */
void FREE_c_SECURITY_DKEP_INCFG_ConfigurationResponse_contents_data01 (c_SECURITY_DKEP_INCFG_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data[i]->AttributeRecord.AttributeValue.value);
			sp->data[i]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_SECURITY_DKEP_INCFG_ConfigurationResponse_contents */
void FREE_c_SECURITY_DKEP_INCFG_ConfigurationResponse_contents (c_SECURITY_DKEP_INCFG_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data01.data[i0]->AttributeRecord.AttributeValue.value);
			sp->data01.data[i0]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data01.data[i0]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_SECURITY_DHKEP_INCFG_KeyRequest_contents */
void FREE_c_SECURITY_DHKEP_INCFG_KeyRequest_contents (c_SECURITY_DHKEP_INCFG_KeyRequest_contents* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->ANPubKey.value != NULL) {
		EDFree (sp->ANPubKey.value);
		sp->ANPubKey.value = NULL;
	}
	sp->ANPubKey.usedBits = 0;

}

/* Free function for struct c_SECURITY_DHKEP_INCFG_KeyResponse_contents */
void FREE_c_SECURITY_DHKEP_INCFG_KeyResponse_contents (c_SECURITY_DHKEP_INCFG_KeyResponse_contents* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->ATPubKey.value != NULL) {
		EDFree (sp->ATPubKey.value);
		sp->ATPubKey.value = NULL;
	}
	sp->ATPubKey.usedBits = 0;

}

/* Free function for struct c_SECURITY_DHKEP_INCFG_ANKeyComplete_contents */
void FREE_c_SECURITY_DHKEP_INCFG_ANKeyComplete_contents (c_SECURITY_DHKEP_INCFG_ANKeyComplete_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_SECURITY_DHKEP_INCFG_ATKeyComplete_contents */
void FREE_c_SECURITY_DHKEP_INCFG_ATKeyComplete_contents (c_SECURITY_DHKEP_INCFG_ATKeyComplete_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_SECURITY_DHKEP_INCFG_ConfigurationRequest_contents_data01 */
void FREE_c_SECURITY_DHKEP_INCFG_ConfigurationRequest_contents_data01 (c_SECURITY_DHKEP_INCFG_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_DH_Key_Exchange_Protocol_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_SECURITY_DHKEP_INCFG_ConfigurationRequest_contents */
void FREE_c_SECURITY_DHKEP_INCFG_ConfigurationRequest_contents (c_SECURITY_DHKEP_INCFG_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_DH_Key_Exchange_Protocol_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_SECURITY_DHKEP_INCFG_ConfigurationResponse_contents_data01 */
void FREE_c_SECURITY_DHKEP_INCFG_ConfigurationResponse_contents_data01 (c_SECURITY_DHKEP_INCFG_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_DH_Key_Exchange_Protocol_Attributes_Response (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_SECURITY_DHKEP_INCFG_ConfigurationResponse_contents */
void FREE_c_SECURITY_DHKEP_INCFG_ConfigurationResponse_contents (c_SECURITY_DHKEP_INCFG_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_DH_Key_Exchange_Protocol_Attributes_Response (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_SECURITY_DAP_INCFG_ConfigurationRequest_contents_data01 */
void FREE_c_SECURITY_DAP_INCFG_ConfigurationRequest_contents_data01 (c_SECURITY_DAP_INCFG_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data[i]->AttributeRecord.AttributeValue.value);
			sp->data[i]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_SECURITY_DAP_INCFG_ConfigurationRequest_contents */
void FREE_c_SECURITY_DAP_INCFG_ConfigurationRequest_contents (c_SECURITY_DAP_INCFG_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data01.data[i0]->AttributeRecord.AttributeValue.value);
			sp->data01.data[i0]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data01.data[i0]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_SECURITY_DAP_INCFG_ConfigurationResponse_contents_data01 */
void FREE_c_SECURITY_DAP_INCFG_ConfigurationResponse_contents_data01 (c_SECURITY_DAP_INCFG_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data[i]->AttributeRecord.AttributeValue.value);
			sp->data[i]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_SECURITY_DAP_INCFG_ConfigurationResponse_contents */
void FREE_c_SECURITY_DAP_INCFG_ConfigurationResponse_contents (c_SECURITY_DAP_INCFG_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data01.data[i0]->AttributeRecord.AttributeValue.value);
			sp->data01.data[i0]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data01.data[i0]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_SECURITY_SHA1AP_INCFG_ConfigurationRequest_contents_data01 */
void FREE_c_SECURITY_SHA1AP_INCFG_ConfigurationRequest_contents_data01 (c_SECURITY_SHA1AP_INCFG_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_SHA_1_Authentication_Protocol_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_SECURITY_SHA1AP_INCFG_ConfigurationRequest_contents */
void FREE_c_SECURITY_SHA1AP_INCFG_ConfigurationRequest_contents (c_SECURITY_SHA1AP_INCFG_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_SHA_1_Authentication_Protocol_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_SECURITY_SHA1AP_INCFG_ConfigurationResponse_contents_data01 */
void FREE_c_SECURITY_SHA1AP_INCFG_ConfigurationResponse_contents_data01 (c_SECURITY_SHA1AP_INCFG_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_SHA_1_Authentication_Protocol_Attributes_Response (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_SECURITY_SHA1AP_INCFG_ConfigurationResponse_contents */
void FREE_c_SECURITY_SHA1AP_INCFG_ConfigurationResponse_contents (c_SECURITY_SHA1AP_INCFG_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_SHA_1_Authentication_Protocol_Attributes_Response (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_SECURITY_DEP_INCFG_ConfigurationRequest_contents_data01 */
void FREE_c_SECURITY_DEP_INCFG_ConfigurationRequest_contents_data01 (c_SECURITY_DEP_INCFG_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data[i]->AttributeRecord.AttributeValue.value);
			sp->data[i]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_SECURITY_DEP_INCFG_ConfigurationRequest_contents */
void FREE_c_SECURITY_DEP_INCFG_ConfigurationRequest_contents (c_SECURITY_DEP_INCFG_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data01.data[i0]->AttributeRecord.AttributeValue.value);
			sp->data01.data[i0]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data01.data[i0]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_SECURITY_DEP_INCFG_ConfigurationResponse_contents_data01 */
void FREE_c_SECURITY_DEP_INCFG_ConfigurationResponse_contents_data01 (c_SECURITY_DEP_INCFG_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data[i]->AttributeRecord.AttributeValue.value);
			sp->data[i]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_SECURITY_DEP_INCFG_ConfigurationResponse_contents */
void FREE_c_SECURITY_DEP_INCFG_ConfigurationResponse_contents (c_SECURITY_DEP_INCFG_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data01.data[i0]->AttributeRecord.AttributeValue.value);
			sp->data01.data[i0]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data01.data[i0]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_MAC_DCCMACP_INCFG_ConfigurationRequest_contents_data01 */
void FREE_c_MAC_DCCMACP_INCFG_ConfigurationRequest_contents_data01 (c_MAC_DCCMACP_INCFG_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data[i]->AttributeRecord.AttributeValue.value);
			sp->data[i]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MAC_DCCMACP_INCFG_ConfigurationRequest_contents */
void FREE_c_MAC_DCCMACP_INCFG_ConfigurationRequest_contents (c_MAC_DCCMACP_INCFG_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data01.data[i0]->AttributeRecord.AttributeValue.value);
			sp->data01.data[i0]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data01.data[i0]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_MAC_DCCMACP_INCFG_ConfigurationResponse_contents_data01 */
void FREE_c_MAC_DCCMACP_INCFG_ConfigurationResponse_contents_data01 (c_MAC_DCCMACP_INCFG_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data[i]->AttributeRecord.AttributeValue.value);
			sp->data[i]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MAC_DCCMACP_INCFG_ConfigurationResponse_contents */
void FREE_c_MAC_DCCMACP_INCFG_ConfigurationResponse_contents (c_MAC_DCCMACP_INCFG_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data01.data[i0]->AttributeRecord.AttributeValue.value);
			sp->data01.data[i0]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data01.data[i0]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_MAC_ECCMACP_INCFG_ConfigurationRequest_contents_data01 */
void FREE_c_MAC_ECCMACP_INCFG_ConfigurationRequest_contents_data01 (c_MAC_ECCMACP_INCFG_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Enhanced_Control_Channel_MAC_Protocol_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MAC_ECCMACP_INCFG_ConfigurationRequest_contents */
void FREE_c_MAC_ECCMACP_INCFG_ConfigurationRequest_contents (c_MAC_ECCMACP_INCFG_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Enhanced_Control_Channel_MAC_Protocol_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_MAC_ECCMACP_INCFG_ConfigurationResponse_contents_data01 */
void FREE_c_MAC_ECCMACP_INCFG_ConfigurationResponse_contents_data01 (c_MAC_ECCMACP_INCFG_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Enhanced_Control_Channel_MAC_Protocol_Attributes_Response (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MAC_ECCMACP_INCFG_ConfigurationResponse_contents */
void FREE_c_MAC_ECCMACP_INCFG_ConfigurationResponse_contents (c_MAC_ECCMACP_INCFG_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Enhanced_Control_Channel_MAC_Protocol_Attributes_Response (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_MAC_DACMACP_INCFG_ConfigurationRequest_contents_data01 */
void FREE_c_MAC_DACMACP_INCFG_ConfigurationRequest_contents_data01 (c_MAC_DACMACP_INCFG_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Default_Access_Channel_MAC_Protocol_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MAC_DACMACP_INCFG_ConfigurationRequest_contents */
void FREE_c_MAC_DACMACP_INCFG_ConfigurationRequest_contents (c_MAC_DACMACP_INCFG_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Default_Access_Channel_MAC_Protocol_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_MAC_DACMACP_INCFG_ConfigurationResponse_contents_data01 */
void FREE_c_MAC_DACMACP_INCFG_ConfigurationResponse_contents_data01 (c_MAC_DACMACP_INCFG_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Default_Access_Channel_MAC_Protocol_Attributes_Response (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MAC_DACMACP_INCFG_ConfigurationResponse_contents */
void FREE_c_MAC_DACMACP_INCFG_ConfigurationResponse_contents (c_MAC_DACMACP_INCFG_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Default_Access_Channel_MAC_Protocol_Attributes_Response (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_MAC_DACMACP_INUSE_AccessParameters_contents_data01 */
void FREE_c_MAC_DACMACP_INUSE_AccessParameters_contents_data01 (c_MAC_DACMACP_INUSE_AccessParameters_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MAC_DACMACP_INUSE_AccessParameters_contents */
void FREE_c_MAC_DACMACP_INUSE_AccessParameters_contents (c_MAC_DACMACP_INUSE_AccessParameters_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_MAC_EACMACP_INCFG_ConfigurationRequest_contents_data01 */
void FREE_c_MAC_EACMACP_INCFG_ConfigurationRequest_contents_data01 (c_MAC_EACMACP_INCFG_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MAC_EACMACP_INCFG_ConfigurationRequest_contents */
void FREE_c_MAC_EACMACP_INCFG_ConfigurationRequest_contents (c_MAC_EACMACP_INCFG_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_MAC_EACMACP_INCFG_ConfigurationResponse_contents_data01 */
void FREE_c_MAC_EACMACP_INCFG_ConfigurationResponse_contents_data01 (c_MAC_EACMACP_INCFG_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_Response (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MAC_EACMACP_INCFG_ConfigurationResponse_contents */
void FREE_c_MAC_EACMACP_INCFG_ConfigurationResponse_contents (c_MAC_EACMACP_INCFG_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_Response (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_MAC_EACMACP_INUSE_AccessParameters_contents_data01 */
void FREE_c_MAC_EACMACP_INUSE_AccessParameters_contents_data01 (c_MAC_EACMACP_INUSE_AccessParameters_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_MAC_EACMACP_INUSE_AccessParameters_contents_data02 */
void FREE_c_MAC_EACMACP_INUSE_AccessParameters_contents_data02 (c_MAC_EACMACP_INUSE_AccessParameters_contents_data02* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->ProfileID_Present) {
		}
		if (sp->data[i]->CommonPersistenceIncluded_Present) {
		}
		if (sp->data[i]->CommonAPersistence_Present) {
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_MAC_EACMACP_INUSE_AccessParameters_contents_data03 */
void FREE_c_MAC_EACMACP_INUSE_AccessParameters_contents_data03 (c_MAC_EACMACP_INUSE_AccessParameters_contents_data03* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->ProfileBasedAPersistence_Present) {
		}
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MAC_EACMACP_INUSE_AccessParameters_contents */
void FREE_c_MAC_EACMACP_INUSE_AccessParameters_contents (c_MAC_EACMACP_INUSE_AccessParameters_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data02.items; i0++) {
		if (sp->data02.data[i0]->ProfileID_Present) {
		}
		if (sp->data02.data[i0]->CommonPersistenceIncluded_Present) {
		}
		if (sp->data02.data[i0]->CommonAPersistence_Present) {
		}
		EDFree (sp->data02.data[i0]);
		sp->data02.data[i0] = NULL;
	}
	if (sp->data02.data) {EDFree (sp->data02.data); sp->data02.data = NULL; sp->data02.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data03.items; i0++) {
		if (sp->data03.data[i0]->ProfileBasedAPersistence_Present) {
		}
		EDFree (sp->data03.data[i0]);
		sp->data03.data[i0] = NULL;
	}
	if (sp->data03.data) {EDFree (sp->data03.data); sp->data03.data = NULL; sp->data03.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_MAC_EACMACP_INUSE_AttributeUpdateRequest_contents_data01 */
void FREE_c_MAC_EACMACP_INUSE_AttributeUpdateRequest_contents_data01 (c_MAC_EACMACP_INUSE_AttributeUpdateRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MAC_EACMACP_INUSE_AttributeUpdateRequest_contents */
void FREE_c_MAC_EACMACP_INUSE_AttributeUpdateRequest_contents (c_MAC_EACMACP_INUSE_AttributeUpdateRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_MAC_EACMACP_INUSE_AttributeUpdateAccept_contents */
void FREE_c_MAC_EACMACP_INUSE_AttributeUpdateAccept_contents (c_MAC_EACMACP_INUSE_AttributeUpdateAccept_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_MAC_EACMACP_INUSE_AttributeUpdateReject_contents */
void FREE_c_MAC_EACMACP_INUSE_AttributeUpdateReject_contents (c_MAC_EACMACP_INUSE_AttributeUpdateReject_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_MAC_DFTCMACP_INCFG_ConfigurationRequest_contents_data01 */
void FREE_c_MAC_DFTCMACP_INCFG_ConfigurationRequest_contents_data01 (c_MAC_DFTCMACP_INCFG_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MAC_DFTCMACP_INCFG_ConfigurationRequest_contents */
void FREE_c_MAC_DFTCMACP_INCFG_ConfigurationRequest_contents (c_MAC_DFTCMACP_INCFG_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_MAC_DFTCMACP_INCFG_ConfigurationResponse_contents_data01 */
void FREE_c_MAC_DFTCMACP_INCFG_ConfigurationResponse_contents_data01 (c_MAC_DFTCMACP_INCFG_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_Response (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MAC_DFTCMACP_INCFG_ConfigurationResponse_contents */
void FREE_c_MAC_DFTCMACP_INCFG_ConfigurationResponse_contents (c_MAC_DFTCMACP_INCFG_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_Response (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_MAC_DFTCMACP_INUSE_FixedModeEnable_contents */
void FREE_c_MAC_DFTCMACP_INUSE_FixedModeEnable_contents (c_MAC_DFTCMACP_INUSE_FixedModeEnable_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_MAC_EFTCMACP_INCFG_ConfigurationRequest_contents_data01 */
void FREE_c_MAC_EFTCMACP_INCFG_ConfigurationRequest_contents_data01 (c_MAC_EFTCMACP_INCFG_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MAC_EFTCMACP_INCFG_ConfigurationRequest_contents */
void FREE_c_MAC_EFTCMACP_INCFG_ConfigurationRequest_contents (c_MAC_EFTCMACP_INCFG_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_MAC_EFTCMACP_INCFG_ConfigurationResponse_contents_data01 */
void FREE_c_MAC_EFTCMACP_INCFG_ConfigurationResponse_contents_data01 (c_MAC_EFTCMACP_INCFG_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_Response (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MAC_EFTCMACP_INCFG_ConfigurationResponse_contents */
void FREE_c_MAC_EFTCMACP_INCFG_ConfigurationResponse_contents (c_MAC_EFTCMACP_INCFG_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_Response (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_MAC_EFTCMACP_INUSE_FixedModeEnable_contents */
void FREE_c_MAC_EFTCMACP_INUSE_FixedModeEnable_contents (c_MAC_EFTCMACP_INUSE_FixedModeEnable_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_MAC_EFTCMACP_INUSE_AttributeUpdateRequest_contents_data01 */
void FREE_c_MAC_EFTCMACP_INUSE_AttributeUpdateRequest_contents_data01 (c_MAC_EFTCMACP_INUSE_AttributeUpdateRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MAC_EFTCMACP_INUSE_AttributeUpdateRequest_contents */
void FREE_c_MAC_EFTCMACP_INUSE_AttributeUpdateRequest_contents (c_MAC_EFTCMACP_INUSE_AttributeUpdateRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_MAC_EFTCMACP_INUSE_AttributeUpdateAccept_contents */
void FREE_c_MAC_EFTCMACP_INUSE_AttributeUpdateAccept_contents (c_MAC_EFTCMACP_INUSE_AttributeUpdateAccept_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_MAC_EFTCMACP_INUSE_AttributeUpdateReject_contents */
void FREE_c_MAC_EFTCMACP_INUSE_AttributeUpdateReject_contents (c_MAC_EFTCMACP_INUSE_AttributeUpdateReject_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_MAC_MFTCMACP_INCFG_ConfigurationRequest_contents_data01 */
void FREE_c_MAC_MFTCMACP_INCFG_ConfigurationRequest_contents_data01 (c_MAC_MFTCMACP_INCFG_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MAC_MFTCMACP_INCFG_ConfigurationRequest_contents */
void FREE_c_MAC_MFTCMACP_INCFG_ConfigurationRequest_contents (c_MAC_MFTCMACP_INCFG_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_MAC_MFTCMACP_INCFG_ConfigurationResponse_contents_data01 */
void FREE_c_MAC_MFTCMACP_INCFG_ConfigurationResponse_contents_data01 (c_MAC_MFTCMACP_INCFG_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_Response (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MAC_MFTCMACP_INCFG_ConfigurationResponse_contents */
void FREE_c_MAC_MFTCMACP_INCFG_ConfigurationResponse_contents (c_MAC_MFTCMACP_INCFG_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_Response (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_MAC_MFTCMACP_INUSE_FixedModeEnable_contents_data01 */
void FREE_c_MAC_MFTCMACP_INUSE_FixedModeEnable_contents_data01 (c_MAC_MFTCMACP_INUSE_FixedModeEnable_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MAC_MFTCMACP_INUSE_FixedModeEnable_contents */
void FREE_c_MAC_MFTCMACP_INUSE_FixedModeEnable_contents (c_MAC_MFTCMACP_INUSE_FixedModeEnable_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_MAC_MFTCMACP_INUSE_AttributeUpdateRequest_contents_data01 */
void FREE_c_MAC_MFTCMACP_INUSE_AttributeUpdateRequest_contents_data01 (c_MAC_MFTCMACP_INUSE_AttributeUpdateRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MAC_MFTCMACP_INUSE_AttributeUpdateRequest_contents */
void FREE_c_MAC_MFTCMACP_INUSE_AttributeUpdateRequest_contents (c_MAC_MFTCMACP_INUSE_AttributeUpdateRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_MAC_MFTCMACP_INUSE_AttributeUpdateAccept_contents */
void FREE_c_MAC_MFTCMACP_INUSE_AttributeUpdateAccept_contents (c_MAC_MFTCMACP_INUSE_AttributeUpdateAccept_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_MAC_MFTCMACP_INUSE_AttributeUpdateReject_contents */
void FREE_c_MAC_MFTCMACP_INUSE_AttributeUpdateReject_contents (c_MAC_MFTCMACP_INUSE_AttributeUpdateReject_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_MAC_DRTCMACP_INCFG_ConfigurationRequest_contents_data01 */
void FREE_c_MAC_DRTCMACP_INCFG_ConfigurationRequest_contents_data01 (c_MAC_DRTCMACP_INCFG_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MAC_DRTCMACP_INCFG_ConfigurationRequest_contents */
void FREE_c_MAC_DRTCMACP_INCFG_ConfigurationRequest_contents (c_MAC_DRTCMACP_INCFG_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_MAC_DRTCMACP_INCFG_ConfigurationResponse_contents_data01 */
void FREE_c_MAC_DRTCMACP_INCFG_ConfigurationResponse_contents_data01 (c_MAC_DRTCMACP_INCFG_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Response (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MAC_DRTCMACP_INCFG_ConfigurationResponse_contents */
void FREE_c_MAC_DRTCMACP_INCFG_ConfigurationResponse_contents (c_MAC_DRTCMACP_INCFG_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Response (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_MAC_DRTCMACP_INUSE_BroadcastReverseRateLimit_contents_data01 */
void FREE_c_MAC_DRTCMACP_INUSE_BroadcastReverseRateLimit_contents_data01 (c_MAC_DRTCMACP_INUSE_BroadcastReverseRateLimit_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MAC_DRTCMACP_INUSE_BroadcastReverseRateLimit_contents */
void FREE_c_MAC_DRTCMACP_INUSE_BroadcastReverseRateLimit_contents (c_MAC_DRTCMACP_INUSE_BroadcastReverseRateLimit_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_MAC_DRTCMACP_INUSE_UnicastReverseRateLimit_contents */
void FREE_c_MAC_DRTCMACP_INUSE_UnicastReverseRateLimit_contents (c_MAC_DRTCMACP_INUSE_UnicastReverseRateLimit_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_MAC_S1RTCMACP_INCFG_ConfigurationRequest_contents_data01 */
void FREE_c_MAC_S1RTCMACP_INCFG_ConfigurationRequest_contents_data01 (c_MAC_S1RTCMACP_INCFG_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MAC_S1RTCMACP_INCFG_ConfigurationRequest_contents */
void FREE_c_MAC_S1RTCMACP_INCFG_ConfigurationRequest_contents (c_MAC_S1RTCMACP_INCFG_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_MAC_S1RTCMACP_INCFG_ConfigurationResponse_contents_data01 */
void FREE_c_MAC_S1RTCMACP_INCFG_ConfigurationResponse_contents_data01 (c_MAC_S1RTCMACP_INCFG_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Response (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MAC_S1RTCMACP_INCFG_ConfigurationResponse_contents */
void FREE_c_MAC_S1RTCMACP_INCFG_ConfigurationResponse_contents (c_MAC_S1RTCMACP_INCFG_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Response (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_MAC_S1RTCMACP_INUSE_BroadcastReverseRateLimit_contents_data01 */
void FREE_c_MAC_S1RTCMACP_INUSE_BroadcastReverseRateLimit_contents_data01 (c_MAC_S1RTCMACP_INUSE_BroadcastReverseRateLimit_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MAC_S1RTCMACP_INUSE_BroadcastReverseRateLimit_contents */
void FREE_c_MAC_S1RTCMACP_INUSE_BroadcastReverseRateLimit_contents (c_MAC_S1RTCMACP_INUSE_BroadcastReverseRateLimit_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_MAC_S1RTCMACP_INUSE_UnicastReverseRateLimit_contents */
void FREE_c_MAC_S1RTCMACP_INUSE_UnicastReverseRateLimit_contents (c_MAC_S1RTCMACP_INUSE_UnicastReverseRateLimit_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_MAC_S1RTCMACP_INUSE_AttributeUpdateRequest_contents_data01 */
void FREE_c_MAC_S1RTCMACP_INUSE_AttributeUpdateRequest_contents_data01 (c_MAC_S1RTCMACP_INUSE_AttributeUpdateRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MAC_S1RTCMACP_INUSE_AttributeUpdateRequest_contents */
void FREE_c_MAC_S1RTCMACP_INUSE_AttributeUpdateRequest_contents (c_MAC_S1RTCMACP_INUSE_AttributeUpdateRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_MAC_S1RTCMACP_INUSE_AttributeUpdateAccept_contents */
void FREE_c_MAC_S1RTCMACP_INUSE_AttributeUpdateAccept_contents (c_MAC_S1RTCMACP_INUSE_AttributeUpdateAccept_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_MAC_S1RTCMACP_INUSE_AttributeUpdateReject_contents */
void FREE_c_MAC_S1RTCMACP_INUSE_AttributeUpdateReject_contents (c_MAC_S1RTCMACP_INUSE_AttributeUpdateReject_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_MAC_S3RTCMACP_INCFG_ConfigurationRequest_contents_data01 */
void FREE_c_MAC_S3RTCMACP_INCFG_ConfigurationRequest_contents_data01 (c_MAC_S3RTCMACP_INCFG_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MAC_S3RTCMACP_INCFG_ConfigurationRequest_contents */
void FREE_c_MAC_S3RTCMACP_INCFG_ConfigurationRequest_contents (c_MAC_S3RTCMACP_INCFG_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_MAC_S3RTCMACP_INCFG_ConfigurationResponse_contents_data01 */
void FREE_c_MAC_S3RTCMACP_INCFG_ConfigurationResponse_contents_data01 (c_MAC_S3RTCMACP_INCFG_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Response (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MAC_S3RTCMACP_INCFG_ConfigurationResponse_contents */
void FREE_c_MAC_S3RTCMACP_INCFG_ConfigurationResponse_contents (c_MAC_S3RTCMACP_INCFG_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Response (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_MAC_S3RTCMACP_INUSE_Request_contents_data01 */
void FREE_c_MAC_S3RTCMACP_INUSE_Request_contents_data01 (c_MAC_S3RTCMACP_INUSE_Request_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MAC_S3RTCMACP_INUSE_Request_contents */
void FREE_c_MAC_S3RTCMACP_INUSE_Request_contents (c_MAC_S3RTCMACP_INUSE_Request_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_MAC_S3RTCMACP_INUSE_Grant_contents_data01 */
void FREE_c_MAC_S3RTCMACP_INUSE_Grant_contents_data01 (c_MAC_S3RTCMACP_INUSE_Grant_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MAC_S3RTCMACP_INUSE_Grant_contents */
void FREE_c_MAC_S3RTCMACP_INUSE_Grant_contents (c_MAC_S3RTCMACP_INUSE_Grant_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_MAC_S3RTCMACP_INUSE_AttributeUpdateRequest_contents_data01 */
void FREE_c_MAC_S3RTCMACP_INUSE_AttributeUpdateRequest_contents_data01 (c_MAC_S3RTCMACP_INUSE_AttributeUpdateRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MAC_S3RTCMACP_INUSE_AttributeUpdateRequest_contents */
void FREE_c_MAC_S3RTCMACP_INUSE_AttributeUpdateRequest_contents (c_MAC_S3RTCMACP_INUSE_AttributeUpdateRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_MAC_S3RTCMACP_INUSE_AttributeUpdateAccept_contents */
void FREE_c_MAC_S3RTCMACP_INUSE_AttributeUpdateAccept_contents (c_MAC_S3RTCMACP_INUSE_AttributeUpdateAccept_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_MAC_S3RTCMACP_INUSE_AttributeUpdateReject_contents */
void FREE_c_MAC_S3RTCMACP_INUSE_AttributeUpdateReject_contents (c_MAC_S3RTCMACP_INUSE_AttributeUpdateReject_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_MAC_MRTCMACP_INCFG_ConfigurationRequest_contents_data01 */
void FREE_c_MAC_MRTCMACP_INCFG_ConfigurationRequest_contents_data01 (c_MAC_MRTCMACP_INCFG_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MAC_MRTCMACP_INCFG_ConfigurationRequest_contents */
void FREE_c_MAC_MRTCMACP_INCFG_ConfigurationRequest_contents (c_MAC_MRTCMACP_INCFG_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_MAC_MRTCMACP_INCFG_ConfigurationResponse_contents_data01 */
void FREE_c_MAC_MRTCMACP_INCFG_ConfigurationResponse_contents_data01 (c_MAC_MRTCMACP_INCFG_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Response (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MAC_MRTCMACP_INCFG_ConfigurationResponse_contents */
void FREE_c_MAC_MRTCMACP_INCFG_ConfigurationResponse_contents (c_MAC_MRTCMACP_INCFG_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Response (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_MAC_MRTCMACP_INUSE_RTCAck_contents_data01 */
void FREE_c_MAC_MRTCMACP_INUSE_RTCAck_contents_data01 (c_MAC_MRTCMACP_INUSE_RTCAck_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MAC_MRTCMACP_INUSE_RTCAck_contents */
void FREE_c_MAC_MRTCMACP_INUSE_RTCAck_contents (c_MAC_MRTCMACP_INUSE_RTCAck_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_MAC_MRTCMACP_INUSE_CarrierRequest_contents */
void FREE_c_MAC_MRTCMACP_INUSE_CarrierRequest_contents (c_MAC_MRTCMACP_INUSE_CarrierRequest_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_MAC_MRTCMACP_INUSE_ReverseCDMAChannelDropped_contents_data01 */
void FREE_c_MAC_MRTCMACP_INUSE_ReverseCDMAChannelDropped_contents_data01 (c_MAC_MRTCMACP_INUSE_ReverseCDMAChannelDropped_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MAC_MRTCMACP_INUSE_ReverseCDMAChannelDropped_contents */
void FREE_c_MAC_MRTCMACP_INUSE_ReverseCDMAChannelDropped_contents (c_MAC_MRTCMACP_INUSE_ReverseCDMAChannelDropped_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_MAC_MRTCMACP_INUSE_ReverseCDMAChannelDroppedAck_contents */
void FREE_c_MAC_MRTCMACP_INUSE_ReverseCDMAChannelDroppedAck_contents (c_MAC_MRTCMACP_INUSE_ReverseCDMAChannelDroppedAck_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_MAC_MRTCMACP_INUSE_Request_contents_data01 */
void FREE_c_MAC_MRTCMACP_INUSE_Request_contents_data01 (c_MAC_MRTCMACP_INUSE_Request_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MAC_MRTCMACP_INUSE_Request_contents */
void FREE_c_MAC_MRTCMACP_INUSE_Request_contents (c_MAC_MRTCMACP_INUSE_Request_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_MAC_MRTCMACP_INUSE_Grant_contents_data01 */
void FREE_c_MAC_MRTCMACP_INUSE_Grant_contents_data01 (c_MAC_MRTCMACP_INUSE_Grant_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for variable-sized sequence c_MAC_MRTCMACP_INUSE_Grant_contents_data02 */
void FREE_c_MAC_MRTCMACP_INUSE_Grant_contents_data02 (c_MAC_MRTCMACP_INUSE_Grant_contents_data02* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MAC_MRTCMACP_INUSE_Grant_contents */
void FREE_c_MAC_MRTCMACP_INUSE_Grant_contents (c_MAC_MRTCMACP_INUSE_Grant_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data02.items; i0++) {
		EDFree (sp->data02.data[i0]);
		sp->data02.data[i0] = NULL;
	}
	if (sp->data02.data) {EDFree (sp->data02.data); sp->data02.data = NULL; sp->data02.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_MAC_MRTCMACP_INUSE_AttributeUpdateRequest_contents_data01 */
void FREE_c_MAC_MRTCMACP_INUSE_AttributeUpdateRequest_contents_data01 (c_MAC_MRTCMACP_INUSE_AttributeUpdateRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_MAC_MRTCMACP_INUSE_AttributeUpdateRequest_contents */
void FREE_c_MAC_MRTCMACP_INUSE_AttributeUpdateRequest_contents (c_MAC_MRTCMACP_INUSE_AttributeUpdateRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_MAC_MRTCMACP_INUSE_AttributeUpdateAccept_contents */
void FREE_c_MAC_MRTCMACP_INUSE_AttributeUpdateAccept_contents (c_MAC_MRTCMACP_INUSE_AttributeUpdateAccept_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_MAC_MRTCMACP_INUSE_AttributeUpdateReject_contents */
void FREE_c_MAC_MRTCMACP_INUSE_AttributeUpdateReject_contents (c_MAC_MRTCMACP_INUSE_AttributeUpdateReject_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_PHYS01_DS0S1PLPI_INCFG_ConfigurationRequest_contents_data01 */
void FREE_c_PHYS01_DS0S1PLPI_INCFG_ConfigurationRequest_contents_data01 (c_PHYS01_DS0S1PLPI_INCFG_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data[i]->AttributeRecord.AttributeValue.value);
			sp->data[i]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_PHYS01_DS0S1PLPI_INCFG_ConfigurationRequest_contents */
void FREE_c_PHYS01_DS0S1PLPI_INCFG_ConfigurationRequest_contents (c_PHYS01_DS0S1PLPI_INCFG_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data01.data[i0]->AttributeRecord.AttributeValue.value);
			sp->data01.data[i0]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data01.data[i0]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_PHYS01_DS0S1PLPI_INCFG_ConfigurationResponse_contents_data01 */
void FREE_c_PHYS01_DS0S1PLPI_INCFG_ConfigurationResponse_contents_data01 (c_PHYS01_DS0S1PLPI_INCFG_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data[i]->AttributeRecord.AttributeValue.value);
			sp->data[i]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_PHYS01_DS0S1PLPI_INCFG_ConfigurationResponse_contents */
void FREE_c_PHYS01_DS0S1PLPI_INCFG_ConfigurationResponse_contents (c_PHYS01_DS0S1PLPI_INCFG_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data01.data[i0]->AttributeRecord.AttributeValue.value);
			sp->data01.data[i0]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data01.data[i0]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_PHYS2_S2PLPI_INCFG_ConfigurationRequest_contents_data01 */
void FREE_c_PHYS2_S2PLPI_INCFG_ConfigurationRequest_contents_data01 (c_PHYS2_S2PLPI_INCFG_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data[i]->AttributeRecord.AttributeValue.value);
			sp->data[i]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_PHYS2_S2PLPI_INCFG_ConfigurationRequest_contents */
void FREE_c_PHYS2_S2PLPI_INCFG_ConfigurationRequest_contents (c_PHYS2_S2PLPI_INCFG_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data01.data[i0]->AttributeRecord.AttributeValue.value);
			sp->data01.data[i0]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data01.data[i0]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_PHYS2_S2PLPI_INCFG_ConfigurationResponse_contents_data01 */
void FREE_c_PHYS2_S2PLPI_INCFG_ConfigurationResponse_contents_data01 (c_PHYS2_S2PLPI_INCFG_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data[i]->AttributeRecord.AttributeValue.value);
			sp->data[i]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_PHYS2_S2PLPI_INCFG_ConfigurationResponse_contents */
void FREE_c_PHYS2_S2PLPI_INCFG_ConfigurationResponse_contents (c_PHYS2_S2PLPI_INCFG_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data01.data[i0]->AttributeRecord.AttributeValue.value);
			sp->data01.data[i0]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data01.data[i0]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_PHYS3_S3PLPI_INCFG_ConfigurationRequest_contents_data01 */
void FREE_c_PHYS3_S3PLPI_INCFG_ConfigurationRequest_contents_data01 (c_PHYS3_S3PLPI_INCFG_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_PHYS3_S3PLPI_INCFG_ConfigurationRequest_contents */
void FREE_c_PHYS3_S3PLPI_INCFG_ConfigurationRequest_contents (c_PHYS3_S3PLPI_INCFG_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_PHYS3_S3PLPI_INCFG_ConfigurationResponse_contents_data01 */
void FREE_c_PHYS3_S3PLPI_INCFG_ConfigurationResponse_contents_data01 (c_PHYS3_S3PLPI_INCFG_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_Response (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_PHYS3_S3PLPI_INCFG_ConfigurationResponse_contents */
void FREE_c_PHYS3_S3PLPI_INCFG_ConfigurationResponse_contents (c_PHYS3_S3PLPI_INCFG_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_Response (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_PHYS3_S3PLPI_INUSE_AttributeUpdateRequest_contents_data01 */
void FREE_c_PHYS3_S3PLPI_INUSE_AttributeUpdateRequest_contents_data01 (c_PHYS3_S3PLPI_INUSE_AttributeUpdateRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		FREE_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes (&(sp->data[i]->AttributeRecord));
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_PHYS3_S3PLPI_INUSE_AttributeUpdateRequest_contents */
void FREE_c_PHYS3_S3PLPI_INUSE_AttributeUpdateRequest_contents (c_PHYS3_S3PLPI_INUSE_AttributeUpdateRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		FREE_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes (&(sp->data01.data[i0]->AttributeRecord));
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_PHYS3_S3PLPI_INUSE_AttributeUpdateAccept_contents */
void FREE_c_PHYS3_S3PLPI_INUSE_AttributeUpdateAccept_contents (c_PHYS3_S3PLPI_INUSE_AttributeUpdateAccept_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_PHYS3_S3PLPI_INUSE_AttributeUpdateReject_contents */
void FREE_c_PHYS3_S3PLPI_INUSE_AttributeUpdateReject_contents (c_PHYS3_S3PLPI_INUSE_AttributeUpdateReject_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for variable-sized sequence c_GEN_GCP_ConfigurationRequest_contents_data01 */
void FREE_c_GEN_GCP_ConfigurationRequest_contents_data01 (c_GEN_GCP_ConfigurationRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data[i]->AttributeRecord.AttributeValue.value);
			sp->data[i]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_GEN_GCP_ConfigurationRequest_contents */
void FREE_c_GEN_GCP_ConfigurationRequest_contents (c_GEN_GCP_ConfigurationRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data01.data[i0]->AttributeRecord.AttributeValue.value);
			sp->data01.data[i0]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data01.data[i0]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_GEN_GCP_ConfigurationResponse_contents_data01 */
void FREE_c_GEN_GCP_ConfigurationResponse_contents_data01 (c_GEN_GCP_ConfigurationResponse_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data[i]->AttributeRecord.AttributeValue.value);
			sp->data[i]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_GEN_GCP_ConfigurationResponse_contents */
void FREE_c_GEN_GCP_ConfigurationResponse_contents (c_GEN_GCP_ConfigurationResponse_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data01.data[i0]->AttributeRecord.AttributeValue.value);
			sp->data01.data[i0]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data01.data[i0]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_GEN_GAUP_AttributeUpdateRequest_contents_data01 */
void FREE_c_GEN_GAUP_AttributeUpdateRequest_contents_data01 (c_GEN_GAUP_AttributeUpdateRequest_contents_data01* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
		if (sp->data[i]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data[i]->AttributeRecord.AttributeValue.value);
			sp->data[i]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data[i]);
		sp->data[i] = NULL;
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_GEN_GAUP_AttributeUpdateRequest_contents */
void FREE_c_GEN_GAUP_AttributeUpdateRequest_contents (c_GEN_GAUP_AttributeUpdateRequest_contents* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data01.items; i0++) {
		if (sp->data01.data[i0]->AttributeRecord.AttributeValue.value != NULL) {
			EDFree (sp->data01.data[i0]->AttributeRecord.AttributeValue.value);
			sp->data01.data[i0]->AttributeRecord.AttributeValue.value = NULL;
		}
		sp->data01.data[i0]->AttributeRecord.AttributeValue.usedBits = 0;
		EDFree (sp->data01.data[i0]);
		sp->data01.data[i0] = NULL;
	}
	if (sp->data01.data) {EDFree (sp->data01.data); sp->data01.data = NULL; sp->data01.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_GEN_GAUP_AttributeUpdateAccept_contents */
void FREE_c_GEN_GAUP_AttributeUpdateAccept_contents (c_GEN_GAUP_AttributeUpdateAccept_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_GEN_GAUP_AttributeUpdateReject_contents */
void FREE_c_GEN_GAUP_AttributeUpdateReject_contents (c_GEN_GAUP_AttributeUpdateReject_contents* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_CONN_DINSP_INUSE_Sync */
void FREE_c_CONN_DINSP_INUSE_Sync (c_CONN_DINSP_INUSE_Sync* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_DINSP_INUSE_Sync_contents (&(sp->contents));

}

/* Free function for struct c_SIGAPP_SLP_INCFG_ConfigurationRequest */
void FREE_c_SIGAPP_SLP_INCFG_ConfigurationRequest (c_SIGAPP_SLP_INCFG_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SIGAPP_SLP_INCFG_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_SIGAPP_SLP_INCFG_ConfigurationResponse */
void FREE_c_SIGAPP_SLP_INCFG_ConfigurationResponse (c_SIGAPP_SLP_INCFG_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SIGAPP_SLP_INCFG_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_SIGAPP_SLP_Reset */
void FREE_c_SIGAPP_SLP_Reset (c_SIGAPP_SLP_Reset* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SIGAPP_SLP_Reset_contents (&(sp->contents));

}

/* Free function for struct c_SIGAPP_SLP_ResetAck */
void FREE_c_SIGAPP_SLP_ResetAck (c_SIGAPP_SLP_ResetAck* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SIGAPP_SLP_ResetAck_contents (&(sp->contents));

}

/* Free function for struct c_PKTAPP_DPA_INCFG_ConfigurationRequest */
void FREE_c_PKTAPP_DPA_INCFG_ConfigurationRequest (c_PKTAPP_DPA_INCFG_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_PKTAPP_DPA_INCFG_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_PKTAPP_DPA_INCFG_ConfigurationResponse */
void FREE_c_PKTAPP_DPA_INCFG_ConfigurationResponse (c_PKTAPP_DPA_INCFG_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_PKTAPP_DPA_INCFG_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_PKTAPP_RLP_INUSE_Reset */
void FREE_c_PKTAPP_RLP_INUSE_Reset (c_PKTAPP_RLP_INUSE_Reset* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_PKTAPP_RLP_INUSE_ResetAck */
void FREE_c_PKTAPP_RLP_INUSE_ResetAck (c_PKTAPP_RLP_INUSE_ResetAck* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_PKTAPP_RLP_INUSE_Nak */
void FREE_c_PKTAPP_RLP_INUSE_Nak (c_PKTAPP_RLP_INUSE_Nak* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_PKTAPP_RLP_INUSE_Nak_contents (&(sp->contents));

}

/* Free function for struct c_PKTAPP_LUP_INUSE_LocationRequest */
void FREE_c_PKTAPP_LUP_INUSE_LocationRequest (c_PKTAPP_LUP_INUSE_LocationRequest* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_PKTAPP_LUP_INUSE_LocationNotification */
void FREE_c_PKTAPP_LUP_INUSE_LocationNotification (c_PKTAPP_LUP_INUSE_LocationNotification* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_PKTAPP_LUP_INUSE_LocationNotification_contents (&(sp->contents));

}

/* Free function for struct c_PKTAPP_LUP_INUSE_LocationAssignment */
void FREE_c_PKTAPP_LUP_INUSE_LocationAssignment (c_PKTAPP_LUP_INUSE_LocationAssignment* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_PKTAPP_LUP_INUSE_LocationAssignment_contents (&(sp->contents));

}

/* Free function for struct c_PKTAPP_LUP_INUSE_LocationComplete */
void FREE_c_PKTAPP_LUP_INUSE_LocationComplete (c_PKTAPP_LUP_INUSE_LocationComplete* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_PKTAPP_LUP_INUSE_LocationComplete_contents (&(sp->contents));

}

/* Free function for struct c_PKTAPP_FCP_INUSE_XonRequest */
void FREE_c_PKTAPP_FCP_INUSE_XonRequest (c_PKTAPP_FCP_INUSE_XonRequest* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_PKTAPP_FCP_INUSE_XonResponse */
void FREE_c_PKTAPP_FCP_INUSE_XonResponse (c_PKTAPP_FCP_INUSE_XonResponse* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_PKTAPP_FCP_INUSE_XoffRequest */
void FREE_c_PKTAPP_FCP_INUSE_XoffRequest (c_PKTAPP_FCP_INUSE_XoffRequest* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_PKTAPP_FCP_INUSE_XoffResponse */
void FREE_c_PKTAPP_FCP_INUSE_XoffResponse (c_PKTAPP_FCP_INUSE_XoffResponse* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_PKTAPP_FCP_INUSE_DataReady */
void FREE_c_PKTAPP_FCP_INUSE_DataReady (c_PKTAPP_FCP_INUSE_DataReady* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_PKTAPP_FCP_INUSE_DataReady_contents (&(sp->contents));

}

/* Free function for struct c_PKTAPP_FCP_INUSE_DataReadyAck */
void FREE_c_PKTAPP_FCP_INUSE_DataReadyAck (c_PKTAPP_FCP_INUSE_DataReadyAck* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_PKTAPP_FCP_INUSE_DataReadyAck_contents (&(sp->contents));

}

/* Free function for struct c_MFPAPP_MFPA_INCFG_ConfigurationRequest */
void FREE_c_MFPAPP_MFPA_INCFG_ConfigurationRequest (c_MFPAPP_MFPA_INCFG_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MFPAPP_MFPA_INCFG_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_MFPAPP_MFPA_INCFG_ConfigurationResponse */
void FREE_c_MFPAPP_MFPA_INCFG_ConfigurationResponse (c_MFPAPP_MFPA_INCFG_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MFPAPP_MFPA_INCFG_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_MFPAPP_RLP_INUSE_ResetTxIndication */
void FREE_c_MFPAPP_RLP_INUSE_ResetTxIndication (c_MFPAPP_RLP_INUSE_ResetTxIndication* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MFPAPP_RLP_INUSE_ResetTxIndication_contents (&(sp->contents));

}

/* Free function for struct c_MFPAPP_RLP_INUSE_ResetRxIndication */
void FREE_c_MFPAPP_RLP_INUSE_ResetRxIndication (c_MFPAPP_RLP_INUSE_ResetRxIndication* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MFPAPP_RLP_INUSE_ResetRxIndication_contents (&(sp->contents));

}

/* Free function for struct c_MFPAPP_RLP_INUSE_ResetTxIndicationAck */
void FREE_c_MFPAPP_RLP_INUSE_ResetTxIndicationAck (c_MFPAPP_RLP_INUSE_ResetTxIndicationAck* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MFPAPP_RLP_INUSE_ResetTxIndicationAck_contents (&(sp->contents));

}

/* Free function for struct c_MFPAPP_RLP_INUSE_ResetTxComplete */
void FREE_c_MFPAPP_RLP_INUSE_ResetTxComplete (c_MFPAPP_RLP_INUSE_ResetTxComplete* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MFPAPP_RLP_INUSE_ResetTxComplete_contents (&(sp->contents));

}

/* Free function for struct c_MFPAPP_RLP_INUSE_ResetRxComplete */
void FREE_c_MFPAPP_RLP_INUSE_ResetRxComplete (c_MFPAPP_RLP_INUSE_ResetRxComplete* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MFPAPP_RLP_INUSE_ResetRxComplete_contents (&(sp->contents));

}

/* Free function for struct c_MFPAPP_RLP_INUSE_Nak */
void FREE_c_MFPAPP_RLP_INUSE_Nak (c_MFPAPP_RLP_INUSE_Nak* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MFPAPP_RLP_INUSE_Nak_contents (&(sp->contents));

}

/* Free function for struct c_MFPAPP_RLP_INUSE_ReservationOnRequest */
void FREE_c_MFPAPP_RLP_INUSE_ReservationOnRequest (c_MFPAPP_RLP_INUSE_ReservationOnRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MFPAPP_RLP_INUSE_ReservationOnRequest_contents (&(sp->contents));

}

/* Free function for struct c_MFPAPP_RLP_INUSE_ReservationOffRequest */
void FREE_c_MFPAPP_RLP_INUSE_ReservationOffRequest (c_MFPAPP_RLP_INUSE_ReservationOffRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MFPAPP_RLP_INUSE_ReservationOffRequest_contents (&(sp->contents));

}

/* Free function for struct c_MFPAPP_RLP_INUSE_ReservationAccept */
void FREE_c_MFPAPP_RLP_INUSE_ReservationAccept (c_MFPAPP_RLP_INUSE_ReservationAccept* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MFPAPP_RLP_INUSE_ReservationAccept_contents (&(sp->contents));

}

/* Free function for struct c_MFPAPP_RLP_INUSE_ReservationReject */
void FREE_c_MFPAPP_RLP_INUSE_ReservationReject (c_MFPAPP_RLP_INUSE_ReservationReject* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MFPAPP_RLP_INUSE_ReservationReject_contents (&(sp->contents));

}

/* Free function for struct c_MFPAPP_RLP_INUSE_RevReservationOn */
void FREE_c_MFPAPP_RLP_INUSE_RevReservationOn (c_MFPAPP_RLP_INUSE_RevReservationOn* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MFPAPP_RLP_INUSE_RevReservationOn_contents (&(sp->contents));

}

/* Free function for struct c_MFPAPP_RLP_INUSE_RevReservationOff */
void FREE_c_MFPAPP_RLP_INUSE_RevReservationOff (c_MFPAPP_RLP_INUSE_RevReservationOff* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MFPAPP_RLP_INUSE_RevReservationOff_contents (&(sp->contents));

}

/* Free function for struct c_MFPAPP_RLP_INUSE_FwdReservationOff */
void FREE_c_MFPAPP_RLP_INUSE_FwdReservationOff (c_MFPAPP_RLP_INUSE_FwdReservationOff* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MFPAPP_RLP_INUSE_FwdReservationOff_contents (&(sp->contents));

}

/* Free function for struct c_MFPAPP_RLP_INUSE_FwdReservationOn */
void FREE_c_MFPAPP_RLP_INUSE_FwdReservationOn (c_MFPAPP_RLP_INUSE_FwdReservationOn* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MFPAPP_RLP_INUSE_FwdReservationOn_contents (&(sp->contents));

}

/* Free function for struct c_MFPAPP_RLP_INUSE_FwdReservationAck */
void FREE_c_MFPAPP_RLP_INUSE_FwdReservationAck (c_MFPAPP_RLP_INUSE_FwdReservationAck* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MFPAPP_RLP_INUSE_FwdReservationAck_contents (&(sp->contents));

}

/* Free function for struct c_MFPAPP_RLP_INUSE_AttributeUpdateRequest */
void FREE_c_MFPAPP_RLP_INUSE_AttributeUpdateRequest (c_MFPAPP_RLP_INUSE_AttributeUpdateRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MFPAPP_RLP_INUSE_AttributeUpdateRequest_contents (&(sp->contents));

}

/* Free function for struct c_MFPAPP_RLP_INUSE_AttributeUpdateAccept */
void FREE_c_MFPAPP_RLP_INUSE_AttributeUpdateAccept (c_MFPAPP_RLP_INUSE_AttributeUpdateAccept* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MFPAPP_RLP_INUSE_AttributeUpdateAccept_contents (&(sp->contents));

}

/* Free function for struct c_MFPAPP_RLP_INUSE_AttributeUpdateReject */
void FREE_c_MFPAPP_RLP_INUSE_AttributeUpdateReject (c_MFPAPP_RLP_INUSE_AttributeUpdateReject* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MFPAPP_RLP_INUSE_AttributeUpdateReject_contents (&(sp->contents));

}

/* Free function for struct c_MFPAPP_DOSP_INUSE_DataOverSignaling */
void FREE_c_MFPAPP_DOSP_INUSE_DataOverSignaling (c_MFPAPP_DOSP_INUSE_DataOverSignaling* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MFPAPP_DOSP_INUSE_DataOverSignaling_contents (&(sp->contents));

}

/* Free function for struct c_MFPAPP_DOSP_INUSE_DataOverSignalingAck */
void FREE_c_MFPAPP_DOSP_INUSE_DataOverSignalingAck (c_MFPAPP_DOSP_INUSE_DataOverSignalingAck* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MFPAPP_DOSP_INUSE_DataOverSignalingAck_contents (&(sp->contents));

}

/* Free function for struct c_MFPAPP_LUP_INUSE_LocationRequest */
void FREE_c_MFPAPP_LUP_INUSE_LocationRequest (c_MFPAPP_LUP_INUSE_LocationRequest* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_MFPAPP_LUP_INUSE_LocationNotification */
void FREE_c_MFPAPP_LUP_INUSE_LocationNotification (c_MFPAPP_LUP_INUSE_LocationNotification* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MFPAPP_LUP_INUSE_LocationNotification_contents (&(sp->contents));

}

/* Free function for struct c_MFPAPP_LUP_INUSE_LocationAssignment */
void FREE_c_MFPAPP_LUP_INUSE_LocationAssignment (c_MFPAPP_LUP_INUSE_LocationAssignment* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MFPAPP_LUP_INUSE_LocationAssignment_contents (&(sp->contents));

}

/* Free function for struct c_MFPAPP_LUP_INUSE_LocationComplete */
void FREE_c_MFPAPP_LUP_INUSE_LocationComplete (c_MFPAPP_LUP_INUSE_LocationComplete* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MFPAPP_LUP_INUSE_LocationComplete_contents (&(sp->contents));

}

/* Free function for struct c_MFPAPP_LUP_INUSE_StorageBLOBRequest */
void FREE_c_MFPAPP_LUP_INUSE_StorageBLOBRequest (c_MFPAPP_LUP_INUSE_StorageBLOBRequest* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_MFPAPP_LUP_INUSE_StorageBLOBNotification */
void FREE_c_MFPAPP_LUP_INUSE_StorageBLOBNotification (c_MFPAPP_LUP_INUSE_StorageBLOBNotification* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MFPAPP_LUP_INUSE_StorageBLOBNotification_contents (&(sp->contents));

}

/* Free function for struct c_MFPAPP_LUP_INUSE_StorageBLOBAssignment */
void FREE_c_MFPAPP_LUP_INUSE_StorageBLOBAssignment (c_MFPAPP_LUP_INUSE_StorageBLOBAssignment* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MFPAPP_LUP_INUSE_StorageBLOBAssignment_contents (&(sp->contents));

}

/* Free function for struct c_MFPAPP_LUP_INUSE_StorageBLOBComplete */
void FREE_c_MFPAPP_LUP_INUSE_StorageBLOBComplete (c_MFPAPP_LUP_INUSE_StorageBLOBComplete* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MFPAPP_LUP_INUSE_StorageBLOBComplete_contents (&(sp->contents));

}

/* Free function for struct c_MFPAPP_FCP_INUSE_XonRequest */
void FREE_c_MFPAPP_FCP_INUSE_XonRequest (c_MFPAPP_FCP_INUSE_XonRequest* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_MFPAPP_FCP_INUSE_XonResponse */
void FREE_c_MFPAPP_FCP_INUSE_XonResponse (c_MFPAPP_FCP_INUSE_XonResponse* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_MFPAPP_FCP_INUSE_XoffRequest */
void FREE_c_MFPAPP_FCP_INUSE_XoffRequest (c_MFPAPP_FCP_INUSE_XoffRequest* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_MFPAPP_FCP_INUSE_XoffResponse */
void FREE_c_MFPAPP_FCP_INUSE_XoffResponse (c_MFPAPP_FCP_INUSE_XoffResponse* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_MFPAPP_FCP_INUSE_DataReady */
void FREE_c_MFPAPP_FCP_INUSE_DataReady (c_MFPAPP_FCP_INUSE_DataReady* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MFPAPP_FCP_INUSE_DataReady_contents (&(sp->contents));

}

/* Free function for struct c_MFPAPP_FCP_INUSE_DataReadyAck */
void FREE_c_MFPAPP_FCP_INUSE_DataReadyAck (c_MFPAPP_FCP_INUSE_DataReadyAck* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MFPAPP_FCP_INUSE_DataReadyAck_contents (&(sp->contents));

}

/* Free function for struct c_STREAM_DSP_INCFG_ConfigurationRequest */
void FREE_c_STREAM_DSP_INCFG_ConfigurationRequest (c_STREAM_DSP_INCFG_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_STREAM_DSP_INCFG_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_STREAM_DSP_INCFG_ConfigurationResponse */
void FREE_c_STREAM_DSP_INCFG_ConfigurationResponse (c_STREAM_DSP_INCFG_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_STREAM_DSP_INCFG_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_STREAM_GVSP_INCFG_ConfigurationRequest */
void FREE_c_STREAM_GVSP_INCFG_ConfigurationRequest (c_STREAM_GVSP_INCFG_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_STREAM_GVSP_INCFG_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_STREAM_GVSP_INCFG_ConfigurationResponse */
void FREE_c_STREAM_GVSP_INCFG_ConfigurationResponse (c_STREAM_GVSP_INCFG_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_STREAM_GVSP_INCFG_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_SESSION_DSMP_INCFG_ConfigurationRequest */
void FREE_c_SESSION_DSMP_INCFG_ConfigurationRequest (c_SESSION_DSMP_INCFG_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SESSION_DSMP_INCFG_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_SESSION_DSMP_INCFG_ConfigurationResponse */
void FREE_c_SESSION_DSMP_INCFG_ConfigurationResponse (c_SESSION_DSMP_INCFG_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SESSION_DSMP_INCFG_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_SESSION_DSMP_INUSE_SessionClose */
void FREE_c_SESSION_DSMP_INUSE_SessionClose (c_SESSION_DSMP_INUSE_SessionClose* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SESSION_DSMP_INUSE_SessionClose_contents (&(sp->contents));

}

/* Free function for struct c_SESSION_DSMP_INUSE_KeepAliveRequest */
void FREE_c_SESSION_DSMP_INUSE_KeepAliveRequest (c_SESSION_DSMP_INUSE_KeepAliveRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SESSION_DSMP_INUSE_KeepAliveRequest_contents (&(sp->contents));

}

/* Free function for struct c_SESSION_DSMP_INUSE_KeepAliveResponse */
void FREE_c_SESSION_DSMP_INUSE_KeepAliveResponse (c_SESSION_DSMP_INUSE_KeepAliveResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SESSION_DSMP_INUSE_KeepAliveResponse_contents (&(sp->contents));

}

/* Free function for struct c_SESSION_DAMP_INCFG_ConfigurationRequest */
void FREE_c_SESSION_DAMP_INCFG_ConfigurationRequest (c_SESSION_DAMP_INCFG_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SESSION_DAMP_INCFG_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_SESSION_DAMP_INCFG_ConfigurationResponse */
void FREE_c_SESSION_DAMP_INCFG_ConfigurationResponse (c_SESSION_DAMP_INCFG_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SESSION_DAMP_INCFG_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_SESSION_DAMP_INUSE_UATIRequest */
void FREE_c_SESSION_DAMP_INUSE_UATIRequest (c_SESSION_DAMP_INUSE_UATIRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SESSION_DAMP_INUSE_UATIRequest_contents (&(sp->contents));

}

/* Free function for struct c_SESSION_DAMP_INUSE_UATIAssignment */
void FREE_c_SESSION_DAMP_INUSE_UATIAssignment (c_SESSION_DAMP_INUSE_UATIAssignment* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SESSION_DAMP_INUSE_UATIAssignment_contents (&(sp->contents));

}

/* Free function for struct c_SESSION_DAMP_INUSE_UATIComplete */
void FREE_c_SESSION_DAMP_INUSE_UATIComplete (c_SESSION_DAMP_INUSE_UATIComplete* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SESSION_DAMP_INUSE_UATIComplete_contents (&(sp->contents));

}

/* Free function for struct c_SESSION_DAMP_INUSE_HardwareIDRequest */
void FREE_c_SESSION_DAMP_INUSE_HardwareIDRequest (c_SESSION_DAMP_INUSE_HardwareIDRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SESSION_DAMP_INUSE_HardwareIDRequest_contents (&(sp->contents));

}

/* Free function for struct c_SESSION_DAMP_INUSE_HardwareIDResponse */
void FREE_c_SESSION_DAMP_INUSE_HardwareIDResponse (c_SESSION_DAMP_INUSE_HardwareIDResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SESSION_DAMP_INUSE_HardwareIDResponse_contents (&(sp->contents));

}

/* Free function for struct c_SESSION_DAMP_INUSE_AttributeUpdateRequest */
void FREE_c_SESSION_DAMP_INUSE_AttributeUpdateRequest (c_SESSION_DAMP_INUSE_AttributeUpdateRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SESSION_DAMP_INUSE_AttributeUpdateRequest_contents (&(sp->contents));

}

/* Free function for struct c_SESSION_DAMP_INUSE_AttributeUpdateAccept */
void FREE_c_SESSION_DAMP_INUSE_AttributeUpdateAccept (c_SESSION_DAMP_INUSE_AttributeUpdateAccept* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SESSION_DAMP_INUSE_AttributeUpdateAccept_contents (&(sp->contents));

}

/* Free function for struct c_SESSION_DAMP_INUSE_AttributeUpdateReject */
void FREE_c_SESSION_DAMP_INUSE_AttributeUpdateReject (c_SESSION_DAMP_INUSE_AttributeUpdateReject* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SESSION_DAMP_INUSE_AttributeUpdateReject_contents (&(sp->contents));

}

/* Free function for struct c_SESSION_DSCP_INUSE_ConfigurationComplete */
void FREE_c_SESSION_DSCP_INUSE_ConfigurationComplete (c_SESSION_DSCP_INUSE_ConfigurationComplete* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SESSION_DSCP_INUSE_ConfigurationComplete_contents (&(sp->contents));

}

/* Free function for struct c_SESSION_DSCP_INUSE_ConfigurationStart */
void FREE_c_SESSION_DSCP_INUSE_ConfigurationStart (c_SESSION_DSCP_INUSE_ConfigurationStart* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_SESSION_DSCP_INUSE_ConfigurationRequest */
void FREE_c_SESSION_DSCP_INUSE_ConfigurationRequest (c_SESSION_DSCP_INUSE_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SESSION_DSCP_INUSE_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_SESSION_DSCP_INUSE_ConfigurationResponse */
void FREE_c_SESSION_DSCP_INUSE_ConfigurationResponse (c_SESSION_DSCP_INUSE_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SESSION_DSCP_INUSE_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_SESSION_DSCP_INUSE_SoftConfigurationComplete */
void FREE_c_SESSION_DSCP_INUSE_SoftConfigurationComplete (c_SESSION_DSCP_INUSE_SoftConfigurationComplete* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SESSION_DSCP_INUSE_SoftConfigurationComplete_contents (&(sp->contents));

}

/* Free function for struct c_SESSION_DSCP_INUSE_LockConfiguration */
void FREE_c_SESSION_DSCP_INUSE_LockConfiguration (c_SESSION_DSCP_INUSE_LockConfiguration* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SESSION_DSCP_INUSE_LockConfiguration_contents (&(sp->contents));

}

/* Free function for struct c_SESSION_DSCP_INUSE_LockConfigurationAck */
void FREE_c_SESSION_DSCP_INUSE_LockConfigurationAck (c_SESSION_DSCP_INUSE_LockConfigurationAck* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SESSION_DSCP_INUSE_LockConfigurationAck_contents (&(sp->contents));

}

/* Free function for struct c_SESSION_DSCP_INUSE_UnLockConfiguration */
void FREE_c_SESSION_DSCP_INUSE_UnLockConfiguration (c_SESSION_DSCP_INUSE_UnLockConfiguration* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SESSION_DSCP_INUSE_UnLockConfiguration_contents (&(sp->contents));

}

/* Free function for struct c_SESSION_DSCP_INUSE_UnLockConfigurationAck */
void FREE_c_SESSION_DSCP_INUSE_UnLockConfigurationAck (c_SESSION_DSCP_INUSE_UnLockConfigurationAck* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SESSION_DSCP_INUSE_UnLockConfigurationAck_contents (&(sp->contents));

}

/* Free function for struct c_SESSION_DSCP_INUSE_DeletePersonality */
void FREE_c_SESSION_DSCP_INUSE_DeletePersonality (c_SESSION_DSCP_INUSE_DeletePersonality* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SESSION_DSCP_INUSE_DeletePersonality_contents (&(sp->contents));

}

/* Free function for struct c_SESSION_DSCP_INUSE_DeletePersonalityAck */
void FREE_c_SESSION_DSCP_INUSE_DeletePersonalityAck (c_SESSION_DSCP_INUSE_DeletePersonalityAck* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SESSION_DSCP_INUSE_DeletePersonalityAck_contents (&(sp->contents));

}

/* Free function for struct c_SESSION_DSCP_INUSE_AttributeUpdateRequest */
void FREE_c_SESSION_DSCP_INUSE_AttributeUpdateRequest (c_SESSION_DSCP_INUSE_AttributeUpdateRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SESSION_DSCP_INUSE_AttributeUpdateRequest_contents (&(sp->contents));

}

/* Free function for struct c_SESSION_DSCP_INUSE_AttributeUpdateAccept */
void FREE_c_SESSION_DSCP_INUSE_AttributeUpdateAccept (c_SESSION_DSCP_INUSE_AttributeUpdateAccept* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SESSION_DSCP_INUSE_AttributeUpdateAccept_contents (&(sp->contents));

}

/* Free function for struct c_SESSION_DSCP_INUSE_AttributeUpdateReject */
void FREE_c_SESSION_DSCP_INUSE_AttributeUpdateReject (c_SESSION_DSCP_INUSE_AttributeUpdateReject* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SESSION_DSCP_INUSE_AttributeUpdateReject_contents (&(sp->contents));

}

/* Free function for struct c_SESSION_GMCDP_INCFG_ConfigurationRequest */
void FREE_c_SESSION_GMCDP_INCFG_ConfigurationRequest (c_SESSION_GMCDP_INCFG_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SESSION_GMCDP_INCFG_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_SESSION_GMCDP_INCFG_ConfigurationResponse */
void FREE_c_SESSION_GMCDP_INCFG_ConfigurationResponse (c_SESSION_GMCDP_INCFG_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SESSION_GMCDP_INCFG_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_CONN_DALMP_INCFG_ConfigurationRequest */
void FREE_c_CONN_DALMP_INCFG_ConfigurationRequest (c_CONN_DALMP_INCFG_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_DALMP_INCFG_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_CONN_DALMP_INCFG_ConfigurationResponse */
void FREE_c_CONN_DALMP_INCFG_ConfigurationResponse (c_CONN_DALMP_INCFG_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_DALMP_INCFG_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_CONN_DALMP_INUSE_Redirect */
void FREE_c_CONN_DALMP_INUSE_Redirect (c_CONN_DALMP_INUSE_Redirect* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_DALMP_INUSE_Redirect_contents (&(sp->contents));

}

/* Free function for struct c_CONN_DALMP_INUSE_ConnectionFailureReport */
void FREE_c_CONN_DALMP_INUSE_ConnectionFailureReport (c_CONN_DALMP_INUSE_ConnectionFailureReport* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_DALMP_INUSE_ConnectionFailureReport_contents (&(sp->contents));

}

/* Free function for struct c_CONN_DALMP_INUSE_ConnectionFailureReportAck */
void FREE_c_CONN_DALMP_INUSE_ConnectionFailureReportAck (c_CONN_DALMP_INUSE_ConnectionFailureReportAck* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_DALMP_INUSE_ConnectionFailureReportAck_contents (&(sp->contents));

}

/* Free function for struct c_CONN_DINSP_INCFG_ConfigurationRequest */
void FREE_c_CONN_DINSP_INCFG_ConfigurationRequest (c_CONN_DINSP_INCFG_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_DINSP_INCFG_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_CONN_DINSP_INCFG_ConfigurationResponse */
void FREE_c_CONN_DINSP_INCFG_ConfigurationResponse (c_CONN_DINSP_INCFG_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_DINSP_INCFG_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_CONN_DIDSP_INCFG_ConfigurationRequest */
void FREE_c_CONN_DIDSP_INCFG_ConfigurationRequest (c_CONN_DIDSP_INCFG_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_DIDSP_INCFG_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_CONN_DIDSP_INCFG_ConfigurationResponse */
void FREE_c_CONN_DIDSP_INCFG_ConfigurationResponse (c_CONN_DIDSP_INCFG_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_DIDSP_INCFG_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_CONN_DIDSP_INUSE_Page */
void FREE_c_CONN_DIDSP_INUSE_Page (c_CONN_DIDSP_INUSE_Page* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_CONN_DIDSP_INUSE_ConnectionRequest */
void FREE_c_CONN_DIDSP_INUSE_ConnectionRequest (c_CONN_DIDSP_INUSE_ConnectionRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_DIDSP_INUSE_ConnectionRequest_contents (&(sp->contents));

}

/* Free function for struct c_CONN_DIDSP_INUSE_ConnectionDeny */
void FREE_c_CONN_DIDSP_INUSE_ConnectionDeny (c_CONN_DIDSP_INUSE_ConnectionDeny* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_DIDSP_INUSE_ConnectionDeny_contents (&(sp->contents));

}

/* Free function for struct c_CONN_EISP_INCFG_ConfigurationRequest */
void FREE_c_CONN_EISP_INCFG_ConfigurationRequest (c_CONN_EISP_INCFG_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_EISP_INCFG_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_CONN_EISP_INCFG_ConfigurationResponse */
void FREE_c_CONN_EISP_INCFG_ConfigurationResponse (c_CONN_EISP_INCFG_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_EISP_INCFG_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_CONN_EISP_INUSE_Page */
void FREE_c_CONN_EISP_INUSE_Page (c_CONN_EISP_INUSE_Page* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_EISP_INUSE_Page_contents (&(sp->contents));

}

/* Free function for struct c_CONN_EISP_INUSE_ConnectionRequest */
void FREE_c_CONN_EISP_INUSE_ConnectionRequest (c_CONN_EISP_INUSE_ConnectionRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_EISP_INUSE_ConnectionRequest_contents (&(sp->contents));

}

/* Free function for struct c_CONN_EISP_INUSE_ConnectionDeny */
void FREE_c_CONN_EISP_INUSE_ConnectionDeny (c_CONN_EISP_INUSE_ConnectionDeny* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_EISP_INUSE_ConnectionDeny_contents (&(sp->contents));

}

/* Free function for struct c_CONN_EISP_INUSE_AttributeUpdateRequest */
void FREE_c_CONN_EISP_INUSE_AttributeUpdateRequest (c_CONN_EISP_INUSE_AttributeUpdateRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_EISP_INUSE_AttributeUpdateRequest_contents (&(sp->contents));

}

/* Free function for struct c_CONN_EISP_INUSE_AttributeUpdateAccept */
void FREE_c_CONN_EISP_INUSE_AttributeUpdateAccept (c_CONN_EISP_INUSE_AttributeUpdateAccept* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_EISP_INUSE_AttributeUpdateAccept_contents (&(sp->contents));

}

/* Free function for struct c_CONN_EISP_INUSE_AttributeUpdateReject */
void FREE_c_CONN_EISP_INUSE_AttributeUpdateReject (c_CONN_EISP_INUSE_AttributeUpdateReject* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_EISP_INUSE_AttributeUpdateReject_contents (&(sp->contents));

}

/* Free function for struct c_CONN_QISP_INCFG_ConfigurationRequest */
void FREE_c_CONN_QISP_INCFG_ConfigurationRequest (c_CONN_QISP_INCFG_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_QISP_INCFG_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_CONN_QISP_INCFG_ConfigurationResponse */
void FREE_c_CONN_QISP_INCFG_ConfigurationResponse (c_CONN_QISP_INCFG_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_QISP_INCFG_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_CONN_QISP_INUSE_Page */
void FREE_c_CONN_QISP_INUSE_Page (c_CONN_QISP_INUSE_Page* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_QISP_INUSE_Page_contents (&(sp->contents));

}

/* Free function for struct c_CONN_QISP_INUSE_ConnectionRequest */
void FREE_c_CONN_QISP_INUSE_ConnectionRequest (c_CONN_QISP_INUSE_ConnectionRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_QISP_INUSE_ConnectionRequest_contents (&(sp->contents));

}

/* Free function for struct c_CONN_QISP_INUSE_ConnectionDeny */
void FREE_c_CONN_QISP_INUSE_ConnectionDeny (c_CONN_QISP_INUSE_ConnectionDeny* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_QISP_INUSE_ConnectionDeny_contents (&(sp->contents));

}

/* Free function for struct c_CONN_QISP_INUSE_QuickPage */
void FREE_c_CONN_QISP_INUSE_QuickPage (c_CONN_QISP_INUSE_QuickPage* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_QISP_INUSE_QuickPage_contents (&(sp->contents));

}

/* Free function for struct c_CONN_QISP_INUSE_AttributeUpdateRequest */
void FREE_c_CONN_QISP_INUSE_AttributeUpdateRequest (c_CONN_QISP_INUSE_AttributeUpdateRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_QISP_INUSE_AttributeUpdateRequest_contents (&(sp->contents));

}

/* Free function for struct c_CONN_QISP_INUSE_AttributeUpdateAccept */
void FREE_c_CONN_QISP_INUSE_AttributeUpdateAccept (c_CONN_QISP_INUSE_AttributeUpdateAccept* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_QISP_INUSE_AttributeUpdateAccept_contents (&(sp->contents));

}

/* Free function for struct c_CONN_QISP_INUSE_AttributeUpdateReject */
void FREE_c_CONN_QISP_INUSE_AttributeUpdateReject (c_CONN_QISP_INUSE_AttributeUpdateReject* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_QISP_INUSE_AttributeUpdateReject_contents (&(sp->contents));

}

/* Free function for struct c_CONN_DCSP_INCFG_ConfigurationRequest */
void FREE_c_CONN_DCSP_INCFG_ConfigurationRequest (c_CONN_DCSP_INCFG_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_DCSP_INCFG_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_CONN_DCSP_INCFG_ConfigurationResponse */
void FREE_c_CONN_DCSP_INCFG_ConfigurationResponse (c_CONN_DCSP_INCFG_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_DCSP_INCFG_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_CONN_DCSP_INUSE_ConnectionClose */
void FREE_c_CONN_DCSP_INUSE_ConnectionClose (c_CONN_DCSP_INUSE_ConnectionClose* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_DCSP_INUSE_ConnectionClose_contents (&(sp->contents));

}

/* Free function for struct c_CONN_DRUP_INCFG_ConfigurationRequest */
void FREE_c_CONN_DRUP_INCFG_ConfigurationRequest (c_CONN_DRUP_INCFG_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_DRUP_INCFG_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_CONN_DRUP_INCFG_ConfigurationResponse */
void FREE_c_CONN_DRUP_INCFG_ConfigurationResponse (c_CONN_DRUP_INCFG_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_DRUP_INCFG_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_CONN_DRUP_INUSE_RouteUpdate */
void FREE_c_CONN_DRUP_INUSE_RouteUpdate (c_CONN_DRUP_INUSE_RouteUpdate* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_DRUP_INUSE_RouteUpdate_contents (&(sp->contents));

}

/* Free function for struct c_CONN_DRUP_INUSE_TrafficChannelAssignment */
void FREE_c_CONN_DRUP_INUSE_TrafficChannelAssignment (c_CONN_DRUP_INUSE_TrafficChannelAssignment* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents (&(sp->contents));

}

/* Free function for struct c_CONN_DRUP_INUSE_TrafficChannelComplete */
void FREE_c_CONN_DRUP_INUSE_TrafficChannelComplete (c_CONN_DRUP_INUSE_TrafficChannelComplete* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_DRUP_INUSE_TrafficChannelComplete_contents (&(sp->contents));

}

/* Free function for struct c_CONN_DRUP_INUSE_ResetReport */
void FREE_c_CONN_DRUP_INUSE_ResetReport (c_CONN_DRUP_INUSE_ResetReport* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_CONN_DRUP_INUSE_NeighborList */
void FREE_c_CONN_DRUP_INUSE_NeighborList (c_CONN_DRUP_INUSE_NeighborList* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_DRUP_INUSE_NeighborList_contents (&(sp->contents));

}

/* Free function for struct c_CONN_DRUP_INUSE_AttributeOverride */
void FREE_c_CONN_DRUP_INUSE_AttributeOverride (c_CONN_DRUP_INUSE_AttributeOverride* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_DRUP_INUSE_AttributeOverride_contents (&(sp->contents));

}

/* Free function for struct c_CONN_DRUP_INUSE_AttributeOverrideResponse */
void FREE_c_CONN_DRUP_INUSE_AttributeOverrideResponse (c_CONN_DRUP_INUSE_AttributeOverrideResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_DRUP_INUSE_AttributeOverrideResponse_contents (&(sp->contents));

}

/* Free function for struct c_CONN_DRUP_INUSE_RouteUpdateRequest */
void FREE_c_CONN_DRUP_INUSE_RouteUpdateRequest (c_CONN_DRUP_INUSE_RouteUpdateRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_DRUP_INUSE_RouteUpdateRequest_contents (&(sp->contents));

}

/* Free function for struct c_CONN_DRUP_INUSE_AttributeUpdateRequest */
void FREE_c_CONN_DRUP_INUSE_AttributeUpdateRequest (c_CONN_DRUP_INUSE_AttributeUpdateRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_DRUP_INUSE_AttributeUpdateRequest_contents (&(sp->contents));

}

/* Free function for struct c_CONN_DRUP_INUSE_AttributeUpdateAccept */
void FREE_c_CONN_DRUP_INUSE_AttributeUpdateAccept (c_CONN_DRUP_INUSE_AttributeUpdateAccept* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_DRUP_INUSE_AttributeUpdateAccept_contents (&(sp->contents));

}

/* Free function for struct c_CONN_DRUP_INUSE_AttributeUpdateReject */
void FREE_c_CONN_DRUP_INUSE_AttributeUpdateReject (c_CONN_DRUP_INUSE_AttributeUpdateReject* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_DRUP_INUSE_AttributeUpdateReject_contents (&(sp->contents));

}

/* Free function for struct c_CONN_MRUP_INCFG_ConfigurationRequest */
void FREE_c_CONN_MRUP_INCFG_ConfigurationRequest (c_CONN_MRUP_INCFG_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_MRUP_INCFG_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_CONN_MRUP_INCFG_ConfigurationResponse */
void FREE_c_CONN_MRUP_INCFG_ConfigurationResponse (c_CONN_MRUP_INCFG_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_MRUP_INCFG_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_CONN_MRUP_INUSE_RouteUpdate */
void FREE_c_CONN_MRUP_INUSE_RouteUpdate (c_CONN_MRUP_INUSE_RouteUpdate* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_MRUP_INUSE_RouteUpdate_contents (&(sp->contents));

}

/* Free function for struct c_CONN_MRUP_INUSE_TrafficChannelAssignment */
void FREE_c_CONN_MRUP_INUSE_TrafficChannelAssignment (c_CONN_MRUP_INUSE_TrafficChannelAssignment* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents (&(sp->contents));

}

/* Free function for struct c_CONN_MRUP_INUSE_TrafficChannelComplete */
void FREE_c_CONN_MRUP_INUSE_TrafficChannelComplete (c_CONN_MRUP_INUSE_TrafficChannelComplete* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_MRUP_INUSE_TrafficChannelComplete_contents (&(sp->contents));

}

/* Free function for struct c_CONN_MRUP_INUSE_ResetReport */
void FREE_c_CONN_MRUP_INUSE_ResetReport (c_CONN_MRUP_INUSE_ResetReport* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_CONN_MRUP_INUSE_NeighborList */
void FREE_c_CONN_MRUP_INUSE_NeighborList (c_CONN_MRUP_INUSE_NeighborList* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_MRUP_INUSE_NeighborList_contents (&(sp->contents));

}

/* Free function for struct c_CONN_MRUP_INUSE_RouteUpdateRequest */
void FREE_c_CONN_MRUP_INUSE_RouteUpdateRequest (c_CONN_MRUP_INUSE_RouteUpdateRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_MRUP_INUSE_RouteUpdateRequest_contents (&(sp->contents));

}

/* Free function for struct c_CONN_MRUP_INUSE_AttributeUpdateRequest */
void FREE_c_CONN_MRUP_INUSE_AttributeUpdateRequest (c_CONN_MRUP_INUSE_AttributeUpdateRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_MRUP_INUSE_AttributeUpdateRequest_contents (&(sp->contents));

}

/* Free function for struct c_CONN_MRUP_INUSE_AttributeUpdateAccept */
void FREE_c_CONN_MRUP_INUSE_AttributeUpdateAccept (c_CONN_MRUP_INUSE_AttributeUpdateAccept* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_MRUP_INUSE_AttributeUpdateAccept_contents (&(sp->contents));

}

/* Free function for struct c_CONN_MRUP_INUSE_AttributeUpdateReject */
void FREE_c_CONN_MRUP_INUSE_AttributeUpdateReject (c_CONN_MRUP_INUSE_AttributeUpdateReject* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_MRUP_INUSE_AttributeUpdateReject_contents (&(sp->contents));

}

/* Free function for struct c_CONN_DPCP_INCFG_ConfigurationRequest */
void FREE_c_CONN_DPCP_INCFG_ConfigurationRequest (c_CONN_DPCP_INCFG_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_DPCP_INCFG_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_CONN_DPCP_INCFG_ConfigurationResponse */
void FREE_c_CONN_DPCP_INCFG_ConfigurationResponse (c_CONN_DPCP_INCFG_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_DPCP_INCFG_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_CONN_OMP_INCFG_ConfigurationRequest */
void FREE_c_CONN_OMP_INCFG_ConfigurationRequest (c_CONN_OMP_INCFG_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_OMP_INCFG_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_CONN_OMP_INCFG_ConfigurationResponse */
void FREE_c_CONN_OMP_INCFG_ConfigurationResponse (c_CONN_OMP_INCFG_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_OMP_INCFG_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_CONN_OMP_INUSE_QuickConfig */
void FREE_c_CONN_OMP_INUSE_QuickConfig (c_CONN_OMP_INUSE_QuickConfig* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_OMP_INUSE_QuickConfig_contents (&(sp->contents));

}

/* Free function for struct c_CONN_OMP_INUSE_SectorParameters */
void FREE_c_CONN_OMP_INUSE_SectorParameters (c_CONN_OMP_INUSE_SectorParameters* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_CONN_OMP_INUSE_SectorParameters_contents (&(sp->contents));

}

/* Free function for struct c_SECURITY_DSP_INCFG_ConfigurationRequest */
void FREE_c_SECURITY_DSP_INCFG_ConfigurationRequest (c_SECURITY_DSP_INCFG_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SECURITY_DSP_INCFG_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_SECURITY_DSP_INCFG_ConfigurationResponse */
void FREE_c_SECURITY_DSP_INCFG_ConfigurationResponse (c_SECURITY_DSP_INCFG_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SECURITY_DSP_INCFG_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_SECURITY_GSP_INCFG_ConfigurationRequest */
void FREE_c_SECURITY_GSP_INCFG_ConfigurationRequest (c_SECURITY_GSP_INCFG_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SECURITY_GSP_INCFG_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_SECURITY_GSP_INCFG_ConfigurationResponse */
void FREE_c_SECURITY_GSP_INCFG_ConfigurationResponse (c_SECURITY_GSP_INCFG_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SECURITY_GSP_INCFG_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_SECURITY_DKEP_INCFG_ConfigurationRequest */
void FREE_c_SECURITY_DKEP_INCFG_ConfigurationRequest (c_SECURITY_DKEP_INCFG_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SECURITY_DKEP_INCFG_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_SECURITY_DKEP_INCFG_ConfigurationResponse */
void FREE_c_SECURITY_DKEP_INCFG_ConfigurationResponse (c_SECURITY_DKEP_INCFG_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SECURITY_DKEP_INCFG_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_SECURITY_DHKEP_INCFG_KeyRequest */
void FREE_c_SECURITY_DHKEP_INCFG_KeyRequest (c_SECURITY_DHKEP_INCFG_KeyRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SECURITY_DHKEP_INCFG_KeyRequest_contents (&(sp->contents));

}

/* Free function for struct c_SECURITY_DHKEP_INCFG_KeyResponse */
void FREE_c_SECURITY_DHKEP_INCFG_KeyResponse (c_SECURITY_DHKEP_INCFG_KeyResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SECURITY_DHKEP_INCFG_KeyResponse_contents (&(sp->contents));

}

/* Free function for struct c_SECURITY_DHKEP_INCFG_ANKeyComplete */
void FREE_c_SECURITY_DHKEP_INCFG_ANKeyComplete (c_SECURITY_DHKEP_INCFG_ANKeyComplete* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SECURITY_DHKEP_INCFG_ANKeyComplete_contents (&(sp->contents));

}

/* Free function for struct c_SECURITY_DHKEP_INCFG_ATKeyComplete */
void FREE_c_SECURITY_DHKEP_INCFG_ATKeyComplete (c_SECURITY_DHKEP_INCFG_ATKeyComplete* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SECURITY_DHKEP_INCFG_ATKeyComplete_contents (&(sp->contents));

}

/* Free function for struct c_SECURITY_DHKEP_INCFG_ConfigurationRequest */
void FREE_c_SECURITY_DHKEP_INCFG_ConfigurationRequest (c_SECURITY_DHKEP_INCFG_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SECURITY_DHKEP_INCFG_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_SECURITY_DHKEP_INCFG_ConfigurationResponse */
void FREE_c_SECURITY_DHKEP_INCFG_ConfigurationResponse (c_SECURITY_DHKEP_INCFG_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SECURITY_DHKEP_INCFG_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_SECURITY_DAP_INCFG_ConfigurationRequest */
void FREE_c_SECURITY_DAP_INCFG_ConfigurationRequest (c_SECURITY_DAP_INCFG_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SECURITY_DAP_INCFG_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_SECURITY_DAP_INCFG_ConfigurationResponse */
void FREE_c_SECURITY_DAP_INCFG_ConfigurationResponse (c_SECURITY_DAP_INCFG_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SECURITY_DAP_INCFG_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_SECURITY_SHA1AP_INCFG_ConfigurationRequest */
void FREE_c_SECURITY_SHA1AP_INCFG_ConfigurationRequest (c_SECURITY_SHA1AP_INCFG_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SECURITY_SHA1AP_INCFG_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_SECURITY_SHA1AP_INCFG_ConfigurationResponse */
void FREE_c_SECURITY_SHA1AP_INCFG_ConfigurationResponse (c_SECURITY_SHA1AP_INCFG_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SECURITY_SHA1AP_INCFG_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_SECURITY_DEP_INCFG_ConfigurationRequest */
void FREE_c_SECURITY_DEP_INCFG_ConfigurationRequest (c_SECURITY_DEP_INCFG_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SECURITY_DEP_INCFG_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_SECURITY_DEP_INCFG_ConfigurationResponse */
void FREE_c_SECURITY_DEP_INCFG_ConfigurationResponse (c_SECURITY_DEP_INCFG_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_SECURITY_DEP_INCFG_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_MAC_DCCMACP_INCFG_ConfigurationRequest */
void FREE_c_MAC_DCCMACP_INCFG_ConfigurationRequest (c_MAC_DCCMACP_INCFG_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_DCCMACP_INCFG_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_MAC_DCCMACP_INCFG_ConfigurationResponse */
void FREE_c_MAC_DCCMACP_INCFG_ConfigurationResponse (c_MAC_DCCMACP_INCFG_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_DCCMACP_INCFG_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_MAC_ECCMACP_INCFG_ConfigurationRequest */
void FREE_c_MAC_ECCMACP_INCFG_ConfigurationRequest (c_MAC_ECCMACP_INCFG_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_ECCMACP_INCFG_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_MAC_ECCMACP_INCFG_ConfigurationResponse */
void FREE_c_MAC_ECCMACP_INCFG_ConfigurationResponse (c_MAC_ECCMACP_INCFG_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_ECCMACP_INCFG_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_MAC_DACMACP_INCFG_ConfigurationRequest */
void FREE_c_MAC_DACMACP_INCFG_ConfigurationRequest (c_MAC_DACMACP_INCFG_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_DACMACP_INCFG_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_MAC_DACMACP_INCFG_ConfigurationResponse */
void FREE_c_MAC_DACMACP_INCFG_ConfigurationResponse (c_MAC_DACMACP_INCFG_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_DACMACP_INCFG_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_MAC_DACMACP_INUSE_ACAck */
void FREE_c_MAC_DACMACP_INUSE_ACAck (c_MAC_DACMACP_INUSE_ACAck* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_MAC_DACMACP_INUSE_AccessParameters */
void FREE_c_MAC_DACMACP_INUSE_AccessParameters (c_MAC_DACMACP_INUSE_AccessParameters* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_DACMACP_INUSE_AccessParameters_contents (&(sp->contents));

}

/* Free function for struct c_MAC_EACMACP_INCFG_ConfigurationRequest */
void FREE_c_MAC_EACMACP_INCFG_ConfigurationRequest (c_MAC_EACMACP_INCFG_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_EACMACP_INCFG_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_MAC_EACMACP_INCFG_ConfigurationResponse */
void FREE_c_MAC_EACMACP_INCFG_ConfigurationResponse (c_MAC_EACMACP_INCFG_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_EACMACP_INCFG_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_MAC_EACMACP_INUSE_ACAck */
void FREE_c_MAC_EACMACP_INUSE_ACAck (c_MAC_EACMACP_INUSE_ACAck* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_MAC_EACMACP_INUSE_AccessParameters */
void FREE_c_MAC_EACMACP_INUSE_AccessParameters (c_MAC_EACMACP_INUSE_AccessParameters* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_EACMACP_INUSE_AccessParameters_contents (&(sp->contents));

}

/* Free function for struct c_MAC_EACMACP_INUSE_AttributeUpdateRequest */
void FREE_c_MAC_EACMACP_INUSE_AttributeUpdateRequest (c_MAC_EACMACP_INUSE_AttributeUpdateRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_EACMACP_INUSE_AttributeUpdateRequest_contents (&(sp->contents));

}

/* Free function for struct c_MAC_EACMACP_INUSE_AttributeUpdateAccept */
void FREE_c_MAC_EACMACP_INUSE_AttributeUpdateAccept (c_MAC_EACMACP_INUSE_AttributeUpdateAccept* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_EACMACP_INUSE_AttributeUpdateAccept_contents (&(sp->contents));

}

/* Free function for struct c_MAC_EACMACP_INUSE_AttributeUpdateReject */
void FREE_c_MAC_EACMACP_INUSE_AttributeUpdateReject (c_MAC_EACMACP_INUSE_AttributeUpdateReject* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_EACMACP_INUSE_AttributeUpdateReject_contents (&(sp->contents));

}

/* Free function for struct c_MAC_DFTCMACP_INCFG_ConfigurationRequest */
void FREE_c_MAC_DFTCMACP_INCFG_ConfigurationRequest (c_MAC_DFTCMACP_INCFG_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_DFTCMACP_INCFG_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_MAC_DFTCMACP_INCFG_ConfigurationResponse */
void FREE_c_MAC_DFTCMACP_INCFG_ConfigurationResponse (c_MAC_DFTCMACP_INCFG_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_DFTCMACP_INCFG_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_MAC_DFTCMACP_INUSE_FixedModeEnable */
void FREE_c_MAC_DFTCMACP_INUSE_FixedModeEnable (c_MAC_DFTCMACP_INUSE_FixedModeEnable* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_DFTCMACP_INUSE_FixedModeEnable_contents (&(sp->contents));

}

/* Free function for struct c_MAC_DFTCMACP_INUSE_FixedModeXoff */
void FREE_c_MAC_DFTCMACP_INUSE_FixedModeXoff (c_MAC_DFTCMACP_INUSE_FixedModeXoff* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_MAC_EFTCMACP_INCFG_ConfigurationRequest */
void FREE_c_MAC_EFTCMACP_INCFG_ConfigurationRequest (c_MAC_EFTCMACP_INCFG_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_EFTCMACP_INCFG_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_MAC_EFTCMACP_INCFG_ConfigurationResponse */
void FREE_c_MAC_EFTCMACP_INCFG_ConfigurationResponse (c_MAC_EFTCMACP_INCFG_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_EFTCMACP_INCFG_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_MAC_EFTCMACP_INUSE_FixedModeEnable */
void FREE_c_MAC_EFTCMACP_INUSE_FixedModeEnable (c_MAC_EFTCMACP_INUSE_FixedModeEnable* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_EFTCMACP_INUSE_FixedModeEnable_contents (&(sp->contents));

}

/* Free function for struct c_MAC_EFTCMACP_INUSE_FixedModeXoff */
void FREE_c_MAC_EFTCMACP_INUSE_FixedModeXoff (c_MAC_EFTCMACP_INUSE_FixedModeXoff* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_MAC_EFTCMACP_INUSE_AttributeUpdateRequest */
void FREE_c_MAC_EFTCMACP_INUSE_AttributeUpdateRequest (c_MAC_EFTCMACP_INUSE_AttributeUpdateRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_EFTCMACP_INUSE_AttributeUpdateRequest_contents (&(sp->contents));

}

/* Free function for struct c_MAC_EFTCMACP_INUSE_AttributeUpdateAccept */
void FREE_c_MAC_EFTCMACP_INUSE_AttributeUpdateAccept (c_MAC_EFTCMACP_INUSE_AttributeUpdateAccept* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_EFTCMACP_INUSE_AttributeUpdateAccept_contents (&(sp->contents));

}

/* Free function for struct c_MAC_EFTCMACP_INUSE_AttributeUpdateReject */
void FREE_c_MAC_EFTCMACP_INUSE_AttributeUpdateReject (c_MAC_EFTCMACP_INUSE_AttributeUpdateReject* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_EFTCMACP_INUSE_AttributeUpdateReject_contents (&(sp->contents));

}

/* Free function for struct c_MAC_MFTCMACP_INCFG_ConfigurationRequest */
void FREE_c_MAC_MFTCMACP_INCFG_ConfigurationRequest (c_MAC_MFTCMACP_INCFG_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_MFTCMACP_INCFG_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_MAC_MFTCMACP_INCFG_ConfigurationResponse */
void FREE_c_MAC_MFTCMACP_INCFG_ConfigurationResponse (c_MAC_MFTCMACP_INCFG_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_MFTCMACP_INCFG_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_MAC_MFTCMACP_INUSE_FixedModeEnable */
void FREE_c_MAC_MFTCMACP_INUSE_FixedModeEnable (c_MAC_MFTCMACP_INUSE_FixedModeEnable* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_MFTCMACP_INUSE_FixedModeEnable_contents (&(sp->contents));

}

/* Free function for struct c_MAC_MFTCMACP_INUSE_FixedModeXoff */
void FREE_c_MAC_MFTCMACP_INUSE_FixedModeXoff (c_MAC_MFTCMACP_INUSE_FixedModeXoff* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_MAC_MFTCMACP_INUSE_AttributeUpdateRequest */
void FREE_c_MAC_MFTCMACP_INUSE_AttributeUpdateRequest (c_MAC_MFTCMACP_INUSE_AttributeUpdateRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_MFTCMACP_INUSE_AttributeUpdateRequest_contents (&(sp->contents));

}

/* Free function for struct c_MAC_MFTCMACP_INUSE_AttributeUpdateAccept */
void FREE_c_MAC_MFTCMACP_INUSE_AttributeUpdateAccept (c_MAC_MFTCMACP_INUSE_AttributeUpdateAccept* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_MFTCMACP_INUSE_AttributeUpdateAccept_contents (&(sp->contents));

}

/* Free function for struct c_MAC_MFTCMACP_INUSE_AttributeUpdateReject */
void FREE_c_MAC_MFTCMACP_INUSE_AttributeUpdateReject (c_MAC_MFTCMACP_INUSE_AttributeUpdateReject* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_MFTCMACP_INUSE_AttributeUpdateReject_contents (&(sp->contents));

}

/* Free function for struct c_MAC_DRTCMACP_INCFG_ConfigurationRequest */
void FREE_c_MAC_DRTCMACP_INCFG_ConfigurationRequest (c_MAC_DRTCMACP_INCFG_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_DRTCMACP_INCFG_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_MAC_DRTCMACP_INCFG_ConfigurationResponse */
void FREE_c_MAC_DRTCMACP_INCFG_ConfigurationResponse (c_MAC_DRTCMACP_INCFG_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_DRTCMACP_INCFG_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_MAC_DRTCMACP_INUSE_RTCAck */
void FREE_c_MAC_DRTCMACP_INUSE_RTCAck (c_MAC_DRTCMACP_INUSE_RTCAck* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_MAC_DRTCMACP_INUSE_BroadcastReverseRateLimit */
void FREE_c_MAC_DRTCMACP_INUSE_BroadcastReverseRateLimit (c_MAC_DRTCMACP_INUSE_BroadcastReverseRateLimit* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_DRTCMACP_INUSE_BroadcastReverseRateLimit_contents (&(sp->contents));

}

/* Free function for struct c_MAC_DRTCMACP_INUSE_UnicastReverseRateLimit */
void FREE_c_MAC_DRTCMACP_INUSE_UnicastReverseRateLimit (c_MAC_DRTCMACP_INUSE_UnicastReverseRateLimit* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_DRTCMACP_INUSE_UnicastReverseRateLimit_contents (&(sp->contents));

}

/* Free function for struct c_MAC_S1RTCMACP_INCFG_ConfigurationRequest */
void FREE_c_MAC_S1RTCMACP_INCFG_ConfigurationRequest (c_MAC_S1RTCMACP_INCFG_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_S1RTCMACP_INCFG_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_MAC_S1RTCMACP_INCFG_ConfigurationResponse */
void FREE_c_MAC_S1RTCMACP_INCFG_ConfigurationResponse (c_MAC_S1RTCMACP_INCFG_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_S1RTCMACP_INCFG_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_MAC_S1RTCMACP_INUSE_RTCAck */
void FREE_c_MAC_S1RTCMACP_INUSE_RTCAck (c_MAC_S1RTCMACP_INUSE_RTCAck* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_MAC_S1RTCMACP_INUSE_BroadcastReverseRateLimit */
void FREE_c_MAC_S1RTCMACP_INUSE_BroadcastReverseRateLimit (c_MAC_S1RTCMACP_INUSE_BroadcastReverseRateLimit* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_S1RTCMACP_INUSE_BroadcastReverseRateLimit_contents (&(sp->contents));

}

/* Free function for struct c_MAC_S1RTCMACP_INUSE_UnicastReverseRateLimit */
void FREE_c_MAC_S1RTCMACP_INUSE_UnicastReverseRateLimit (c_MAC_S1RTCMACP_INUSE_UnicastReverseRateLimit* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_S1RTCMACP_INUSE_UnicastReverseRateLimit_contents (&(sp->contents));

}

/* Free function for struct c_MAC_S1RTCMACP_INUSE_AttributeUpdateRequest */
void FREE_c_MAC_S1RTCMACP_INUSE_AttributeUpdateRequest (c_MAC_S1RTCMACP_INUSE_AttributeUpdateRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_S1RTCMACP_INUSE_AttributeUpdateRequest_contents (&(sp->contents));

}

/* Free function for struct c_MAC_S1RTCMACP_INUSE_AttributeUpdateAccept */
void FREE_c_MAC_S1RTCMACP_INUSE_AttributeUpdateAccept (c_MAC_S1RTCMACP_INUSE_AttributeUpdateAccept* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_S1RTCMACP_INUSE_AttributeUpdateAccept_contents (&(sp->contents));

}

/* Free function for struct c_MAC_S1RTCMACP_INUSE_AttributeUpdateReject */
void FREE_c_MAC_S1RTCMACP_INUSE_AttributeUpdateReject (c_MAC_S1RTCMACP_INUSE_AttributeUpdateReject* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_S1RTCMACP_INUSE_AttributeUpdateReject_contents (&(sp->contents));

}

/* Free function for struct c_MAC_S3RTCMACP_INCFG_ConfigurationRequest */
void FREE_c_MAC_S3RTCMACP_INCFG_ConfigurationRequest (c_MAC_S3RTCMACP_INCFG_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_S3RTCMACP_INCFG_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_MAC_S3RTCMACP_INCFG_ConfigurationResponse */
void FREE_c_MAC_S3RTCMACP_INCFG_ConfigurationResponse (c_MAC_S3RTCMACP_INCFG_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_S3RTCMACP_INCFG_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_MAC_S3RTCMACP_INUSE_RTCAck */
void FREE_c_MAC_S3RTCMACP_INUSE_RTCAck (c_MAC_S3RTCMACP_INUSE_RTCAck* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_MAC_S3RTCMACP_INUSE_Request */
void FREE_c_MAC_S3RTCMACP_INUSE_Request (c_MAC_S3RTCMACP_INUSE_Request* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_S3RTCMACP_INUSE_Request_contents (&(sp->contents));

}

/* Free function for struct c_MAC_S3RTCMACP_INUSE_Grant */
void FREE_c_MAC_S3RTCMACP_INUSE_Grant (c_MAC_S3RTCMACP_INUSE_Grant* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_S3RTCMACP_INUSE_Grant_contents (&(sp->contents));

}

/* Free function for struct c_MAC_S3RTCMACP_INUSE_AttributeUpdateRequest */
void FREE_c_MAC_S3RTCMACP_INUSE_AttributeUpdateRequest (c_MAC_S3RTCMACP_INUSE_AttributeUpdateRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_S3RTCMACP_INUSE_AttributeUpdateRequest_contents (&(sp->contents));

}

/* Free function for struct c_MAC_S3RTCMACP_INUSE_AttributeUpdateAccept */
void FREE_c_MAC_S3RTCMACP_INUSE_AttributeUpdateAccept (c_MAC_S3RTCMACP_INUSE_AttributeUpdateAccept* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_S3RTCMACP_INUSE_AttributeUpdateAccept_contents (&(sp->contents));

}

/* Free function for struct c_MAC_S3RTCMACP_INUSE_AttributeUpdateReject */
void FREE_c_MAC_S3RTCMACP_INUSE_AttributeUpdateReject (c_MAC_S3RTCMACP_INUSE_AttributeUpdateReject* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_S3RTCMACP_INUSE_AttributeUpdateReject_contents (&(sp->contents));

}

/* Free function for struct c_MAC_MRTCMACP_INCFG_ConfigurationRequest */
void FREE_c_MAC_MRTCMACP_INCFG_ConfigurationRequest (c_MAC_MRTCMACP_INCFG_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_MRTCMACP_INCFG_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_MAC_MRTCMACP_INCFG_ConfigurationResponse */
void FREE_c_MAC_MRTCMACP_INCFG_ConfigurationResponse (c_MAC_MRTCMACP_INCFG_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_MRTCMACP_INCFG_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_MAC_MRTCMACP_INUSE_RTCAck */
void FREE_c_MAC_MRTCMACP_INUSE_RTCAck (c_MAC_MRTCMACP_INUSE_RTCAck* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_MRTCMACP_INUSE_RTCAck_contents (&(sp->contents));

}

/* Free function for struct c_MAC_MRTCMACP_INUSE_CarrierRequest */
void FREE_c_MAC_MRTCMACP_INUSE_CarrierRequest (c_MAC_MRTCMACP_INUSE_CarrierRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_MRTCMACP_INUSE_CarrierRequest_contents (&(sp->contents));

}

/* Free function for struct c_MAC_MRTCMACP_INUSE_ReverseCDMAChannelDropped */
void FREE_c_MAC_MRTCMACP_INUSE_ReverseCDMAChannelDropped (c_MAC_MRTCMACP_INUSE_ReverseCDMAChannelDropped* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_MRTCMACP_INUSE_ReverseCDMAChannelDropped_contents (&(sp->contents));

}

/* Free function for struct c_MAC_MRTCMACP_INUSE_ReverseCDMAChannelDroppedAck */
void FREE_c_MAC_MRTCMACP_INUSE_ReverseCDMAChannelDroppedAck (c_MAC_MRTCMACP_INUSE_ReverseCDMAChannelDroppedAck* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_MRTCMACP_INUSE_ReverseCDMAChannelDroppedAck_contents (&(sp->contents));

}

/* Free function for struct c_MAC_MRTCMACP_INUSE_Request */
void FREE_c_MAC_MRTCMACP_INUSE_Request (c_MAC_MRTCMACP_INUSE_Request* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_MRTCMACP_INUSE_Request_contents (&(sp->contents));

}

/* Free function for struct c_MAC_MRTCMACP_INUSE_Grant */
void FREE_c_MAC_MRTCMACP_INUSE_Grant (c_MAC_MRTCMACP_INUSE_Grant* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_MRTCMACP_INUSE_Grant_contents (&(sp->contents));

}

/* Free function for struct c_MAC_MRTCMACP_INUSE_AttributeUpdateRequest */
void FREE_c_MAC_MRTCMACP_INUSE_AttributeUpdateRequest (c_MAC_MRTCMACP_INUSE_AttributeUpdateRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_MRTCMACP_INUSE_AttributeUpdateRequest_contents (&(sp->contents));

}

/* Free function for struct c_MAC_MRTCMACP_INUSE_AttributeUpdateAccept */
void FREE_c_MAC_MRTCMACP_INUSE_AttributeUpdateAccept (c_MAC_MRTCMACP_INUSE_AttributeUpdateAccept* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_MRTCMACP_INUSE_AttributeUpdateAccept_contents (&(sp->contents));

}

/* Free function for struct c_MAC_MRTCMACP_INUSE_AttributeUpdateReject */
void FREE_c_MAC_MRTCMACP_INUSE_AttributeUpdateReject (c_MAC_MRTCMACP_INUSE_AttributeUpdateReject* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_MAC_MRTCMACP_INUSE_AttributeUpdateReject_contents (&(sp->contents));

}

/* Free function for struct c_PHYS01_DS0S1PLPI_INCFG_ConfigurationRequest */
void FREE_c_PHYS01_DS0S1PLPI_INCFG_ConfigurationRequest (c_PHYS01_DS0S1PLPI_INCFG_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_PHYS01_DS0S1PLPI_INCFG_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_PHYS01_DS0S1PLPI_INCFG_ConfigurationResponse */
void FREE_c_PHYS01_DS0S1PLPI_INCFG_ConfigurationResponse (c_PHYS01_DS0S1PLPI_INCFG_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_PHYS01_DS0S1PLPI_INCFG_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_PHYS2_S2PLPI_INCFG_ConfigurationRequest */
void FREE_c_PHYS2_S2PLPI_INCFG_ConfigurationRequest (c_PHYS2_S2PLPI_INCFG_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_PHYS2_S2PLPI_INCFG_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_PHYS2_S2PLPI_INCFG_ConfigurationResponse */
void FREE_c_PHYS2_S2PLPI_INCFG_ConfigurationResponse (c_PHYS2_S2PLPI_INCFG_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_PHYS2_S2PLPI_INCFG_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_PHYS3_S3PLPI_INCFG_ConfigurationRequest */
void FREE_c_PHYS3_S3PLPI_INCFG_ConfigurationRequest (c_PHYS3_S3PLPI_INCFG_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_PHYS3_S3PLPI_INCFG_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_PHYS3_S3PLPI_INCFG_ConfigurationResponse */
void FREE_c_PHYS3_S3PLPI_INCFG_ConfigurationResponse (c_PHYS3_S3PLPI_INCFG_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_PHYS3_S3PLPI_INCFG_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_PHYS3_S3PLPI_INUSE_AttributeUpdateRequest */
void FREE_c_PHYS3_S3PLPI_INUSE_AttributeUpdateRequest (c_PHYS3_S3PLPI_INUSE_AttributeUpdateRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_PHYS3_S3PLPI_INUSE_AttributeUpdateRequest_contents (&(sp->contents));

}

/* Free function for struct c_PHYS3_S3PLPI_INUSE_AttributeUpdateAccept */
void FREE_c_PHYS3_S3PLPI_INUSE_AttributeUpdateAccept (c_PHYS3_S3PLPI_INUSE_AttributeUpdateAccept* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_PHYS3_S3PLPI_INUSE_AttributeUpdateAccept_contents (&(sp->contents));

}

/* Free function for struct c_PHYS3_S3PLPI_INUSE_AttributeUpdateReject */
void FREE_c_PHYS3_S3PLPI_INUSE_AttributeUpdateReject (c_PHYS3_S3PLPI_INUSE_AttributeUpdateReject* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_PHYS3_S3PLPI_INUSE_AttributeUpdateReject_contents (&(sp->contents));

}

/* Free function for struct c_GEN_GCP_ConfigurationRequest */
void FREE_c_GEN_GCP_ConfigurationRequest (c_GEN_GCP_ConfigurationRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_GEN_GCP_ConfigurationRequest_contents (&(sp->contents));

}

/* Free function for struct c_GEN_GCP_ConfigurationResponse */
void FREE_c_GEN_GCP_ConfigurationResponse (c_GEN_GCP_ConfigurationResponse* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_GEN_GCP_ConfigurationResponse_contents (&(sp->contents));

}

/* Free function for struct c_GEN_GAUP_AttributeUpdateRequest */
void FREE_c_GEN_GAUP_AttributeUpdateRequest (c_GEN_GAUP_AttributeUpdateRequest* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_GEN_GAUP_AttributeUpdateRequest_contents (&(sp->contents));

}

/* Free function for struct c_GEN_GAUP_AttributeUpdateAccept */
void FREE_c_GEN_GAUP_AttributeUpdateAccept (c_GEN_GAUP_AttributeUpdateAccept* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_GEN_GAUP_AttributeUpdateAccept_contents (&(sp->contents));

}

/* Free function for struct c_GEN_GAUP_AttributeUpdateReject */
void FREE_c_GEN_GAUP_AttributeUpdateReject (c_GEN_GAUP_AttributeUpdateReject* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_GEN_GAUP_AttributeUpdateReject_contents (&(sp->contents));

}

/* Free function for variable-sized sequence c_Air_Attribute_Response_16_ValueIDs */
void FREE_c_Air_Attribute_Response_16_ValueIDs (c_Air_Attribute_Response_16_ValueIDs* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Attribute_Response_16 */
void FREE_c_Air_Attribute_Response_16 (c_Air_Attribute_Response_16* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->ValueIDs.data) {EDFree (sp->ValueIDs.data); sp->ValueIDs.data = NULL; sp->ValueIDs.allocatedItems=0; /*FR02A*/}

}

/* Free function for variable-sized sequence c_Air_Attribute_Response_8_ValueIDs */
void FREE_c_Air_Attribute_Response_8_ValueIDs (c_Air_Attribute_Response_8_ValueIDs* sp) {
	int i;
	for (i=0; i<sp->items; i++) {
	}

	if (sp->data) {EDFree (sp->data); sp->data=NULL; sp->allocatedItems = 0;/*FR03*/}

}
/* Free function for struct c_Air_Attribute_Response_8 */
void FREE_c_Air_Attribute_Response_8 (c_Air_Attribute_Response_8* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->ValueIDs.data) {EDFree (sp->ValueIDs.data); sp->ValueIDs.data = NULL; sp->ValueIDs.allocatedItems=0; /*FR02A*/}

}

/* Free function for struct c_GenericTLV_cs0024 */
void FREE_c_GenericTLV_cs0024 (c_GenericTLV_cs0024* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->TLV_Data.value != NULL) {
		EDFree (sp->TLV_Data.value);
		sp->TLV_Data.value = NULL;
	}
	sp->TLV_Data.usedBits = 0;

}

/* SETITEMS commands for type 'c_Air_Multi_Flow_Packet_Application_Attributes_SupportedHigherLayerProtocols_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multi_Flow_Packet_Application_Attributes_SupportedHigherLayerProtocols_data01 (c_Air_Multi_Flow_Packet_Application_Attributes_SupportedHigherLayerProtocols_data01* sequence, int desiredItems)
{
	int i, i0;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multi_Flow_Packet_Application_Attributes_SupportedHigherLayerProtocols_data01_data** tmp;
		tmp = (c_Air_Multi_Flow_Packet_Application_Attributes_SupportedHigherLayerProtocols_data01_data**)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_SupportedHigherLayerProtocols_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_SupportedHigherLayerProtocols_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multi_Flow_Packet_Application_Attributes_SupportedHigherLayerProtocols_data01_data*)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_SupportedHigherLayerProtocols_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_SupportedHigherLayerProtocols_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->ProtocolCount) = 0;
			sequence->data[i]->data02.items = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				for (i0=0; i0<sequence->data[i]->data02.items; i0++) {
					EDFree (sequence->data[i]->data02.data[i0]);
					sequence->data[i]->data02.data[i0] = NULL;
				}
				if (sequence->data[i]->data02.data) {EDFree (sequence->data[i]->data02.data); sequence->data[i]->data02.data = NULL; sequence->data[i]->data02.allocatedItems=0; /*FR02A*/}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multi_Flow_Packet_Application_Attributes_SupportedHigherLayerProtocols_data01_data */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_SupportedHigherLayerProtocols_data01_data (c_Air_Multi_Flow_Packet_Application_Attributes_SupportedHigherLayerProtocols_data01_data* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data02.items; i0++) {
		EDFree (sp->data02.data[i0]);
		sp->data02.data[i0] = NULL;
	}
	if (sp->data02.data) {EDFree (sp->data02.data); sp->data02.data = NULL; sp->data02.allocatedItems=0; /*FR02A*/}

}

/* SETITEMS commands for type 'c_Air_Multi_Flow_Packet_Application_Attributes_SupportedHigherLayerProtocols_data01_data_data02'. Existing items are not changed. */
int SETITEMS_c_Air_Multi_Flow_Packet_Application_Attributes_SupportedHigherLayerProtocols_data01_data_data02 (c_Air_Multi_Flow_Packet_Application_Attributes_SupportedHigherLayerProtocols_data01_data_data02* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multi_Flow_Packet_Application_Attributes_SupportedHigherLayerProtocols_data01_data_data02_data** tmp;
		tmp = (c_Air_Multi_Flow_Packet_Application_Attributes_SupportedHigherLayerProtocols_data01_data_data02_data**)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_SupportedHigherLayerProtocols_data01_data_data02_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_SupportedHigherLayerProtocols_data01_data_data02_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multi_Flow_Packet_Application_Attributes_SupportedHigherLayerProtocols_data01_data_data02_data*)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_SupportedHigherLayerProtocols_data01_data_data02_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_SupportedHigherLayerProtocols_data01_data_data02_data));
			(sequence->data[i]->ProtocolIdentifier) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multi_Flow_Packet_Application_Attributes_SupportedHigherLayerProtocols_data01_data_data02_data */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_SupportedHigherLayerProtocols_data01_data_data02_data (c_Air_Multi_Flow_Packet_Application_Attributes_SupportedHigherLayerProtocols_data01_data_data02_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multi_Flow_Packet_Application_Attributes_ATSupportedQoSProfiles_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multi_Flow_Packet_Application_Attributes_ATSupportedQoSProfiles_data01 (c_Air_Multi_Flow_Packet_Application_Attributes_ATSupportedQoSProfiles_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multi_Flow_Packet_Application_Attributes_ATSupportedQoSProfiles_data01_data** tmp;
		tmp = (c_Air_Multi_Flow_Packet_Application_Attributes_ATSupportedQoSProfiles_data01_data**)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_ATSupportedQoSProfiles_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_ATSupportedQoSProfiles_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multi_Flow_Packet_Application_Attributes_ATSupportedQoSProfiles_data01_data*)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_ATSupportedQoSProfiles_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_ATSupportedQoSProfiles_data01_data));
			(sequence->data[i]->ProfileType) = 0;
			(sequence->data[i]->ProfileLength) = 0;
			sequence->data[i]->ProfileValue.value = NULL;
			sequence->data[i]->ProfileValue.usedBits = 0;
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->ProfileValue.value != NULL) {
					EDFree (sequence->data[i]->ProfileValue.value);
					sequence->data[i]->ProfileValue.value = NULL;
				}
				sequence->data[i]->ProfileValue.usedBits = 0;
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multi_Flow_Packet_Application_Attributes_ATSupportedQoSProfiles_data01_data */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_ATSupportedQoSProfiles_data01_data (c_Air_Multi_Flow_Packet_Application_Attributes_ATSupportedQoSProfiles_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->ProfileValue.value != NULL) {
		EDFree (sp->ProfileValue.value);
		sp->ProfileValue.value = NULL;
	}
	sp->ProfileValue.usedBits = 0;

}

/* SETITEMS commands for type 'c_Air_Multi_Flow_Packet_Application_Attributes_ANSupportedQoSProfiles_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multi_Flow_Packet_Application_Attributes_ANSupportedQoSProfiles_data01 (c_Air_Multi_Flow_Packet_Application_Attributes_ANSupportedQoSProfiles_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multi_Flow_Packet_Application_Attributes_ANSupportedQoSProfiles_data01_data** tmp;
		tmp = (c_Air_Multi_Flow_Packet_Application_Attributes_ANSupportedQoSProfiles_data01_data**)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_ANSupportedQoSProfiles_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_ANSupportedQoSProfiles_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multi_Flow_Packet_Application_Attributes_ANSupportedQoSProfiles_data01_data*)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_ANSupportedQoSProfiles_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_ANSupportedQoSProfiles_data01_data));
			(sequence->data[i]->ProfileType) = 0;
			(sequence->data[i]->ProfileLength) = 0;
			sequence->data[i]->ProfileValue.value = NULL;
			sequence->data[i]->ProfileValue.usedBits = 0;
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->ProfileValue.value != NULL) {
					EDFree (sequence->data[i]->ProfileValue.value);
					sequence->data[i]->ProfileValue.value = NULL;
				}
				sequence->data[i]->ProfileValue.usedBits = 0;
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multi_Flow_Packet_Application_Attributes_ANSupportedQoSProfiles_data01_data */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_ANSupportedQoSProfiles_data01_data (c_Air_Multi_Flow_Packet_Application_Attributes_ANSupportedQoSProfiles_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->ProfileValue.value != NULL) {
		EDFree (sp->ProfileValue.value);
		sp->ProfileValue.value = NULL;
	}
	sp->ProfileValue.usedBits = 0;

}

/* SETITEMS commands for type 'c_Air_Multi_Flow_Packet_Application_Attributes_MaxRLPFlows_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multi_Flow_Packet_Application_Attributes_MaxRLPFlows_data01 (c_Air_Multi_Flow_Packet_Application_Attributes_MaxRLPFlows_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multi_Flow_Packet_Application_Attributes_MaxRLPFlows_data01_data** tmp;
		tmp = (c_Air_Multi_Flow_Packet_Application_Attributes_MaxRLPFlows_data01_data**)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_MaxRLPFlows_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_MaxRLPFlows_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multi_Flow_Packet_Application_Attributes_MaxRLPFlows_data01_data*)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_MaxRLPFlows_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_MaxRLPFlows_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->MaxNumRLPFlowsFwd) = 0;
			(sequence->data[i]->MaxNumRLPFlowsRev) = 0;
			(sequence->data[i]->MaxActivatedRLPFlowsFwd) = 0;
			(sequence->data[i]->MaxActivatedRLPFlowsRev) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multi_Flow_Packet_Application_Attributes_MaxRLPFlows_data01_data */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_MaxRLPFlows_data01_data (c_Air_Multi_Flow_Packet_Application_Attributes_MaxRLPFlows_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multi_Flow_Packet_Application_Attributes_MaxReservations_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multi_Flow_Packet_Application_Attributes_MaxReservations_data01 (c_Air_Multi_Flow_Packet_Application_Attributes_MaxReservations_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multi_Flow_Packet_Application_Attributes_MaxReservations_data01_data** tmp;
		tmp = (c_Air_Multi_Flow_Packet_Application_Attributes_MaxReservations_data01_data**)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_MaxReservations_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_MaxReservations_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multi_Flow_Packet_Application_Attributes_MaxReservations_data01_data*)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_MaxReservations_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_MaxReservations_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->MaxNumReservationsFwd) = 0;
			(sequence->data[i]->MaxNumReservationsRev) = 0;
			(sequence->data[i]->MaxNumOpenReservationsFwd) = 0;
			(sequence->data[i]->MaxNumOpenReservationsRev) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multi_Flow_Packet_Application_Attributes_MaxReservations_data01_data */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_MaxReservations_data01_data (c_Air_Multi_Flow_Packet_Application_Attributes_MaxReservations_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationFwd_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationFwd_data01 (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationFwd_data01* sequence, int desiredItems)
{
	int i, i0;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationFwd_data01_data** tmp;
		tmp = (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationFwd_data01_data**)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationFwd_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationFwd_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationFwd_data01_data*)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationFwd_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationFwd_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->Active) = 0;
			sequence->data[i]->data02.items = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				for (i0=0; i0<sequence->data[i]->data02.items; i0++) {
					if (sequence->data[i]->data02.data[i0]->RLPID.value != NULL) {
						EDFree (sequence->data[i]->data02.data[i0]->RLPID.value);
						sequence->data[i]->data02.data[i0]->RLPID.value = NULL;
					}
					sequence->data[i]->data02.data[i0]->RLPID.usedBits = 0;
					EDFree (sequence->data[i]->data02.data[i0]);
					sequence->data[i]->data02.data[i0] = NULL;
				}
				if (sequence->data[i]->data02.data) {EDFree (sequence->data[i]->data02.data); sequence->data[i]->data02.data = NULL; sequence->data[i]->data02.allocatedItems=0; /*FR02A*/}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationFwd_data01_data */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationFwd_data01_data (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationFwd_data01_data* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data02.items; i0++) {
		if (sp->data02.data[i0]->RLPID.value != NULL) {
			EDFree (sp->data02.data[i0]->RLPID.value);
			sp->data02.data[i0]->RLPID.value = NULL;
		}
		sp->data02.data[i0]->RLPID.usedBits = 0;
		EDFree (sp->data02.data[i0]);
		sp->data02.data[i0] = NULL;
	}
	if (sp->data02.data) {EDFree (sp->data02.data); sp->data02.data = NULL; sp->data02.allocatedItems=0; /*FR02A*/}

}

/* SETITEMS commands for type 'c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationFwd_data01_data_data02'. Existing items are not changed. */
int SETITEMS_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationFwd_data01_data_data02 (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationFwd_data01_data_data02* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationFwd_data01_data_data02_data** tmp;
		tmp = (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationFwd_data01_data_data02_data**)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationFwd_data01_data_data02_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationFwd_data01_data_data02_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationFwd_data01_data_data02_data*)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationFwd_data01_data_data02_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationFwd_data01_data_data02_data));
			(sequence->data[i]->SequenceLength) = 0;
			(sequence->data[i]->RLPIDLength) = 0;
			sequence->data[i]->RLPID.value = NULL;
			sequence->data[i]->RLPID.usedBits = 0;
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->RLPID.value != NULL) {
					EDFree (sequence->data[i]->RLPID.value);
					sequence->data[i]->RLPID.value = NULL;
				}
				sequence->data[i]->RLPID.usedBits = 0;
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationFwd_data01_data_data02_data */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationFwd_data01_data_data02_data (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationFwd_data01_data_data02_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->RLPID.value != NULL) {
		EDFree (sp->RLPID.value);
		sp->RLPID.value = NULL;
	}
	sp->RLPID.usedBits = 0;

}

/* SETITEMS commands for type 'c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationRev_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationRev_data01 (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationRev_data01* sequence, int desiredItems)
{
	int i, i0;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationRev_data01_data** tmp;
		tmp = (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationRev_data01_data**)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationRev_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationRev_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationRev_data01_data*)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationRev_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationRev_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->Active) = 0;
			sequence->data[i]->data02.items = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				for (i0=0; i0<sequence->data[i]->data02.items; i0++) {
					if (sequence->data[i]->data02.data[i0]->RLPID.value != NULL) {
						EDFree (sequence->data[i]->data02.data[i0]->RLPID.value);
						sequence->data[i]->data02.data[i0]->RLPID.value = NULL;
					}
					sequence->data[i]->data02.data[i0]->RLPID.usedBits = 0;
					EDFree (sequence->data[i]->data02.data[i0]);
					sequence->data[i]->data02.data[i0] = NULL;
				}
				if (sequence->data[i]->data02.data) {EDFree (sequence->data[i]->data02.data); sequence->data[i]->data02.data = NULL; sequence->data[i]->data02.allocatedItems=0; /*FR02A*/}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationRev_data01_data */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationRev_data01_data (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationRev_data01_data* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data02.items; i0++) {
		if (sp->data02.data[i0]->RLPID.value != NULL) {
			EDFree (sp->data02.data[i0]->RLPID.value);
			sp->data02.data[i0]->RLPID.value = NULL;
		}
		sp->data02.data[i0]->RLPID.usedBits = 0;
		EDFree (sp->data02.data[i0]);
		sp->data02.data[i0] = NULL;
	}
	if (sp->data02.data) {EDFree (sp->data02.data); sp->data02.data = NULL; sp->data02.allocatedItems=0; /*FR02A*/}

}

/* SETITEMS commands for type 'c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationRev_data01_data_data02'. Existing items are not changed. */
int SETITEMS_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationRev_data01_data_data02 (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationRev_data01_data_data02* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationRev_data01_data_data02_data** tmp;
		tmp = (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationRev_data01_data_data02_data**)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationRev_data01_data_data02_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationRev_data01_data_data02_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationRev_data01_data_data02_data*)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationRev_data01_data_data02_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationRev_data01_data_data02_data));
			(sequence->data[i]->SequenceLength) = 0;
			(sequence->data[i]->RLPIDLength) = 0;
			sequence->data[i]->RLPID.value = NULL;
			sequence->data[i]->RLPID.usedBits = 0;
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->RLPID.value != NULL) {
					EDFree (sequence->data[i]->RLPID.value);
					sequence->data[i]->RLPID.value = NULL;
				}
				sequence->data[i]->RLPID.usedBits = 0;
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationRev_data01_data_data02_data */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationRev_data01_data_data02_data (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationRev_data01_data_data02_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->RLPID.value != NULL) {
		EDFree (sp->RLPID.value);
		sp->RLPID.value = NULL;
	}
	sp->RLPID.usedBits = 0;

}

/* SETITEMS commands for type 'c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersFwd_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersFwd_data01 (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersFwd_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersFwd_data01_data** tmp;
		tmp = (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersFwd_data01_data**)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersFwd_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersFwd_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersFwd_data01_data*)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersFwd_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersFwd_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->AbortTimer) = 0;
			(sequence->data[i]->FlushTimer) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersFwd_data01_data */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersFwd_data01_data (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersFwd_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersRev_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersRev_data01 (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersRev_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersRev_data01_data** tmp;
		tmp = (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersRev_data01_data**)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersRev_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersRev_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersRev_data01_data*)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersRev_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersRev_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->AbortTimer) = 0;
			(sequence->data[i]->FlushTimer) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersRev_data01_data */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersRev_data01_data (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersRev_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationFwd_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationFwd_data01 (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationFwd_data01* sequence, int desiredItems)
{
	int i, i0;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationFwd_data01_data** tmp;
		tmp = (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationFwd_data01_data**)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationFwd_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationFwd_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationFwd_data01_data*)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationFwd_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationFwd_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->ReservationCount) = 0;
			sequence->data[i]->data02.items = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				for (i0=0; i0<sequence->data[i]->data02.items; i0++) {
					EDFree (sequence->data[i]->data02.data[i0]);
					sequence->data[i]->data02.data[i0] = NULL;
				}
				if (sequence->data[i]->data02.data) {EDFree (sequence->data[i]->data02.data); sequence->data[i]->data02.data = NULL; sequence->data[i]->data02.allocatedItems=0; /*FR02A*/}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationFwd_data01_data */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationFwd_data01_data (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationFwd_data01_data* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data02.items; i0++) {
		EDFree (sp->data02.data[i0]);
		sp->data02.data[i0] = NULL;
	}
	if (sp->data02.data) {EDFree (sp->data02.data); sp->data02.data = NULL; sp->data02.allocatedItems=0; /*FR02A*/}

}

/* SETITEMS commands for type 'c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationFwd_data01_data_data02'. Existing items are not changed. */
int SETITEMS_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationFwd_data01_data_data02 (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationFwd_data01_data_data02* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationFwd_data01_data_data02_data** tmp;
		tmp = (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationFwd_data01_data_data02_data**)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationFwd_data01_data_data02_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationFwd_data01_data_data02_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationFwd_data01_data_data02_data*)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationFwd_data01_data_data02_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationFwd_data01_data_data02_data));
			(sequence->data[i]->ReservationLabel) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationFwd_data01_data_data02_data */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationFwd_data01_data_data02_data (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationFwd_data01_data_data02_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationRev_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationRev_data01 (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationRev_data01* sequence, int desiredItems)
{
	int i, i0;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationRev_data01_data** tmp;
		tmp = (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationRev_data01_data**)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationRev_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationRev_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationRev_data01_data*)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationRev_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationRev_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->ReservationCount) = 0;
			sequence->data[i]->data02.items = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				for (i0=0; i0<sequence->data[i]->data02.items; i0++) {
					EDFree (sequence->data[i]->data02.data[i0]);
					sequence->data[i]->data02.data[i0] = NULL;
				}
				if (sequence->data[i]->data02.data) {EDFree (sequence->data[i]->data02.data); sequence->data[i]->data02.data = NULL; sequence->data[i]->data02.allocatedItems=0; /*FR02A*/}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationRev_data01_data */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationRev_data01_data (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationRev_data01_data* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data02.items; i0++) {
		EDFree (sp->data02.data[i0]);
		sp->data02.data[i0] = NULL;
	}
	if (sp->data02.data) {EDFree (sp->data02.data); sp->data02.data = NULL; sp->data02.allocatedItems=0; /*FR02A*/}

}

/* SETITEMS commands for type 'c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationRev_data01_data_data02'. Existing items are not changed. */
int SETITEMS_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationRev_data01_data_data02 (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationRev_data01_data_data02* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationRev_data01_data_data02_data** tmp;
		tmp = (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationRev_data01_data_data02_data**)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationRev_data01_data_data02_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationRev_data01_data_data02_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationRev_data01_data_data02_data*)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationRev_data01_data_data02_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationRev_data01_data_data02_data));
			(sequence->data[i]->ReservationLabel) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationRev_data01_data_data02_data */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationRev_data01_data_data02_data (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationRev_data01_data_data02_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestFwd_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestFwd_data01 (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestFwd_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestFwd_data01_data** tmp;
		tmp = (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestFwd_data01_data**)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestFwd_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestFwd_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestFwd_data01_data*)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestFwd_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestFwd_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->ProfileType) = 0;
			(sequence->data[i]->ProfileLength) = 0;
			sequence->data[i]->ProfileValue.value = NULL;
			sequence->data[i]->ProfileValue.usedBits = 0;
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->ProfileValue.value != NULL) {
					EDFree (sequence->data[i]->ProfileValue.value);
					sequence->data[i]->ProfileValue.value = NULL;
				}
				sequence->data[i]->ProfileValue.usedBits = 0;
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestFwd_data01_data */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestFwd_data01_data (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestFwd_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->ProfileValue.value != NULL) {
		EDFree (sp->ProfileValue.value);
		sp->ProfileValue.value = NULL;
	}
	sp->ProfileValue.usedBits = 0;

}

/* SETITEMS commands for type 'c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestRev_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestRev_data01 (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestRev_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestRev_data01_data** tmp;
		tmp = (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestRev_data01_data**)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestRev_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestRev_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestRev_data01_data*)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestRev_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestRev_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->ProfileType) = 0;
			(sequence->data[i]->ProfileLength) = 0;
			sequence->data[i]->ProfileValue.value = NULL;
			sequence->data[i]->ProfileValue.usedBits = 0;
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->ProfileValue.value != NULL) {
					EDFree (sequence->data[i]->ProfileValue.value);
					sequence->data[i]->ProfileValue.value = NULL;
				}
				sequence->data[i]->ProfileValue.usedBits = 0;
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestRev_data01_data */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestRev_data01_data (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestRev_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->ProfileValue.value != NULL) {
		EDFree (sp->ProfileValue.value);
		sp->ProfileValue.value = NULL;
	}
	sp->ProfileValue.usedBits = 0;

}

/* SETITEMS commands for type 'c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseFwd_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseFwd_data01 (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseFwd_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseFwd_data01_data** tmp;
		tmp = (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseFwd_data01_data**)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseFwd_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseFwd_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseFwd_data01_data*)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseFwd_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseFwd_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->ProfileType) = 0;
			(sequence->data[i]->ProfileLength) = 0;
			sequence->data[i]->ProfileValue.value = NULL;
			sequence->data[i]->ProfileValue.usedBits = 0;
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->ProfileValue.value != NULL) {
					EDFree (sequence->data[i]->ProfileValue.value);
					sequence->data[i]->ProfileValue.value = NULL;
				}
				sequence->data[i]->ProfileValue.usedBits = 0;
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseFwd_data01_data */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseFwd_data01_data (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseFwd_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->ProfileValue.value != NULL) {
		EDFree (sp->ProfileValue.value);
		sp->ProfileValue.value = NULL;
	}
	sp->ProfileValue.usedBits = 0;

}

/* SETITEMS commands for type 'c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseRev_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseRev_data01 (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseRev_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseRev_data01_data** tmp;
		tmp = (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseRev_data01_data**)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseRev_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseRev_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseRev_data01_data*)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseRev_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseRev_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->ProfileType) = 0;
			(sequence->data[i]->ProfileLength) = 0;
			sequence->data[i]->ProfileValue.value = NULL;
			sequence->data[i]->ProfileValue.usedBits = 0;
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->ProfileValue.value != NULL) {
					EDFree (sequence->data[i]->ProfileValue.value);
					sequence->data[i]->ProfileValue.value = NULL;
				}
				sequence->data[i]->ProfileValue.usedBits = 0;
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseRev_data01_data */
void FREE_c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseRev_data01_data (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseRev_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->ProfileValue.value != NULL) {
		EDFree (sp->ProfileValue.value);
		sp->ProfileValue.value = NULL;
	}
	sp->ProfileValue.usedBits = 0;

}

/* SETITEMS commands for type 'c_Air_Default_Stream_Protocol_Attributes_StreamConfiguration_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Default_Stream_Protocol_Attributes_StreamConfiguration_data01 (c_Air_Default_Stream_Protocol_Attributes_StreamConfiguration_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Default_Stream_Protocol_Attributes_StreamConfiguration_data01_data** tmp;
		tmp = (c_Air_Default_Stream_Protocol_Attributes_StreamConfiguration_data01_data**)EDAlloc (sizeof (c_Air_Default_Stream_Protocol_Attributes_StreamConfiguration_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Default_Stream_Protocol_Attributes_StreamConfiguration_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Default_Stream_Protocol_Attributes_StreamConfiguration_data01_data*)EDAlloc (sizeof (c_Air_Default_Stream_Protocol_Attributes_StreamConfiguration_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Default_Stream_Protocol_Attributes_StreamConfiguration_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->Stream0Application) = 0;
			(sequence->data[i]->Stream1Application) = 0;
			(sequence->data[i]->Stream2Application) = 0;
			(sequence->data[i]->Stream3Application) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Default_Stream_Protocol_Attributes_StreamConfiguration_data01_data */
void FREE_c_Air_Default_Stream_Protocol_Attributes_StreamConfiguration_data01_data (c_Air_Default_Stream_Protocol_Attributes_StreamConfiguration_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Default_Session_Configuration_Protocol_Attributes_PriorSession_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Default_Session_Configuration_Protocol_Attributes_PriorSession_data01 (c_Air_Default_Session_Configuration_Protocol_Attributes_PriorSession_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Default_Session_Configuration_Protocol_Attributes_PriorSession_data01_data** tmp;
		tmp = (c_Air_Default_Session_Configuration_Protocol_Attributes_PriorSession_data01_data**)EDAlloc (sizeof (c_Air_Default_Session_Configuration_Protocol_Attributes_PriorSession_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Default_Session_Configuration_Protocol_Attributes_PriorSession_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Default_Session_Configuration_Protocol_Attributes_PriorSession_data01_data*)EDAlloc (sizeof (c_Air_Default_Session_Configuration_Protocol_Attributes_PriorSession_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Default_Session_Configuration_Protocol_Attributes_PriorSession_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->Restore) = 0;
			sequence->data[i]->SecurityPacket.value = NULL;
			sequence->data[i]->SecurityPacket.usedBits = 0;
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->UATI_Present) {
					EDFree (sequence->data[i]->UATI);
				}
				if (sequence->data[i]->SecurityPacketLength_Present) {
				}
				if (sequence->data[i]->SecurityPacket.value != NULL) {
					EDFree (sequence->data[i]->SecurityPacket.value);
					sequence->data[i]->SecurityPacket.value = NULL;
				}
				sequence->data[i]->SecurityPacket.usedBits = 0;
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Default_Session_Configuration_Protocol_Attributes_PriorSession_data01_data */
void FREE_c_Air_Default_Session_Configuration_Protocol_Attributes_PriorSession_data01_data (c_Air_Default_Session_Configuration_Protocol_Attributes_PriorSession_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->UATI_Present) {
		EDFree (sp->UATI);
		sp->UATI_Present = ED_FALSE;
	}
	if (sp->SecurityPacket.value != NULL) {
		EDFree (sp->SecurityPacket.value);
		sp->SecurityPacket.value = NULL;
	}
	sp->SecurityPacket.usedBits = 0;

}

void SETPRESENT_c_Air_Default_Session_Configuration_Protocol_Attributes_PriorSession_data01_data_UATI (c_Air_Default_Session_Configuration_Protocol_Attributes_PriorSession_data01_data* sp, ED_BOOLEAN present)
{
	/* Do nothing if already compliant to the request */
	if (sp->UATI_Present == present) return;
	sp->UATI_Present = present;
	if (present) {
		/*-->*/sp->UATI = (ED_BYTE*)EDAlloc ((size_t)16);
		ED_RESET_MEM (sp->UATI, 16);
	} else {
		EDFree (sp->UATI);
	}
}

/* SETITEMS commands for type 'c_Air_Default_Session_Configuration_Protocol_Attributes_ATSupportedApplicationSubtypes_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Default_Session_Configuration_Protocol_Attributes_ATSupportedApplicationSubtypes_data01 (c_Air_Default_Session_Configuration_Protocol_Attributes_ATSupportedApplicationSubtypes_data01* sequence, int desiredItems)
{
	int i, i0;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Default_Session_Configuration_Protocol_Attributes_ATSupportedApplicationSubtypes_data01_data** tmp;
		tmp = (c_Air_Default_Session_Configuration_Protocol_Attributes_ATSupportedApplicationSubtypes_data01_data**)EDAlloc (sizeof (c_Air_Default_Session_Configuration_Protocol_Attributes_ATSupportedApplicationSubtypes_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Default_Session_Configuration_Protocol_Attributes_ATSupportedApplicationSubtypes_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Default_Session_Configuration_Protocol_Attributes_ATSupportedApplicationSubtypes_data01_data*)EDAlloc (sizeof (c_Air_Default_Session_Configuration_Protocol_Attributes_ATSupportedApplicationSubtypes_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Default_Session_Configuration_Protocol_Attributes_ATSupportedApplicationSubtypes_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->NumAppSubtypes) = 0;
			sequence->data[i]->data02.items = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				for (i0=0; i0<sequence->data[i]->data02.items; i0++) {
					EDFree (sequence->data[i]->data02.data[i0]);
					sequence->data[i]->data02.data[i0] = NULL;
				}
				if (sequence->data[i]->data02.data) {EDFree (sequence->data[i]->data02.data); sequence->data[i]->data02.data = NULL; sequence->data[i]->data02.allocatedItems=0; /*FR02A*/}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Default_Session_Configuration_Protocol_Attributes_ATSupportedApplicationSubtypes_data01_data */
void FREE_c_Air_Default_Session_Configuration_Protocol_Attributes_ATSupportedApplicationSubtypes_data01_data (c_Air_Default_Session_Configuration_Protocol_Attributes_ATSupportedApplicationSubtypes_data01_data* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data02.items; i0++) {
		EDFree (sp->data02.data[i0]);
		sp->data02.data[i0] = NULL;
	}
	if (sp->data02.data) {EDFree (sp->data02.data); sp->data02.data = NULL; sp->data02.allocatedItems=0; /*FR02A*/}

}

/* SETITEMS commands for type 'c_Air_Default_Session_Configuration_Protocol_Attributes_ATSupportedApplicationSubtypes_data01_data_data02'. Existing items are not changed. */
int SETITEMS_c_Air_Default_Session_Configuration_Protocol_Attributes_ATSupportedApplicationSubtypes_data01_data_data02 (c_Air_Default_Session_Configuration_Protocol_Attributes_ATSupportedApplicationSubtypes_data01_data_data02* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Default_Session_Configuration_Protocol_Attributes_ATSupportedApplicationSubtypes_data01_data_data02_data** tmp;
		tmp = (c_Air_Default_Session_Configuration_Protocol_Attributes_ATSupportedApplicationSubtypes_data01_data_data02_data**)EDAlloc (sizeof (c_Air_Default_Session_Configuration_Protocol_Attributes_ATSupportedApplicationSubtypes_data01_data_data02_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Default_Session_Configuration_Protocol_Attributes_ATSupportedApplicationSubtypes_data01_data_data02_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Default_Session_Configuration_Protocol_Attributes_ATSupportedApplicationSubtypes_data01_data_data02_data*)EDAlloc (sizeof (c_Air_Default_Session_Configuration_Protocol_Attributes_ATSupportedApplicationSubtypes_data01_data_data02_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Default_Session_Configuration_Protocol_Attributes_ATSupportedApplicationSubtypes_data01_data_data02_data));
			(sequence->data[i]->ApplicationSubtype) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Default_Session_Configuration_Protocol_Attributes_ATSupportedApplicationSubtypes_data01_data_data02_data */
void FREE_c_Air_Default_Session_Configuration_Protocol_Attributes_ATSupportedApplicationSubtypes_data01_data_data02_data (c_Air_Default_Session_Configuration_Protocol_Attributes_ATSupportedApplicationSubtypes_data01_data_data02_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Default_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Default_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01 (c_Air_Default_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Default_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01_data** tmp;
		tmp = (c_Air_Default_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01_data**)EDAlloc (sizeof (c_Air_Default_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Default_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Default_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01_data*)EDAlloc (sizeof (c_Air_Default_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Default_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->PreferredControlChannelCycleEnabled) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->PreferredControlChannelCycle_Present) {
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Default_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01_data */
void FREE_c_Air_Default_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01_data (c_Air_Default_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Enhanced_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Enhanced_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01 (c_Air_Enhanced_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Enhanced_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01_data** tmp;
		tmp = (c_Air_Enhanced_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01_data**)EDAlloc (sizeof (c_Air_Enhanced_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Enhanced_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Enhanced_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01_data*)EDAlloc (sizeof (c_Air_Enhanced_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Enhanced_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->PreferredControlChannelCycleEnabled) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->PreferredControlChannelCycle_Present) {
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Enhanced_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01_data */
void FREE_c_Air_Enhanced_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01_data (c_Air_Enhanced_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Enhanced_Idle_State_Protocol_Attributes_SlottedMode_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Enhanced_Idle_State_Protocol_Attributes_SlottedMode_data01 (c_Air_Enhanced_Idle_State_Protocol_Attributes_SlottedMode_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Enhanced_Idle_State_Protocol_Attributes_SlottedMode_data01_data** tmp;
		tmp = (c_Air_Enhanced_Idle_State_Protocol_Attributes_SlottedMode_data01_data**)EDAlloc (sizeof (c_Air_Enhanced_Idle_State_Protocol_Attributes_SlottedMode_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Enhanced_Idle_State_Protocol_Attributes_SlottedMode_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Enhanced_Idle_State_Protocol_Attributes_SlottedMode_data01_data*)EDAlloc (sizeof (c_Air_Enhanced_Idle_State_Protocol_Attributes_SlottedMode_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Enhanced_Idle_State_Protocol_Attributes_SlottedMode_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->SlotCycle1) = 0;
			(sequence->data[i]->SlotCycle2) = 0;
			(sequence->data[i]->SlotCycle3) = 0;
			(sequence->data[i]->WakeCount1) = 0;
			(sequence->data[i]->WakeCount2) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Enhanced_Idle_State_Protocol_Attributes_SlottedMode_data01_data */
void FREE_c_Air_Enhanced_Idle_State_Protocol_Attributes_SlottedMode_data01_data (c_Air_Enhanced_Idle_State_Protocol_Attributes_SlottedMode_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Enhanced_Idle_State_Protocol_Attributes_PagingMask_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Enhanced_Idle_State_Protocol_Attributes_PagingMask_data01 (c_Air_Enhanced_Idle_State_Protocol_Attributes_PagingMask_data01* sequence, int desiredItems)
{
	int i, i0;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Enhanced_Idle_State_Protocol_Attributes_PagingMask_data01_data** tmp;
		tmp = (c_Air_Enhanced_Idle_State_Protocol_Attributes_PagingMask_data01_data**)EDAlloc (sizeof (c_Air_Enhanced_Idle_State_Protocol_Attributes_PagingMask_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Enhanced_Idle_State_Protocol_Attributes_PagingMask_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Enhanced_Idle_State_Protocol_Attributes_PagingMask_data01_data*)EDAlloc (sizeof (c_Air_Enhanced_Idle_State_Protocol_Attributes_PagingMask_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Enhanced_Idle_State_Protocol_Attributes_PagingMask_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->MaskCount) = 0;
			sequence->data[i]->data02.items = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				for (i0=0; i0<sequence->data[i]->data02.items; i0++) {
					EDFree (sequence->data[i]->data02.data[i0]);
					sequence->data[i]->data02.data[i0] = NULL;
				}
				if (sequence->data[i]->data02.data) {EDFree (sequence->data[i]->data02.data); sequence->data[i]->data02.data = NULL; sequence->data[i]->data02.allocatedItems=0; /*FR02A*/}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Enhanced_Idle_State_Protocol_Attributes_PagingMask_data01_data */
void FREE_c_Air_Enhanced_Idle_State_Protocol_Attributes_PagingMask_data01_data (c_Air_Enhanced_Idle_State_Protocol_Attributes_PagingMask_data01_data* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data02.items; i0++) {
		EDFree (sp->data02.data[i0]);
		sp->data02.data[i0] = NULL;
	}
	if (sp->data02.data) {EDFree (sp->data02.data); sp->data02.data = NULL; sp->data02.allocatedItems=0; /*FR02A*/}

}

/* SETITEMS commands for type 'c_Air_Enhanced_Idle_State_Protocol_Attributes_PagingMask_data01_data_data02'. Existing items are not changed. */
int SETITEMS_c_Air_Enhanced_Idle_State_Protocol_Attributes_PagingMask_data01_data_data02 (c_Air_Enhanced_Idle_State_Protocol_Attributes_PagingMask_data01_data_data02* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Enhanced_Idle_State_Protocol_Attributes_PagingMask_data01_data_data02_data** tmp;
		tmp = (c_Air_Enhanced_Idle_State_Protocol_Attributes_PagingMask_data01_data_data02_data**)EDAlloc (sizeof (c_Air_Enhanced_Idle_State_Protocol_Attributes_PagingMask_data01_data_data02_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Enhanced_Idle_State_Protocol_Attributes_PagingMask_data01_data_data02_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Enhanced_Idle_State_Protocol_Attributes_PagingMask_data01_data_data02_data*)EDAlloc (sizeof (c_Air_Enhanced_Idle_State_Protocol_Attributes_PagingMask_data01_data_data02_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Enhanced_Idle_State_Protocol_Attributes_PagingMask_data01_data_data02_data));
			(sequence->data[i]->MaskPurpose) = 0;
			(sequence->data[i]->PreMaskDuration) = 0;
			(sequence->data[i]->MaskDuration) = 0;
			(sequence->data[i]->PostMaskDuration) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Enhanced_Idle_State_Protocol_Attributes_PagingMask_data01_data_data02_data */
void FREE_c_Air_Enhanced_Idle_State_Protocol_Attributes_PagingMask_data01_data_data02_data (c_Air_Enhanced_Idle_State_Protocol_Attributes_PagingMask_data01_data_data02_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Quick_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Quick_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01 (c_Air_Quick_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Quick_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01_data** tmp;
		tmp = (c_Air_Quick_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01_data**)EDAlloc (sizeof (c_Air_Quick_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Quick_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Quick_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01_data*)EDAlloc (sizeof (c_Air_Quick_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Quick_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->PreferredControlChannelCycleEnabled) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->PreferredControlChannelCycle_Present) {
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Quick_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01_data */
void FREE_c_Air_Quick_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01_data (c_Air_Quick_Idle_State_Protocol_Attributes_PreferredControlChannelCycle_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Quick_Idle_State_Protocol_Attributes_SlottedMode_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Quick_Idle_State_Protocol_Attributes_SlottedMode_data01 (c_Air_Quick_Idle_State_Protocol_Attributes_SlottedMode_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Quick_Idle_State_Protocol_Attributes_SlottedMode_data01_data** tmp;
		tmp = (c_Air_Quick_Idle_State_Protocol_Attributes_SlottedMode_data01_data**)EDAlloc (sizeof (c_Air_Quick_Idle_State_Protocol_Attributes_SlottedMode_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Quick_Idle_State_Protocol_Attributes_SlottedMode_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Quick_Idle_State_Protocol_Attributes_SlottedMode_data01_data*)EDAlloc (sizeof (c_Air_Quick_Idle_State_Protocol_Attributes_SlottedMode_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Quick_Idle_State_Protocol_Attributes_SlottedMode_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->SlotCycle1) = 0;
			(sequence->data[i]->SlotCycle2) = 0;
			(sequence->data[i]->SlotCycle3) = 0;
			(sequence->data[i]->WakeCount1) = 0;
			(sequence->data[i]->WakeCount2) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Quick_Idle_State_Protocol_Attributes_SlottedMode_data01_data */
void FREE_c_Air_Quick_Idle_State_Protocol_Attributes_SlottedMode_data01_data (c_Air_Quick_Idle_State_Protocol_Attributes_SlottedMode_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Quick_Idle_State_Protocol_Attributes_PagingMask_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Quick_Idle_State_Protocol_Attributes_PagingMask_data01 (c_Air_Quick_Idle_State_Protocol_Attributes_PagingMask_data01* sequence, int desiredItems)
{
	int i, i0;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Quick_Idle_State_Protocol_Attributes_PagingMask_data01_data** tmp;
		tmp = (c_Air_Quick_Idle_State_Protocol_Attributes_PagingMask_data01_data**)EDAlloc (sizeof (c_Air_Quick_Idle_State_Protocol_Attributes_PagingMask_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Quick_Idle_State_Protocol_Attributes_PagingMask_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Quick_Idle_State_Protocol_Attributes_PagingMask_data01_data*)EDAlloc (sizeof (c_Air_Quick_Idle_State_Protocol_Attributes_PagingMask_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Quick_Idle_State_Protocol_Attributes_PagingMask_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->MaskCount) = 0;
			sequence->data[i]->data02.items = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				for (i0=0; i0<sequence->data[i]->data02.items; i0++) {
					EDFree (sequence->data[i]->data02.data[i0]);
					sequence->data[i]->data02.data[i0] = NULL;
				}
				if (sequence->data[i]->data02.data) {EDFree (sequence->data[i]->data02.data); sequence->data[i]->data02.data = NULL; sequence->data[i]->data02.allocatedItems=0; /*FR02A*/}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Quick_Idle_State_Protocol_Attributes_PagingMask_data01_data */
void FREE_c_Air_Quick_Idle_State_Protocol_Attributes_PagingMask_data01_data (c_Air_Quick_Idle_State_Protocol_Attributes_PagingMask_data01_data* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data02.items; i0++) {
		EDFree (sp->data02.data[i0]);
		sp->data02.data[i0] = NULL;
	}
	if (sp->data02.data) {EDFree (sp->data02.data); sp->data02.data = NULL; sp->data02.allocatedItems=0; /*FR02A*/}

}

/* SETITEMS commands for type 'c_Air_Quick_Idle_State_Protocol_Attributes_PagingMask_data01_data_data02'. Existing items are not changed. */
int SETITEMS_c_Air_Quick_Idle_State_Protocol_Attributes_PagingMask_data01_data_data02 (c_Air_Quick_Idle_State_Protocol_Attributes_PagingMask_data01_data_data02* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Quick_Idle_State_Protocol_Attributes_PagingMask_data01_data_data02_data** tmp;
		tmp = (c_Air_Quick_Idle_State_Protocol_Attributes_PagingMask_data01_data_data02_data**)EDAlloc (sizeof (c_Air_Quick_Idle_State_Protocol_Attributes_PagingMask_data01_data_data02_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Quick_Idle_State_Protocol_Attributes_PagingMask_data01_data_data02_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Quick_Idle_State_Protocol_Attributes_PagingMask_data01_data_data02_data*)EDAlloc (sizeof (c_Air_Quick_Idle_State_Protocol_Attributes_PagingMask_data01_data_data02_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Quick_Idle_State_Protocol_Attributes_PagingMask_data01_data_data02_data));
			(sequence->data[i]->MaskPurpose) = 0;
			(sequence->data[i]->PreMaskDuration) = 0;
			(sequence->data[i]->MaskDuration) = 0;
			(sequence->data[i]->PostMaskDuration) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Quick_Idle_State_Protocol_Attributes_PagingMask_data01_data_data02_data */
void FREE_c_Air_Quick_Idle_State_Protocol_Attributes_PagingMask_data01_data_data02_data (c_Air_Quick_Idle_State_Protocol_Attributes_PagingMask_data01_data_data02_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Quick_Idle_State_Protocol_Attributes_QuickPaging_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Quick_Idle_State_Protocol_Attributes_QuickPaging_data01 (c_Air_Quick_Idle_State_Protocol_Attributes_QuickPaging_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Quick_Idle_State_Protocol_Attributes_QuickPaging_data01_data** tmp;
		tmp = (c_Air_Quick_Idle_State_Protocol_Attributes_QuickPaging_data01_data**)EDAlloc (sizeof (c_Air_Quick_Idle_State_Protocol_Attributes_QuickPaging_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Quick_Idle_State_Protocol_Attributes_QuickPaging_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Quick_Idle_State_Protocol_Attributes_QuickPaging_data01_data*)EDAlloc (sizeof (c_Air_Quick_Idle_State_Protocol_Attributes_QuickPaging_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Quick_Idle_State_Protocol_Attributes_QuickPaging_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->QuickPagingEnabled) = 0;
			(sequence->data[i]->SubSyncQuickPaging) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Quick_Idle_State_Protocol_Attributes_QuickPaging_data01_data */
void FREE_c_Air_Quick_Idle_State_Protocol_Attributes_QuickPaging_data01_data (c_Air_Quick_Idle_State_Protocol_Attributes_QuickPaging_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Default_Route_Update_Protocol_Attributes_SearchParameters_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Default_Route_Update_Protocol_Attributes_SearchParameters_data01 (c_Air_Default_Route_Update_Protocol_Attributes_SearchParameters_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Default_Route_Update_Protocol_Attributes_SearchParameters_data01_data** tmp;
		tmp = (c_Air_Default_Route_Update_Protocol_Attributes_SearchParameters_data01_data**)EDAlloc (sizeof (c_Air_Default_Route_Update_Protocol_Attributes_SearchParameters_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Default_Route_Update_Protocol_Attributes_SearchParameters_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Default_Route_Update_Protocol_Attributes_SearchParameters_data01_data*)EDAlloc (sizeof (c_Air_Default_Route_Update_Protocol_Attributes_SearchParameters_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Default_Route_Update_Protocol_Attributes_SearchParameters_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->PilotIncrement) = 0;
			(sequence->data[i]->SearchWindowActive) = 0;
			(sequence->data[i]->SearchWindowNeighbor) = 0;
			(sequence->data[i]->SearchWindowRemaining) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Default_Route_Update_Protocol_Attributes_SearchParameters_data01_data */
void FREE_c_Air_Default_Route_Update_Protocol_Attributes_SearchParameters_data01_data (c_Air_Default_Route_Update_Protocol_Attributes_SearchParameters_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Default_Route_Update_Protocol_Attributes_SetManagementSameChannelParameters_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Default_Route_Update_Protocol_Attributes_SetManagementSameChannelParameters_data01 (c_Air_Default_Route_Update_Protocol_Attributes_SetManagementSameChannelParameters_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Default_Route_Update_Protocol_Attributes_SetManagementSameChannelParameters_data01_data** tmp;
		tmp = (c_Air_Default_Route_Update_Protocol_Attributes_SetManagementSameChannelParameters_data01_data**)EDAlloc (sizeof (c_Air_Default_Route_Update_Protocol_Attributes_SetManagementSameChannelParameters_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Default_Route_Update_Protocol_Attributes_SetManagementSameChannelParameters_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Default_Route_Update_Protocol_Attributes_SetManagementSameChannelParameters_data01_data*)EDAlloc (sizeof (c_Air_Default_Route_Update_Protocol_Attributes_SetManagementSameChannelParameters_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Default_Route_Update_Protocol_Attributes_SetManagementSameChannelParameters_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->PilotAdd) = 0;
			(sequence->data[i]->PilotCompare) = 0;
			(sequence->data[i]->PilotDrop) = 0;
			(sequence->data[i]->PilotDropTimer) = 0;
			(sequence->data[i]->DynamicThresholds) = 0;
			(sequence->data[i]->NeighborMaxAge) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->SoftSlope_Present) {
				}
				if (sequence->data[i]->AddIntercept_Present) {
				}
				if (sequence->data[i]->DropIntercept_Present) {
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Default_Route_Update_Protocol_Attributes_SetManagementSameChannelParameters_data01_data */
void FREE_c_Air_Default_Route_Update_Protocol_Attributes_SetManagementSameChannelParameters_data01_data (c_Air_Default_Route_Update_Protocol_Attributes_SetManagementSameChannelParameters_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Default_Route_Update_Protocol_Attributes_SetManagementDifferentChannelParameters_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Default_Route_Update_Protocol_Attributes_SetManagementDifferentChannelParameters_data01 (c_Air_Default_Route_Update_Protocol_Attributes_SetManagementDifferentChannelParameters_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Default_Route_Update_Protocol_Attributes_SetManagementDifferentChannelParameters_data01_data** tmp;
		tmp = (c_Air_Default_Route_Update_Protocol_Attributes_SetManagementDifferentChannelParameters_data01_data**)EDAlloc (sizeof (c_Air_Default_Route_Update_Protocol_Attributes_SetManagementDifferentChannelParameters_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Default_Route_Update_Protocol_Attributes_SetManagementDifferentChannelParameters_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Default_Route_Update_Protocol_Attributes_SetManagementDifferentChannelParameters_data01_data*)EDAlloc (sizeof (c_Air_Default_Route_Update_Protocol_Attributes_SetManagementDifferentChannelParameters_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Default_Route_Update_Protocol_Attributes_SetManagementDifferentChannelParameters_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->PilotAdd) = 0;
			(sequence->data[i]->PilotCompare) = 0;
			(sequence->data[i]->PilotDrop) = 0;
			(sequence->data[i]->PilotDropTimer) = 0;
			(sequence->data[i]->DynamicThresholds) = 0;
			(sequence->data[i]->NeighborMaxAge) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->SoftSlope_Present) {
				}
				if (sequence->data[i]->AddIntercept_Present) {
				}
				if (sequence->data[i]->DropIntercept_Present) {
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Default_Route_Update_Protocol_Attributes_SetManagementDifferentChannelParameters_data01_data */
void FREE_c_Air_Default_Route_Update_Protocol_Attributes_SetManagementDifferentChannelParameters_data01_data (c_Air_Default_Route_Update_Protocol_Attributes_SetManagementDifferentChannelParameters_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01 (c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01* sequence, int desiredItems)
{
	int i, i0, i1;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data** tmp;
		tmp = (c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data**)EDAlloc (sizeof (c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data*)EDAlloc (sizeof (c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->BandClassCount) = 0;
			sequence->data[i]->data02.items = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				for (i0=0; i0<sequence->data[i]->data02.items; i0++) {
					for (i1=0; i1<sequence->data[i]->data02.data[i0]->data03.items; i1++) {
						EDFree (sequence->data[i]->data02.data[i0]->data03.data[i1]);
						sequence->data[i]->data02.data[i0]->data03.data[i1] = NULL;
					}
					if (sequence->data[i]->data02.data[i0]->data03.data) {EDFree (sequence->data[i]->data02.data[i0]->data03.data); sequence->data[i]->data02.data[i0]->data03.data = NULL; sequence->data[i]->data02.data[i0]->data03.allocatedItems=0; /*FR02A*/}
					EDFree (sequence->data[i]->data02.data[i0]);
					sequence->data[i]->data02.data[i0] = NULL;
				}
				if (sequence->data[i]->data02.data) {EDFree (sequence->data[i]->data02.data); sequence->data[i]->data02.data = NULL; sequence->data[i]->data02.allocatedItems=0; /*FR02A*/}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data */
void FREE_c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data (c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data* sp) {
	int i0;
	int i1;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data02.items; i0++) {
		for (i1=0; i1<sp->data02.data[i0]->data03.items; i1++) {
			EDFree (sp->data02.data[i0]->data03.data[i1]);
			sp->data02.data[i0]->data03.data[i1] = NULL;
		}
		if (sp->data02.data[i0]->data03.data) {EDFree (sp->data02.data[i0]->data03.data); sp->data02.data[i0]->data03.data = NULL; sp->data02.data[i0]->data03.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data02.data[i0]);
		sp->data02.data[i0] = NULL;
	}
	if (sp->data02.data) {EDFree (sp->data02.data); sp->data02.data = NULL; sp->data02.allocatedItems=0; /*FR02A*/}

}

/* SETITEMS commands for type 'c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02'. Existing items are not changed. */
int SETITEMS_c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02 (c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02* sequence, int desiredItems)
{
	int i, i0;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data** tmp;
		tmp = (c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data**)EDAlloc (sizeof (c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data*)EDAlloc (sizeof (c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data));
			(sequence->data[i]->BandClass) = 0;
			(sequence->data[i]->BandSubClassCount) = 0;
			sequence->data[i]->data03.items = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				for (i0=0; i0<sequence->data[i]->data03.items; i0++) {
					EDFree (sequence->data[i]->data03.data[i0]);
					sequence->data[i]->data03.data[i0] = NULL;
				}
				if (sequence->data[i]->data03.data) {EDFree (sequence->data[i]->data03.data); sequence->data[i]->data03.data = NULL; sequence->data[i]->data03.allocatedItems=0; /*FR02A*/}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data */
void FREE_c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data (c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data03.items; i0++) {
		EDFree (sp->data03.data[i0]);
		sp->data03.data[i0] = NULL;
	}
	if (sp->data03.data) {EDFree (sp->data03.data); sp->data03.data = NULL; sp->data03.allocatedItems=0; /*FR02A*/}

}

/* SETITEMS commands for type 'c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data_data03'. Existing items are not changed. */
int SETITEMS_c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data_data03 (c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data_data03* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data_data03_data** tmp;
		tmp = (c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data_data03_data**)EDAlloc (sizeof (c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data_data03_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data_data03_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data_data03_data*)EDAlloc (sizeof (c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data_data03_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data_data03_data));
			(sequence->data[i]->BandSubClass) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data_data03_data */
void FREE_c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data_data03_data (c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data_data03_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Route_Update_Protocol_Attributes_SearchParameters_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Route_Update_Protocol_Attributes_SearchParameters_data01 (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SearchParameters_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Route_Update_Protocol_Attributes_SearchParameters_data01_data** tmp;
		tmp = (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SearchParameters_data01_data**)EDAlloc (sizeof (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SearchParameters_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SearchParameters_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SearchParameters_data01_data*)EDAlloc (sizeof (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SearchParameters_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SearchParameters_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->PilotIncrement) = 0;
			(sequence->data[i]->SearchWindowActive) = 0;
			(sequence->data[i]->SearchWindowNeighbor) = 0;
			(sequence->data[i]->SearchWindowRemaining) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Route_Update_Protocol_Attributes_SearchParameters_data01_data */
void FREE_c_Air_Multicarrier_Route_Update_Protocol_Attributes_SearchParameters_data01_data (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SearchParameters_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Route_Update_Protocol_Attributes_SetManagementParameters_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Route_Update_Protocol_Attributes_SetManagementParameters_data01 (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SetManagementParameters_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Route_Update_Protocol_Attributes_SetManagementParameters_data01_data** tmp;
		tmp = (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SetManagementParameters_data01_data**)EDAlloc (sizeof (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SetManagementParameters_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SetManagementParameters_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SetManagementParameters_data01_data*)EDAlloc (sizeof (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SetManagementParameters_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SetManagementParameters_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->PilotAdd) = 0;
			(sequence->data[i]->PilotCompare) = 0;
			(sequence->data[i]->PilotDrop) = 0;
			(sequence->data[i]->PilotDropTimer) = 0;
			(sequence->data[i]->DynamicThresholds) = 0;
			(sequence->data[i]->NeighborMaxAge) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->SoftSlope_Present) {
				}
				if (sequence->data[i]->AddIntercept_Present) {
				}
				if (sequence->data[i]->DropIntercept_Present) {
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Route_Update_Protocol_Attributes_SetManagementParameters_data01_data */
void FREE_c_Air_Multicarrier_Route_Update_Protocol_Attributes_SetManagementParameters_data01_data (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SetManagementParameters_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01 (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01* sequence, int desiredItems)
{
	int i, i0, i1;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data** tmp;
		tmp = (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data**)EDAlloc (sizeof (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data*)EDAlloc (sizeof (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->BandClassCount) = 0;
			sequence->data[i]->data02.items = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				for (i0=0; i0<sequence->data[i]->data02.items; i0++) {
					for (i1=0; i1<sequence->data[i]->data02.data[i0]->data03.items; i1++) {
						EDFree (sequence->data[i]->data02.data[i0]->data03.data[i1]);
						sequence->data[i]->data02.data[i0]->data03.data[i1] = NULL;
					}
					if (sequence->data[i]->data02.data[i0]->data03.data) {EDFree (sequence->data[i]->data02.data[i0]->data03.data); sequence->data[i]->data02.data[i0]->data03.data = NULL; sequence->data[i]->data02.data[i0]->data03.allocatedItems=0; /*FR02A*/}
					EDFree (sequence->data[i]->data02.data[i0]);
					sequence->data[i]->data02.data[i0] = NULL;
				}
				if (sequence->data[i]->data02.data) {EDFree (sequence->data[i]->data02.data); sequence->data[i]->data02.data = NULL; sequence->data[i]->data02.allocatedItems=0; /*FR02A*/}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data */
void FREE_c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data* sp) {
	int i0;
	int i1;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data02.items; i0++) {
		for (i1=0; i1<sp->data02.data[i0]->data03.items; i1++) {
			EDFree (sp->data02.data[i0]->data03.data[i1]);
			sp->data02.data[i0]->data03.data[i1] = NULL;
		}
		if (sp->data02.data[i0]->data03.data) {EDFree (sp->data02.data[i0]->data03.data); sp->data02.data[i0]->data03.data = NULL; sp->data02.data[i0]->data03.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data02.data[i0]);
		sp->data02.data[i0] = NULL;
	}
	if (sp->data02.data) {EDFree (sp->data02.data); sp->data02.data = NULL; sp->data02.allocatedItems=0; /*FR02A*/}

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02 (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02* sequence, int desiredItems)
{
	int i, i0;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data** tmp;
		tmp = (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data**)EDAlloc (sizeof (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data*)EDAlloc (sizeof (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data));
			(sequence->data[i]->BandClass) = 0;
			(sequence->data[i]->InterFlexDuplexTag) = 0;
			(sequence->data[i]->IntraFlexDuplexFlag) = 0;
			(sequence->data[i]->BandSubClassCount) = 0;
			sequence->data[i]->data03.items = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				for (i0=0; i0<sequence->data[i]->data03.items; i0++) {
					EDFree (sequence->data[i]->data03.data[i0]);
					sequence->data[i]->data03.data[i0] = NULL;
				}
				if (sequence->data[i]->data03.data) {EDFree (sequence->data[i]->data03.data); sequence->data[i]->data03.data = NULL; sequence->data[i]->data03.allocatedItems=0; /*FR02A*/}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data */
void FREE_c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data03.items; i0++) {
		EDFree (sp->data03.data[i0]);
		sp->data03.data[i0] = NULL;
	}
	if (sp->data03.data) {EDFree (sp->data03.data); sp->data03.data = NULL; sp->data03.allocatedItems=0; /*FR02A*/}

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data_data03'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data_data03 (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data_data03* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data_data03_data** tmp;
		tmp = (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data_data03_data**)EDAlloc (sizeof (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data_data03_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data_data03_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data_data03_data*)EDAlloc (sizeof (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data_data03_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data_data03_data));
			(sequence->data[i]->BandSubClass) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data_data03_data */
void FREE_c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data_data03_data (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels_data01_data_data02_data_data03_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedDRXPatterns_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedDRXPatterns_data01 (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedDRXPatterns_data01* sequence, int desiredItems)
{
	int i, i0;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedDRXPatterns_data01_data** tmp;
		tmp = (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedDRXPatterns_data01_data**)EDAlloc (sizeof (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedDRXPatterns_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedDRXPatterns_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedDRXPatterns_data01_data*)EDAlloc (sizeof (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedDRXPatterns_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedDRXPatterns_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->NumberofDRXPatterns) = 0;
			sequence->data[i]->data02.items = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				for (i0=0; i0<sequence->data[i]->data02.items; i0++) {
					EDFree (sequence->data[i]->data02.data[i0]);
					sequence->data[i]->data02.data[i0] = NULL;
				}
				if (sequence->data[i]->data02.data) {EDFree (sequence->data[i]->data02.data); sequence->data[i]->data02.data = NULL; sequence->data[i]->data02.allocatedItems=0; /*FR02A*/}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedDRXPatterns_data01_data */
void FREE_c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedDRXPatterns_data01_data (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedDRXPatterns_data01_data* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data02.items; i0++) {
		EDFree (sp->data02.data[i0]);
		sp->data02.data[i0] = NULL;
	}
	if (sp->data02.data) {EDFree (sp->data02.data); sp->data02.data = NULL; sp->data02.allocatedItems=0; /*FR02A*/}

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedDRXPatterns_data01_data_data02'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedDRXPatterns_data01_data_data02 (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedDRXPatterns_data01_data_data02* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedDRXPatterns_data01_data_data02_data** tmp;
		tmp = (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedDRXPatterns_data01_data_data02_data**)EDAlloc (sizeof (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedDRXPatterns_data01_data_data02_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedDRXPatterns_data01_data_data02_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedDRXPatterns_data01_data_data02_data*)EDAlloc (sizeof (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedDRXPatterns_data01_data_data02_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedDRXPatterns_data01_data_data02_data));
			(sequence->data[i]->SupportedDRXPattern) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedDRXPatterns_data01_data_data02_data */
void FREE_c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedDRXPatterns_data01_data_data02_data (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedDRXPatterns_data01_data_data02_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Default_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Default_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration_data01 (c_Air_Default_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Default_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration_data01_data** tmp;
		tmp = (c_Air_Default_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration_data01_data**)EDAlloc (sizeof (c_Air_Default_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Default_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Default_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration_data01_data*)EDAlloc (sizeof (c_Air_Default_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Default_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->ProbeSequenceMax) = 0;
			(sequence->data[i]->ProbeBackoff) = 0;
			(sequence->data[i]->ProbeSequenceBackoff) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Default_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration_data01_data */
void FREE_c_Air_Default_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration_data01_data (c_Air_Default_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Default_Access_Channel_MAC_Protocol_Attributes_PowerParameters_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Default_Access_Channel_MAC_Protocol_Attributes_PowerParameters_data01 (c_Air_Default_Access_Channel_MAC_Protocol_Attributes_PowerParameters_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Default_Access_Channel_MAC_Protocol_Attributes_PowerParameters_data01_data** tmp;
		tmp = (c_Air_Default_Access_Channel_MAC_Protocol_Attributes_PowerParameters_data01_data**)EDAlloc (sizeof (c_Air_Default_Access_Channel_MAC_Protocol_Attributes_PowerParameters_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Default_Access_Channel_MAC_Protocol_Attributes_PowerParameters_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Default_Access_Channel_MAC_Protocol_Attributes_PowerParameters_data01_data*)EDAlloc (sizeof (c_Air_Default_Access_Channel_MAC_Protocol_Attributes_PowerParameters_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Default_Access_Channel_MAC_Protocol_Attributes_PowerParameters_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->DataOffsetNom) = 0;
			(sequence->data[i]->DataOffset9k6) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Default_Access_Channel_MAC_Protocol_Attributes_PowerParameters_data01_data */
void FREE_c_Air_Default_Access_Channel_MAC_Protocol_Attributes_PowerParameters_data01_data (c_Air_Default_Access_Channel_MAC_Protocol_Attributes_PowerParameters_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration_data01 (c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration_data01_data** tmp;
		tmp = (c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration_data01_data**)EDAlloc (sizeof (c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration_data01_data*)EDAlloc (sizeof (c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->ProbeSequenceMax) = 0;
			(sequence->data[i]->ProbeBackoff) = 0;
			(sequence->data[i]->ProbeSequenceBackoff) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration_data01_data */
void FREE_c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration_data01_data (c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01 (c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01_data** tmp;
		tmp = (c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01_data**)EDAlloc (sizeof (c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01_data*)EDAlloc (sizeof (c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->SofterHandoffDelay) = 0;
			(sequence->data[i]->SoftHandoffDelay) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01_data */
void FREE_c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01_data (c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCLock_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCLock_data01 (c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCLock_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCLock_data01_data** tmp;
		tmp = (c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCLock_data01_data**)EDAlloc (sizeof (c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCLock_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCLock_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCLock_data01_data*)EDAlloc (sizeof (c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCLock_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCLock_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->DRCLockPeriod) = 0;
			(sequence->data[i]->DRCLockLength) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCLock_data01_data */
void FREE_c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCLock_data01_data (c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCLock_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01 (c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01_data** tmp;
		tmp = (c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01_data**)EDAlloc (sizeof (c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01_data*)EDAlloc (sizeof (c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->SofterHandoffDelay) = 0;
			(sequence->data[i]->SoftHandoffDelay) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01_data */
void FREE_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01_data (c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCTranslationOffset_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCTranslationOffset_data01 (c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCTranslationOffset_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCTranslationOffset_data01_data** tmp;
		tmp = (c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCTranslationOffset_data01_data**)EDAlloc (sizeof (c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCTranslationOffset_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCTranslationOffset_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCTranslationOffset_data01_data*)EDAlloc (sizeof (c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCTranslationOffset_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCTranslationOffset_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->DRCOffset1) = 0;
			(sequence->data[i]->DRCOffset2) = 0;
			(sequence->data[i]->DRCOffset3) = 0;
			(sequence->data[i]->DRCOffset4) = 0;
			(sequence->data[i]->DRCOffset5) = 0;
			(sequence->data[i]->DRCOffset6) = 0;
			(sequence->data[i]->DRCOffset7) = 0;
			(sequence->data[i]->DRCOffset8) = 0;
			(sequence->data[i]->DRCOffset9) = 0;
			(sequence->data[i]->DRCOffsetA) = 0;
			(sequence->data[i]->DRCOffsetB) = 0;
			(sequence->data[i]->DRCOffsetC) = 0;
			(sequence->data[i]->DRCOffsetD) = 0;
			(sequence->data[i]->DRCOffsetE) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCTranslationOffset_data01_data */
void FREE_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCTranslationOffset_data01_data (c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCTranslationOffset_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01 (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01_data** tmp;
		tmp = (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01_data**)EDAlloc (sizeof (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01_data*)EDAlloc (sizeof (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->SofterHandoffDelay) = 0;
			(sequence->data[i]->SoftHandoffDelay) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01_data */
void FREE_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01_data (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ATSupportedPacketFormats_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ATSupportedPacketFormats_data01 (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ATSupportedPacketFormats_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ATSupportedPacketFormats_data01_data** tmp;
		tmp = (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ATSupportedPacketFormats_data01_data**)EDAlloc (sizeof (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ATSupportedPacketFormats_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ATSupportedPacketFormats_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ATSupportedPacketFormats_data01_data*)EDAlloc (sizeof (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ATSupportedPacketFormats_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ATSupportedPacketFormats_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->MaxOptionalDataRate) = 0;
			(sequence->data[i]->MaxOptionalPayloadSize) = 0;
			(sequence->data[i]->ShortPacketsEnabledThresh) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ATSupportedPacketFormats_data01_data */
void FREE_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ATSupportedPacketFormats_data01_data (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ATSupportedPacketFormats_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_TentativeDRCtoTxDRCMap_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_TentativeDRCtoTxDRCMap_data01 (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_TentativeDRCtoTxDRCMap_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_TentativeDRCtoTxDRCMap_data01_data** tmp;
		tmp = (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_TentativeDRCtoTxDRCMap_data01_data**)EDAlloc (sizeof (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_TentativeDRCtoTxDRCMap_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_TentativeDRCtoTxDRCMap_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_TentativeDRCtoTxDRCMap_data01_data*)EDAlloc (sizeof (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_TentativeDRCtoTxDRCMap_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_TentativeDRCtoTxDRCMap_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->TxDRCMap01) = 0;
			(sequence->data[i]->TxDRCMap02) = 0;
			(sequence->data[i]->TxDRCMap03) = 0;
			(sequence->data[i]->TxDRCMap04) = 0;
			(sequence->data[i]->TxDRCMap05) = 0;
			(sequence->data[i]->TxDRCMap06) = 0;
			(sequence->data[i]->TxDRCMap07) = 0;
			(sequence->data[i]->TxDRCMap08) = 0;
			(sequence->data[i]->TxDRCMap09) = 0;
			(sequence->data[i]->TxDRCMap0A) = 0;
			(sequence->data[i]->TxDRCMap0B) = 0;
			(sequence->data[i]->TxDRCMap0C) = 0;
			(sequence->data[i]->TxDRCMap0D) = 0;
			(sequence->data[i]->TxDRCMap0E) = 0;
			(sequence->data[i]->TxDRCMap10) = 0;
			(sequence->data[i]->TxDRCMap11) = 0;
			(sequence->data[i]->TxDRCMap12) = 0;
			(sequence->data[i]->TxDRCMap13) = 0;
			(sequence->data[i]->TxDRCMap14) = 0;
			(sequence->data[i]->TxDRCMap15) = 0;
			(sequence->data[i]->TxDRCMap16) = 0;
			(sequence->data[i]->TxDRCMap17) = 0;
			(sequence->data[i]->TxDRCMap18) = 0;
			(sequence->data[i]->TxDRCMap19) = 0;
			(sequence->data[i]->TxDRCMap1A) = 0;
			(sequence->data[i]->TxDRCMap1B) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_TentativeDRCtoTxDRCMap_data01_data */
void FREE_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_TentativeDRCtoTxDRCMap_data01_data (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_TentativeDRCtoTxDRCMap_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ExtendedSpans_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ExtendedSpans_data01 (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ExtendedSpans_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ExtendedSpans_data01_data** tmp;
		tmp = (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ExtendedSpans_data01_data**)EDAlloc (sizeof (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ExtendedSpans_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ExtendedSpans_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ExtendedSpans_data01_data*)EDAlloc (sizeof (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ExtendedSpans_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ExtendedSpans_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->ExtendedSpansEnabled) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->PERTargetSpan_Present) {
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ExtendedSpans_data01_data */
void FREE_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ExtendedSpans_data01_data (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ExtendedSpans_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters_data01 (c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters_data01_data** tmp;
		tmp = (c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters_data01_data**)EDAlloc (sizeof (c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters_data01_data*)EDAlloc (sizeof (c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->DataOffsetNom) = 0;
			(sequence->data[i]->DataOffset9k6) = 0;
			(sequence->data[i]->DataOffset19k2) = 0;
			(sequence->data[i]->DataOffset38k4) = 0;
			(sequence->data[i]->DataOffset76k8) = 0;
			(sequence->data[i]->DataOffset153k6) = 0;
			(sequence->data[i]->RPCStep) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters_data01_data */
void FREE_c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters_data01_data (c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters_data01 (c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters_data01_data** tmp;
		tmp = (c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters_data01_data**)EDAlloc (sizeof (c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters_data01_data*)EDAlloc (sizeof (c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->Transition009k6_019k2) = 0;
			(sequence->data[i]->Transition019k2_038k4) = 0;
			(sequence->data[i]->Transition038k4_076k8) = 0;
			(sequence->data[i]->Transition076k8_153k6) = 0;
			(sequence->data[i]->Transition019k2_009k6) = 0;
			(sequence->data[i]->Transition038k4_019k2) = 0;
			(sequence->data[i]->Transition076k8_038k4) = 0;
			(sequence->data[i]->Transition153k6_076k8) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters_data01_data */
void FREE_c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters_data01_data (c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters_data01 (c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters_data01_data** tmp;
		tmp = (c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters_data01_data**)EDAlloc (sizeof (c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters_data01_data*)EDAlloc (sizeof (c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->DataOffsetNom) = 0;
			(sequence->data[i]->DataOffset9k6) = 0;
			(sequence->data[i]->DataOffset19k2) = 0;
			(sequence->data[i]->DataOffset38k4) = 0;
			(sequence->data[i]->DataOffset76k8) = 0;
			(sequence->data[i]->DataOffset153k6) = 0;
			(sequence->data[i]->RPCStep) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters_data01_data */
void FREE_c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters_data01_data (c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters_data01 (c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters_data01_data** tmp;
		tmp = (c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters_data01_data**)EDAlloc (sizeof (c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters_data01_data*)EDAlloc (sizeof (c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->Transition009k6_019k2) = 0;
			(sequence->data[i]->Transition019k2_038k4) = 0;
			(sequence->data[i]->Transition038k4_076k8) = 0;
			(sequence->data[i]->Transition076k8_153k6) = 0;
			(sequence->data[i]->Transition019k2_009k6) = 0;
			(sequence->data[i]->Transition038k4_019k2) = 0;
			(sequence->data[i]->Transition076k8_038k4) = 0;
			(sequence->data[i]->Transition153k6_076k8) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters_data01_data */
void FREE_c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters_data01_data (c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters_data01_data** tmp;
		tmp = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters_data01_data**)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters_data01_data*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->AuxiliaryPilotChannelGain) = 0;
			(sequence->data[i]->AuxiliaryPilotChannelMinPayload) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters_data01_data */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters_data01_data (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters_data01_data** tmp;
		tmp = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters_data01_data**)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters_data01_data*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->AllocationStagger) = 0;
			(sequence->data[i]->TxT2Pmin) = 0;
			(sequence->data[i]->RPCStep) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters_data01_data */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters_data01_data (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPackets_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPackets_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPackets_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPackets_data01_data** tmp;
		tmp = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPackets_data01_data**)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPackets_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPackets_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPackets_data01_data*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPackets_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPackets_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->MaxNumSubPackets0) = 0;
			(sequence->data[i]->MaxNumSubPackets1) = 0;
			(sequence->data[i]->MaxNumSubPackets2) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPackets_data01_data */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPackets_data01_data (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPackets_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload_data01_data** tmp;
		tmp = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload_data01_data**)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload_data01_data*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->PermittedPayload0_1) = 0;
			(sequence->data[i]->PermittedPayload0_2) = 0;
			(sequence->data[i]->PermittedPayload0_3) = 0;
			(sequence->data[i]->PermittedPayload128_1) = 0;
			(sequence->data[i]->PermittedPayload128_2) = 0;
			(sequence->data[i]->PermittedPayload128_3) = 0;
			(sequence->data[i]->PermittedPayload256_1) = 0;
			(sequence->data[i]->PermittedPayload256_2) = 0;
			(sequence->data[i]->PermittedPayload256_3) = 0;
			(sequence->data[i]->PermittedPayload512_1) = 0;
			(sequence->data[i]->PermittedPayload512_2) = 0;
			(sequence->data[i]->PermittedPayload512_3) = 0;
			(sequence->data[i]->PermittedPayload768_1) = 0;
			(sequence->data[i]->PermittedPayload768_2) = 0;
			(sequence->data[i]->PermittedPayload768_3) = 0;
			(sequence->data[i]->PermittedPayload1024_1) = 0;
			(sequence->data[i]->PermittedPayload1024_2) = 0;
			(sequence->data[i]->PermittedPayload1024_3) = 0;
			(sequence->data[i]->PermittedPayload1536_1) = 0;
			(sequence->data[i]->PermittedPayload1536_2) = 0;
			(sequence->data[i]->PermittedPayload1536_3) = 0;
			(sequence->data[i]->PermittedPayload2048_1) = 0;
			(sequence->data[i]->PermittedPayload2048_2) = 0;
			(sequence->data[i]->PermittedPayload2048_3) = 0;
			(sequence->data[i]->PermittedPayload3072_1) = 0;
			(sequence->data[i]->PermittedPayload3072_2) = 0;
			(sequence->data[i]->PermittedPayload3072_3) = 0;
			(sequence->data[i]->PermittedPayload4096_1) = 0;
			(sequence->data[i]->PermittedPayload4096_2) = 0;
			(sequence->data[i]->PermittedPayload4096_3) = 0;
			(sequence->data[i]->PermittedPayload6144_1) = 0;
			(sequence->data[i]->PermittedPayload6144_2) = 0;
			(sequence->data[i]->PermittedPayload6144_3) = 0;
			(sequence->data[i]->PermittedPayload8192_1) = 0;
			(sequence->data[i]->PermittedPayload8192_2) = 0;
			(sequence->data[i]->PermittedPayload8192_3) = 0;
			(sequence->data[i]->PermittedPayload12288_1) = 0;
			(sequence->data[i]->PermittedPayload12288_2) = 0;
			(sequence->data[i]->PermittedPayload12288_3) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload_data01_data */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload_data01_data (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrength_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrength_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrength_data01* sequence, int desiredItems)
{
	int i, i0;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrength_data01_data** tmp;
		tmp = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrength_data01_data**)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrength_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrength_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrength_data01_data*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrength_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrength_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->NumPilotStrengthAxisValues) = 0;
			sequence->data[i]->data02.items = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				for (i0=0; i0<sequence->data[i]->data02.items; i0++) {
					EDFree (sequence->data[i]->data02.data[i0]);
					sequence->data[i]->data02.data[i0] = NULL;
				}
				if (sequence->data[i]->data02.data) {EDFree (sequence->data[i]->data02.data); sequence->data[i]->data02.data = NULL; sequence->data[i]->data02.allocatedItems=0; /*FR02A*/}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrength_data01_data */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrength_data01_data (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrength_data01_data* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data02.items; i0++) {
		EDFree (sp->data02.data[i0]);
		sp->data02.data[i0] = NULL;
	}
	if (sp->data02.data) {EDFree (sp->data02.data); sp->data02.data = NULL; sp->data02.allocatedItems=0; /*FR02A*/}

}

/* SETITEMS commands for type 'c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrength_data01_data_data02'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrength_data01_data_data02 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrength_data01_data_data02* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrength_data01_data_data02_data** tmp;
		tmp = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrength_data01_data_data02_data**)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrength_data01_data_data02_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrength_data01_data_data02_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrength_data01_data_data02_data*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrength_data01_data_data02_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrength_data01_data_data02_data));
			(sequence->data[i]->PilotStrengthAxis) = 0;
			(sequence->data[i]->PilotStrengthPilotStrengthAxis) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrength_data01_data_data02_data */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrength_data01_data_data02_data (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrength_data01_data_data02_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128_data01_data** tmp;
		tmp = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128_data01_data**)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128_data01_data*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->LoLatT2PTransition128) = 0;
			(sequence->data[i]->LoLatTerminationTarget128) = 0;
			(sequence->data[i]->HiCapT2PTransition128) = 0;
			(sequence->data[i]->HiCapTerminationTarget128) = 0;
			(sequence->data[i]->T2PLoLatPreTransition128) = 0;
			(sequence->data[i]->T2PLoLatPostTransition128) = 0;
			(sequence->data[i]->T2PHiCapPreTransition128) = 0;
			(sequence->data[i]->T2PHiCapPostTransition128) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128_data01_data */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128_data01_data (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256_data01_data** tmp;
		tmp = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256_data01_data**)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256_data01_data*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->LoLatT2PTransition256) = 0;
			(sequence->data[i]->LoLatTerminationTarget256) = 0;
			(sequence->data[i]->HiCapT2PTransition256) = 0;
			(sequence->data[i]->HiCapTerminationTarget256) = 0;
			(sequence->data[i]->T2PLoLatPreTransition256) = 0;
			(sequence->data[i]->T2PLoLatPostTransition256) = 0;
			(sequence->data[i]->T2PHiCapPreTransition256) = 0;
			(sequence->data[i]->T2PHiCapPostTransition256) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256_data01_data */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256_data01_data (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512_data01_data** tmp;
		tmp = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512_data01_data**)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512_data01_data*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->LoLatT2PTransition512) = 0;
			(sequence->data[i]->LoLatTerminationTarget512) = 0;
			(sequence->data[i]->HiCapT2PTransition512) = 0;
			(sequence->data[i]->HiCapTerminationTarget512) = 0;
			(sequence->data[i]->T2PLoLatPreTransition512) = 0;
			(sequence->data[i]->T2PLoLatPostTransition512) = 0;
			(sequence->data[i]->T2PHiCapPreTransition512) = 0;
			(sequence->data[i]->T2PHiCapPostTransition512) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512_data01_data */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512_data01_data (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768_data01_data** tmp;
		tmp = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768_data01_data**)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768_data01_data*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->LoLatT2PTransition768) = 0;
			(sequence->data[i]->LoLatTerminationTarget768) = 0;
			(sequence->data[i]->HiCapT2PTransition768) = 0;
			(sequence->data[i]->HiCapTerminationTarget768) = 0;
			(sequence->data[i]->T2PLoLatPreTransition768) = 0;
			(sequence->data[i]->T2PLoLatPostTransition768) = 0;
			(sequence->data[i]->T2PHiCapPreTransition768) = 0;
			(sequence->data[i]->T2PHiCapPostTransition768) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768_data01_data */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768_data01_data (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024_data01_data** tmp;
		tmp = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024_data01_data**)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024_data01_data*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->LoLatT2PTransition1024) = 0;
			(sequence->data[i]->LoLatTerminationTarget1024) = 0;
			(sequence->data[i]->HiCapT2PTransition1024) = 0;
			(sequence->data[i]->HiCapTerminationTarget1024) = 0;
			(sequence->data[i]->T2PLoLatPreTransition1024) = 0;
			(sequence->data[i]->T2PLoLatPostTransition1024) = 0;
			(sequence->data[i]->T2PHiCapPreTransition1024) = 0;
			(sequence->data[i]->T2PHiCapPostTransition1024) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024_data01_data */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024_data01_data (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536_data01_data** tmp;
		tmp = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536_data01_data**)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536_data01_data*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->LoLatT2PTransition1536) = 0;
			(sequence->data[i]->LoLatTerminationTarget1536) = 0;
			(sequence->data[i]->HiCapT2PTransition1536) = 0;
			(sequence->data[i]->HiCapTerminationTarget1536) = 0;
			(sequence->data[i]->T2PLoLatPreTransition1536) = 0;
			(sequence->data[i]->T2PLoLatPostTransition1536) = 0;
			(sequence->data[i]->T2PHiCapPreTransition1536) = 0;
			(sequence->data[i]->T2PHiCapPostTransition1536) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536_data01_data */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536_data01_data (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048_data01_data** tmp;
		tmp = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048_data01_data**)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048_data01_data*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->LoLatT2PTransition2048) = 0;
			(sequence->data[i]->LoLatTerminationTarget2048) = 0;
			(sequence->data[i]->HiCapT2PTransition2048) = 0;
			(sequence->data[i]->HiCapTerminationTarget2048) = 0;
			(sequence->data[i]->T2PLoLatPreTransition2048) = 0;
			(sequence->data[i]->T2PLoLatPostTransition2048) = 0;
			(sequence->data[i]->T2PHiCapPreTransition2048) = 0;
			(sequence->data[i]->T2PHiCapPostTransition2048) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048_data01_data */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048_data01_data (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072_data01_data** tmp;
		tmp = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072_data01_data**)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072_data01_data*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->LoLatT2PTransition3072) = 0;
			(sequence->data[i]->LoLatTerminationTarget3072) = 0;
			(sequence->data[i]->HiCapT2PTransition3072) = 0;
			(sequence->data[i]->HiCapTerminationTarget3072) = 0;
			(sequence->data[i]->T2PLoLatPreTransition3072) = 0;
			(sequence->data[i]->T2PLoLatPostTransition3072) = 0;
			(sequence->data[i]->T2PHiCapPreTransition3072) = 0;
			(sequence->data[i]->T2PHiCapPostTransition3072) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072_data01_data */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072_data01_data (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096_data01_data** tmp;
		tmp = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096_data01_data**)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096_data01_data*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->LoLatT2PTransition4096) = 0;
			(sequence->data[i]->LoLatTerminationTarget4096) = 0;
			(sequence->data[i]->HiCapT2PTransition4096) = 0;
			(sequence->data[i]->HiCapTerminationTarget4096) = 0;
			(sequence->data[i]->T2PLoLatPreTransition4096) = 0;
			(sequence->data[i]->T2PLoLatPostTransition4096) = 0;
			(sequence->data[i]->T2PHiCapPreTransition4096) = 0;
			(sequence->data[i]->T2PHiCapPostTransition4096) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096_data01_data */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096_data01_data (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144_data01_data** tmp;
		tmp = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144_data01_data**)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144_data01_data*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->LoLatT2PTransition6144) = 0;
			(sequence->data[i]->LoLatTerminationTarget6144) = 0;
			(sequence->data[i]->HiCapT2PTransition6144) = 0;
			(sequence->data[i]->HiCapTerminationTarget6144) = 0;
			(sequence->data[i]->T2PLoLatPreTransition6144) = 0;
			(sequence->data[i]->T2PLoLatPostTransition6144) = 0;
			(sequence->data[i]->T2PHiCapPreTransition6144) = 0;
			(sequence->data[i]->T2PHiCapPostTransition6144) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144_data01_data */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144_data01_data (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192_data01_data** tmp;
		tmp = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192_data01_data**)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192_data01_data*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->LoLatT2PTransition8192) = 0;
			(sequence->data[i]->LoLatTerminationTarget8192) = 0;
			(sequence->data[i]->HiCapT2PTransition8192) = 0;
			(sequence->data[i]->HiCapTerminationTarget8192) = 0;
			(sequence->data[i]->T2PLoLatPreTransition8192) = 0;
			(sequence->data[i]->T2PLoLatPostTransition8192) = 0;
			(sequence->data[i]->T2PHiCapPreTransition8192) = 0;
			(sequence->data[i]->T2PHiCapPostTransition8192) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192_data01_data */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192_data01_data (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288_data01_data** tmp;
		tmp = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288_data01_data**)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288_data01_data*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->LoLatT2PTransition12288) = 0;
			(sequence->data[i]->LoLatTerminationTarget12288) = 0;
			(sequence->data[i]->HiCapT2PTransition12288) = 0;
			(sequence->data[i]->HiCapTerminationTarget12288) = 0;
			(sequence->data[i]->T2PLoLatPreTransition12288) = 0;
			(sequence->data[i]->T2PLoLatPostTransition12288) = 0;
			(sequence->data[i]->T2PHiCapPreTransition12288) = 0;
			(sequence->data[i]->T2PHiCapPostTransition12288) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288_data01_data */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288_data01_data (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters_data01_data** tmp;
		tmp = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters_data01_data**)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters_data01_data*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->ReqRatio) = 0;
			(sequence->data[i]->MaxReqInterval) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters_data01_data */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters_data01_data (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters_data01_data** tmp;
		tmp = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters_data01_data**)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters_data01_data*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->RRIChannelGainPreTransition0) = 0;
			(sequence->data[i]->RRIChannelGainPostTransition0) = 0;
			(sequence->data[i]->RRIChannelGainPreTransition1) = 0;
			(sequence->data[i]->RRIChannelGainPostTransition1) = 0;
			(sequence->data[i]->RRIChannelGainPreTransition2) = 0;
			(sequence->data[i]->RRIChannelGainPostTransition2) = 0;
			(sequence->data[i]->RRIChannelGainPreTransition3) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters_data01_data */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters_data01_data (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2Pmax_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2Pmax_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2Pmax_data01* sequence, int desiredItems)
{
	int i, i0;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2Pmax_data01_data** tmp;
		tmp = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2Pmax_data01_data**)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2Pmax_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2Pmax_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2Pmax_data01_data*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2Pmax_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2Pmax_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->NumPilotStrengthAxisValues) = 0;
			sequence->data[i]->data02.items = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				for (i0=0; i0<sequence->data[i]->data02.items; i0++) {
					EDFree (sequence->data[i]->data02.data[i0]);
					sequence->data[i]->data02.data[i0] = NULL;
				}
				if (sequence->data[i]->data02.data) {EDFree (sequence->data[i]->data02.data); sequence->data[i]->data02.data = NULL; sequence->data[i]->data02.allocatedItems=0; /*FR02A*/}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2Pmax_data01_data */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2Pmax_data01_data (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2Pmax_data01_data* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data02.items; i0++) {
		EDFree (sp->data02.data[i0]);
		sp->data02.data[i0] = NULL;
	}
	if (sp->data02.data) {EDFree (sp->data02.data); sp->data02.data = NULL; sp->data02.allocatedItems=0; /*FR02A*/}

}

/* SETITEMS commands for type 'c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2Pmax_data01_data_data02'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2Pmax_data01_data_data02 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2Pmax_data01_data_data02* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2Pmax_data01_data_data02_data** tmp;
		tmp = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2Pmax_data01_data_data02_data**)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2Pmax_data01_data_data02_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2Pmax_data01_data_data02_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2Pmax_data01_data_data02_data*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2Pmax_data01_data_data02_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2Pmax_data01_data_data02_data));
			(sequence->data[i]->PilotStrengthAxis) = 0;
			(sequence->data[i]->TxT2PmaxPilotStrengthAxis) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2Pmax_data01_data_data02_data */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2Pmax_data01_data_data02_data (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2Pmax_data01_data_data02_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows_data01_data** tmp;
		tmp = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows_data01_data**)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows_data01_data*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->MaxNumMACFlows) = 0;
			(sequence->data[i]->MaxNumActiveMACFlows) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows_data01_data */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows_data01_data (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01* sequence, int desiredItems)
{
	int i, i0;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data** tmp;
		tmp = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data**)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->FlowCount) = 0;
			sequence->data[i]->data02.items = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				for (i0=0; i0<sequence->data[i]->data02.items; i0++) {
					EDFree (sequence->data[i]->data02.data[i0]);
					sequence->data[i]->data02.data[i0] = NULL;
				}
				if (sequence->data[i]->data02.data) {EDFree (sequence->data[i]->data02.data); sequence->data[i]->data02.data = NULL; sequence->data[i]->data02.allocatedItems=0; /*FR02A*/}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data02.items; i0++) {
		EDFree (sp->data02.data[i0]);
		sp->data02.data[i0] = NULL;
	}
	if (sp->data02.data) {EDFree (sp->data02.data); sp->data02.data = NULL; sp->data02.allocatedItems=0; /*FR02A*/}

}

/* SETITEMS commands for type 'c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data_data02'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data_data02 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data_data02* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data_data02_data** tmp;
		tmp = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data_data02_data**)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data_data02_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data_data02_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data_data02_data*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data_data02_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data_data02_data));
			(sequence->data[i]->Stream) = 0;
			(sequence->data[i]->SubStream) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data_data02_data */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data_data02_data (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data_data02_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data** tmp;
		tmp = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data**)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->NumT2PAxisValues) = 0;
			(sequence->data[i]->NumFRABAxisValues) = 0;
			sequence->data[i]->T2PAxis.items = 0;
			sequence->data[i]->FRABAxis.items = 0;
			sequence->data[i]->BucketFactorT2PAxisFRABAxis.items = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->T2PAxis.data) {EDFree (sequence->data[i]->T2PAxis.data); sequence->data[i]->T2PAxis.data = NULL; sequence->data[i]->T2PAxis.allocatedItems=0; /*FR02A*/}
				if (sequence->data[i]->FRABAxis.data) {EDFree (sequence->data[i]->FRABAxis.data); sequence->data[i]->FRABAxis.data = NULL; sequence->data[i]->FRABAxis.allocatedItems=0; /*FR02A*/}
				if (sequence->data[i]->BucketFactorT2PAxisFRABAxis.data) {EDFree (sequence->data[i]->BucketFactorT2PAxisFRABAxis.data); sequence->data[i]->BucketFactorT2PAxisFRABAxis.data = NULL; sequence->data[i]->BucketFactorT2PAxisFRABAxis.allocatedItems=0; /*FR02A*/}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->T2PAxis.data) {EDFree (sp->T2PAxis.data); sp->T2PAxis.data = NULL; sp->T2PAxis.allocatedItems=0; /*FR02A*/}
	if (sp->FRABAxis.data) {EDFree (sp->FRABAxis.data); sp->FRABAxis.data = NULL; sp->FRABAxis.allocatedItems=0; /*FR02A*/}
	if (sp->BucketFactorT2PAxisFRABAxis.data) {EDFree (sp->BucketFactorT2PAxisFRABAxis.data); sp->BucketFactorT2PAxisFRABAxis.data = NULL; sp->BucketFactorT2PAxisFRABAxis.allocatedItems=0; /*FR02A*/}

}

/* SETITEMS commands for type 'c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_T2PAxis'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_T2PAxis (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_T2PAxis* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		ED_OCTET* tmp;
		tmp = (ED_OCTET*)EDAlloc (sizeof (ED_OCTET) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (ED_OCTET) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			(sequence->data[i]) = 0;
		}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* SETITEMS commands for type 'c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_FRABAxis'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_FRABAxis (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_FRABAxis* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		ED_OCTET* tmp;
		tmp = (ED_OCTET*)EDAlloc (sizeof (ED_OCTET) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (ED_OCTET) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			(sequence->data[i]) = 0;
		}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* SETITEMS commands for type 'c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_BucketFactorT2PAxisFRABAxis'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_BucketFactorT2PAxisFRABAxis (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_BucketFactorT2PAxisFRABAxis* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		ED_OCTET* tmp;
		tmp = (ED_OCTET*)EDAlloc (sizeof (ED_OCTET) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (ED_OCTET) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			(sequence->data[i]) = 0;
		}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* SETITEMS commands for type 'c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeNN_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeNN_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeNN_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeNN_data01_data** tmp;
		tmp = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeNN_data01_data**)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeNN_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeNN_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeNN_data01_data*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeNN_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeNN_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->T2PInflowmin) = 0;
			(sequence->data[i]->T2PInflowmax) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeNN_data01_data */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeNN_data01_data (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeNN_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01* sequence, int desiredItems)
{
	int i, i0;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data** tmp;
		tmp = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data**)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->NumT2PAxisValues) = 0;
			(sequence->data[i]->NumFRABAxisValues) = 0;
			sequence->data[i]->data02.items = 0;
			sequence->data[i]->data03.items = 0;
			sequence->data[i]->data04.items = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				for (i0=0; i0<sequence->data[i]->data02.items; i0++) {
					EDFree (sequence->data[i]->data02.data[i0]);
					sequence->data[i]->data02.data[i0] = NULL;
				}
				if (sequence->data[i]->data02.data) {EDFree (sequence->data[i]->data02.data); sequence->data[i]->data02.data = NULL; sequence->data[i]->data02.allocatedItems=0; /*FR02A*/}
				for (i0=0; i0<sequence->data[i]->data03.items; i0++) {
					EDFree (sequence->data[i]->data03.data[i0]);
					sequence->data[i]->data03.data[i0] = NULL;
				}
				if (sequence->data[i]->data03.data) {EDFree (sequence->data[i]->data03.data); sequence->data[i]->data03.data = NULL; sequence->data[i]->data03.allocatedItems=0; /*FR02A*/}
				for (i0=0; i0<sequence->data[i]->data04.items; i0++) {
					EDFree (sequence->data[i]->data04.data[i0]);
					sequence->data[i]->data04.data[i0] = NULL;
				}
				if (sequence->data[i]->data04.data) {EDFree (sequence->data[i]->data04.data); sequence->data[i]->data04.data = NULL; sequence->data[i]->data04.allocatedItems=0; /*FR02A*/}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data02.items; i0++) {
		EDFree (sp->data02.data[i0]);
		sp->data02.data[i0] = NULL;
	}
	if (sp->data02.data) {EDFree (sp->data02.data); sp->data02.data = NULL; sp->data02.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data03.items; i0++) {
		EDFree (sp->data03.data[i0]);
		sp->data03.data[i0] = NULL;
	}
	if (sp->data03.data) {EDFree (sp->data03.data); sp->data03.data = NULL; sp->data03.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data04.items; i0++) {
		EDFree (sp->data04.data[i0]);
		sp->data04.data[i0] = NULL;
	}
	if (sp->data04.data) {EDFree (sp->data04.data); sp->data04.data = NULL; sp->data04.allocatedItems=0; /*FR02A*/}

}

/* SETITEMS commands for type 'c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data02'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data02 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data02* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data02_data** tmp;
		tmp = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data02_data**)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data02_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data02_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data02_data*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data02_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data02_data));
			(sequence->data[i]->T2PAxis) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data02_data */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data02_data (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data02_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data03'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data03 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data03* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data03_data** tmp;
		tmp = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data03_data**)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data03_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data03_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data03_data*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data03_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data03_data));
			(sequence->data[i]->FRABAxis) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data03_data */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data03_data (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data03_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data04'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data04 (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data04* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data04_data** tmp;
		tmp = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data04_data**)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data04_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data04_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data04_data*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data04_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data04_data));
			(sequence->data[i]->T2PUpT2PAxisFRABAxis) = 0;
			(sequence->data[i]->T2PDnT2PAxisFRABAxis) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data04_data */
void FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data04_data (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN_data01_data_data04_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters_data01_data** tmp;
		tmp = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters_data01_data**)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters_data01_data*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->AuxiliaryPilotChannelGain) = 0;
			(sequence->data[i]->AuxiliaryPilotChannelMinPayload) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters_data01_data */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters_data01_data (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters_data01_data** tmp;
		tmp = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters_data01_data**)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters_data01_data*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->AllocationStagger) = 0;
			(sequence->data[i]->TxT2Pmin) = 0;
			(sequence->data[i]->RPCStep) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters_data01_data */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters_data01_data (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload_data01_data** tmp;
		tmp = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload_data01_data**)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload_data01_data*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->PermittedPayload0_1) = 0;
			(sequence->data[i]->PermittedPayload0_2) = 0;
			(sequence->data[i]->PermittedPayload0_3) = 0;
			(sequence->data[i]->PermittedPayload128_1) = 0;
			(sequence->data[i]->PermittedPayload128_2) = 0;
			(sequence->data[i]->PermittedPayload128_3) = 0;
			(sequence->data[i]->PermittedPayload256_1) = 0;
			(sequence->data[i]->PermittedPayload256_2) = 0;
			(sequence->data[i]->PermittedPayload256_3) = 0;
			(sequence->data[i]->PermittedPayload512_1) = 0;
			(sequence->data[i]->PermittedPayload512_2) = 0;
			(sequence->data[i]->PermittedPayload512_3) = 0;
			(sequence->data[i]->PermittedPayload768_1) = 0;
			(sequence->data[i]->PermittedPayload768_2) = 0;
			(sequence->data[i]->PermittedPayload768_3) = 0;
			(sequence->data[i]->PermittedPayload1024_1) = 0;
			(sequence->data[i]->PermittedPayload1024_2) = 0;
			(sequence->data[i]->PermittedPayload1024_3) = 0;
			(sequence->data[i]->PermittedPayload1536_1) = 0;
			(sequence->data[i]->PermittedPayload1536_2) = 0;
			(sequence->data[i]->PermittedPayload1536_3) = 0;
			(sequence->data[i]->PermittedPayload2048_1) = 0;
			(sequence->data[i]->PermittedPayload2048_2) = 0;
			(sequence->data[i]->PermittedPayload2048_3) = 0;
			(sequence->data[i]->PermittedPayload3072_1) = 0;
			(sequence->data[i]->PermittedPayload3072_2) = 0;
			(sequence->data[i]->PermittedPayload3072_3) = 0;
			(sequence->data[i]->PermittedPayload4096_1) = 0;
			(sequence->data[i]->PermittedPayload4096_2) = 0;
			(sequence->data[i]->PermittedPayload4096_3) = 0;
			(sequence->data[i]->PermittedPayload6144_1) = 0;
			(sequence->data[i]->PermittedPayload6144_2) = 0;
			(sequence->data[i]->PermittedPayload6144_3) = 0;
			(sequence->data[i]->PermittedPayload8192_1) = 0;
			(sequence->data[i]->PermittedPayload8192_2) = 0;
			(sequence->data[i]->PermittedPayload8192_3) = 0;
			(sequence->data[i]->PermittedPayload12288_1) = 0;
			(sequence->data[i]->PermittedPayload12288_2) = 0;
			(sequence->data[i]->PermittedPayload12288_3) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload_data01_data */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload_data01_data (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128_data01_data** tmp;
		tmp = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128_data01_data**)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128_data01_data*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->LoLatT2PTransition128) = 0;
			(sequence->data[i]->LoLatTerminationTarget128) = 0;
			(sequence->data[i]->HiCapT2PTransition128) = 0;
			(sequence->data[i]->HiCapTerminationTarget128) = 0;
			(sequence->data[i]->T2PLoLatPreTransition128) = 0;
			(sequence->data[i]->T2PLoLatPostTransition128) = 0;
			(sequence->data[i]->T2PHiCapPreTransition128) = 0;
			(sequence->data[i]->T2PHiCapPostTransition128) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128_data01_data */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128_data01_data (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256_data01_data** tmp;
		tmp = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256_data01_data**)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256_data01_data*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->LoLatT2PTransition256) = 0;
			(sequence->data[i]->LoLatTerminationTarget256) = 0;
			(sequence->data[i]->HiCapT2PTransition256) = 0;
			(sequence->data[i]->HiCapTerminationTarget256) = 0;
			(sequence->data[i]->T2PLoLatPreTransition256) = 0;
			(sequence->data[i]->T2PLoLatPostTransition256) = 0;
			(sequence->data[i]->T2PHiCapPreTransition256) = 0;
			(sequence->data[i]->T2PHiCapPostTransition256) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256_data01_data */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256_data01_data (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512_data01_data** tmp;
		tmp = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512_data01_data**)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512_data01_data*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->LoLatT2PTransition512) = 0;
			(sequence->data[i]->LoLatTerminationTarget512) = 0;
			(sequence->data[i]->HiCapT2PTransition512) = 0;
			(sequence->data[i]->HiCapTerminationTarget512) = 0;
			(sequence->data[i]->T2PLoLatPreTransition512) = 0;
			(sequence->data[i]->T2PLoLatPostTransition512) = 0;
			(sequence->data[i]->T2PHiCapPreTransition512) = 0;
			(sequence->data[i]->T2PHiCapPostTransition512) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512_data01_data */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512_data01_data (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768_data01_data** tmp;
		tmp = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768_data01_data**)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768_data01_data*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->LoLatT2PTransition768) = 0;
			(sequence->data[i]->LoLatTerminationTarget768) = 0;
			(sequence->data[i]->HiCapT2PTransition768) = 0;
			(sequence->data[i]->HiCapTerminationTarget768) = 0;
			(sequence->data[i]->T2PLoLatPreTransition768) = 0;
			(sequence->data[i]->T2PLoLatPostTransition768) = 0;
			(sequence->data[i]->T2PHiCapPreTransition768) = 0;
			(sequence->data[i]->T2PHiCapPostTransition768) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768_data01_data */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768_data01_data (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024_data01_data** tmp;
		tmp = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024_data01_data**)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024_data01_data*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->LoLatT2PTransition1024) = 0;
			(sequence->data[i]->LoLatTerminationTarget1024) = 0;
			(sequence->data[i]->HiCapT2PTransition1024) = 0;
			(sequence->data[i]->HiCapTerminationTarget1024) = 0;
			(sequence->data[i]->T2PLoLatPreTransition1024) = 0;
			(sequence->data[i]->T2PLoLatPostTransition1024) = 0;
			(sequence->data[i]->T2PHiCapPreTransition1024) = 0;
			(sequence->data[i]->T2PHiCapPostTransition1024) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024_data01_data */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024_data01_data (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536_data01_data** tmp;
		tmp = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536_data01_data**)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536_data01_data*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->LoLatT2PTransition1536) = 0;
			(sequence->data[i]->LoLatTerminationTarget1536) = 0;
			(sequence->data[i]->HiCapT2PTransition1536) = 0;
			(sequence->data[i]->HiCapTerminationTarget1536) = 0;
			(sequence->data[i]->T2PLoLatPreTransition1536) = 0;
			(sequence->data[i]->T2PLoLatPostTransition1536) = 0;
			(sequence->data[i]->T2PHiCapPreTransition1536) = 0;
			(sequence->data[i]->T2PHiCapPostTransition1536) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536_data01_data */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536_data01_data (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048_data01_data** tmp;
		tmp = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048_data01_data**)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048_data01_data*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->LoLatT2PTransition2048) = 0;
			(sequence->data[i]->LoLatTerminationTarget2048) = 0;
			(sequence->data[i]->HiCapT2PTransition2048) = 0;
			(sequence->data[i]->HiCapTerminationTarget2048) = 0;
			(sequence->data[i]->T2PLoLatPreTransition2048) = 0;
			(sequence->data[i]->T2PLoLatPostTransition2048) = 0;
			(sequence->data[i]->T2PHiCapPreTransition2048) = 0;
			(sequence->data[i]->T2PHiCapPostTransition2048) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048_data01_data */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048_data01_data (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072_data01_data** tmp;
		tmp = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072_data01_data**)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072_data01_data*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->LoLatT2PTransition3072) = 0;
			(sequence->data[i]->LoLatTerminationTarget3072) = 0;
			(sequence->data[i]->HiCapT2PTransition3072) = 0;
			(sequence->data[i]->HiCapTerminationTarget3072) = 0;
			(sequence->data[i]->T2PLoLatPreTransition3072) = 0;
			(sequence->data[i]->T2PLoLatPostTransition3072) = 0;
			(sequence->data[i]->T2PHiCapPreTransition3072) = 0;
			(sequence->data[i]->T2PHiCapPostTransition3072) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072_data01_data */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072_data01_data (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096_data01_data** tmp;
		tmp = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096_data01_data**)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096_data01_data*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->LoLatT2PTransition4096) = 0;
			(sequence->data[i]->LoLatTerminationTarget4096) = 0;
			(sequence->data[i]->HiCapT2PTransition4096) = 0;
			(sequence->data[i]->HiCapTerminationTarget4096) = 0;
			(sequence->data[i]->T2PLoLatPreTransition4096) = 0;
			(sequence->data[i]->T2PLoLatPostTransition4096) = 0;
			(sequence->data[i]->T2PHiCapPreTransition4096) = 0;
			(sequence->data[i]->T2PHiCapPostTransition4096) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096_data01_data */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096_data01_data (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144_data01_data** tmp;
		tmp = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144_data01_data**)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144_data01_data*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->LoLatT2PTransition6144) = 0;
			(sequence->data[i]->LoLatTerminationTarget6144) = 0;
			(sequence->data[i]->HiCapT2PTransition6144) = 0;
			(sequence->data[i]->HiCapTerminationTarget6144) = 0;
			(sequence->data[i]->T2PLoLatPreTransition6144) = 0;
			(sequence->data[i]->T2PLoLatPostTransition6144) = 0;
			(sequence->data[i]->T2PHiCapPreTransition6144) = 0;
			(sequence->data[i]->T2PHiCapPostTransition6144) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144_data01_data */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144_data01_data (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192_data01_data** tmp;
		tmp = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192_data01_data**)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192_data01_data*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->LoLatT2PTransition8192) = 0;
			(sequence->data[i]->LoLatTerminationTarget8192) = 0;
			(sequence->data[i]->HiCapT2PTransition8192) = 0;
			(sequence->data[i]->HiCapTerminationTarget8192) = 0;
			(sequence->data[i]->T2PLoLatPreTransition8192) = 0;
			(sequence->data[i]->T2PLoLatPostTransition8192) = 0;
			(sequence->data[i]->T2PHiCapPreTransition8192) = 0;
			(sequence->data[i]->T2PHiCapPostTransition8192) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192_data01_data */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192_data01_data (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288_data01_data** tmp;
		tmp = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288_data01_data**)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288_data01_data*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->LoLatT2PTransition12288) = 0;
			(sequence->data[i]->LoLatTerminationTarget12288) = 0;
			(sequence->data[i]->HiCapT2PTransition12288) = 0;
			(sequence->data[i]->HiCapTerminationTarget12288) = 0;
			(sequence->data[i]->T2PLoLatPreTransition12288) = 0;
			(sequence->data[i]->T2PLoLatPostTransition12288) = 0;
			(sequence->data[i]->T2PHiCapPreTransition12288) = 0;
			(sequence->data[i]->T2PHiCapPostTransition12288) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288_data01_data */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288_data01_data (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters_data01_data** tmp;
		tmp = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters_data01_data**)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters_data01_data*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->ReqRatio) = 0;
			(sequence->data[i]->MaxReqInterval) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters_data01_data */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters_data01_data (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters_data01_data** tmp;
		tmp = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters_data01_data**)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters_data01_data*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->RRIChannelGainPreTransition0) = 0;
			(sequence->data[i]->RRIChannelGainPostTransition0) = 0;
			(sequence->data[i]->RRIChannelGainPreTransition1) = 0;
			(sequence->data[i]->RRIChannelGainPostTransition1) = 0;
			(sequence->data[i]->RRIChannelGainPreTransition2) = 0;
			(sequence->data[i]->RRIChannelGainPostTransition2) = 0;
			(sequence->data[i]->RRIChannelGainPreTransition3) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters_data01_data */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters_data01_data (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows_data01_data** tmp;
		tmp = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows_data01_data**)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows_data01_data*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->MaxNumMACFlows) = 0;
			(sequence->data[i]->MaxNumActiveMACFlows) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows_data01_data */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows_data01_data (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01* sequence, int desiredItems)
{
	int i, i0;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data** tmp;
		tmp = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data**)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->FlowCount) = 0;
			sequence->data[i]->data02.items = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				for (i0=0; i0<sequence->data[i]->data02.items; i0++) {
					EDFree (sequence->data[i]->data02.data[i0]);
					sequence->data[i]->data02.data[i0] = NULL;
				}
				if (sequence->data[i]->data02.data) {EDFree (sequence->data[i]->data02.data); sequence->data[i]->data02.data = NULL; sequence->data[i]->data02.allocatedItems=0; /*FR02A*/}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data02.items; i0++) {
		EDFree (sp->data02.data[i0]);
		sp->data02.data[i0] = NULL;
	}
	if (sp->data02.data) {EDFree (sp->data02.data); sp->data02.data = NULL; sp->data02.allocatedItems=0; /*FR02A*/}

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data_data02'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data_data02 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data_data02* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data_data02_data** tmp;
		tmp = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data_data02_data**)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data_data02_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data_data02_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data_data02_data*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data_data02_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data_data02_data));
			(sequence->data[i]->Stream) = 0;
			(sequence->data[i]->SubStream) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data_data02_data */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data_data02_data (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN_data01_data_data02_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01* sequence, int desiredItems)
{
	int i, i0, i1, i2;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data** tmp;
		tmp = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data**)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->NumT2PAxisValues) = 0;
			(sequence->data[i]->NumFRABAxisValues) = 0;
			sequence->data[i]->data02.items = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				for (i0=0; i0<sequence->data[i]->data02.items; i0++) {
					for (i1=0; i1<sequence->data[i]->data02.data[i0]->data03.items; i1++) {
						for (i2=0; i2<sequence->data[i]->data02.data[i0]->data03.data[i1]->data04.items; i2++) {
							EDFree (sequence->data[i]->data02.data[i0]->data03.data[i1]->data04.data[i2]);
							sequence->data[i]->data02.data[i0]->data03.data[i1]->data04.data[i2] = NULL;
						}
						if (sequence->data[i]->data02.data[i0]->data03.data[i1]->data04.data) {EDFree (sequence->data[i]->data02.data[i0]->data03.data[i1]->data04.data); sequence->data[i]->data02.data[i0]->data03.data[i1]->data04.data = NULL; sequence->data[i]->data02.data[i0]->data03.data[i1]->data04.allocatedItems=0; /*FR02A*/}
						EDFree (sequence->data[i]->data02.data[i0]->data03.data[i1]);
						sequence->data[i]->data02.data[i0]->data03.data[i1] = NULL;
					}
					if (sequence->data[i]->data02.data[i0]->data03.data) {EDFree (sequence->data[i]->data02.data[i0]->data03.data); sequence->data[i]->data02.data[i0]->data03.data = NULL; sequence->data[i]->data02.data[i0]->data03.allocatedItems=0; /*FR02A*/}
					EDFree (sequence->data[i]->data02.data[i0]);
					sequence->data[i]->data02.data[i0] = NULL;
				}
				if (sequence->data[i]->data02.data) {EDFree (sequence->data[i]->data02.data); sequence->data[i]->data02.data = NULL; sequence->data[i]->data02.allocatedItems=0; /*FR02A*/}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data* sp) {
	int i0;
	int i1;
	int i2;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data02.items; i0++) {
		for (i1=0; i1<sp->data02.data[i0]->data03.items; i1++) {
			for (i2=0; i2<sp->data02.data[i0]->data03.data[i1]->data04.items; i2++) {
				EDFree (sp->data02.data[i0]->data03.data[i1]->data04.data[i2]);
				sp->data02.data[i0]->data03.data[i1]->data04.data[i2] = NULL;
			}
			if (sp->data02.data[i0]->data03.data[i1]->data04.data) {EDFree (sp->data02.data[i0]->data03.data[i1]->data04.data); sp->data02.data[i0]->data03.data[i1]->data04.data = NULL; sp->data02.data[i0]->data03.data[i1]->data04.allocatedItems=0; /*FR02A*/}
			EDFree (sp->data02.data[i0]->data03.data[i1]);
			sp->data02.data[i0]->data03.data[i1] = NULL;
		}
		if (sp->data02.data[i0]->data03.data) {EDFree (sp->data02.data[i0]->data03.data); sp->data02.data[i0]->data03.data = NULL; sp->data02.data[i0]->data03.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data02.data[i0]);
		sp->data02.data[i0] = NULL;
	}
	if (sp->data02.data) {EDFree (sp->data02.data); sp->data02.data = NULL; sp->data02.allocatedItems=0; /*FR02A*/}

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02* sequence, int desiredItems)
{
	int i, i0, i1;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data** tmp;
		tmp = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data**)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data));
			(sequence->data[i]->T2PAxis) = 0;
			sequence->data[i]->data03.items = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				for (i0=0; i0<sequence->data[i]->data03.items; i0++) {
					for (i1=0; i1<sequence->data[i]->data03.data[i0]->data04.items; i1++) {
						EDFree (sequence->data[i]->data03.data[i0]->data04.data[i1]);
						sequence->data[i]->data03.data[i0]->data04.data[i1] = NULL;
					}
					if (sequence->data[i]->data03.data[i0]->data04.data) {EDFree (sequence->data[i]->data03.data[i0]->data04.data); sequence->data[i]->data03.data[i0]->data04.data = NULL; sequence->data[i]->data03.data[i0]->data04.allocatedItems=0; /*FR02A*/}
					EDFree (sequence->data[i]->data03.data[i0]);
					sequence->data[i]->data03.data[i0] = NULL;
				}
				if (sequence->data[i]->data03.data) {EDFree (sequence->data[i]->data03.data); sequence->data[i]->data03.data = NULL; sequence->data[i]->data03.allocatedItems=0; /*FR02A*/}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data* sp) {
	int i0;
	int i1;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data03.items; i0++) {
		for (i1=0; i1<sp->data03.data[i0]->data04.items; i1++) {
			EDFree (sp->data03.data[i0]->data04.data[i1]);
			sp->data03.data[i0]->data04.data[i1] = NULL;
		}
		if (sp->data03.data[i0]->data04.data) {EDFree (sp->data03.data[i0]->data04.data); sp->data03.data[i0]->data04.data = NULL; sp->data03.data[i0]->data04.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data03.data[i0]);
		sp->data03.data[i0] = NULL;
	}
	if (sp->data03.data) {EDFree (sp->data03.data); sp->data03.data = NULL; sp->data03.allocatedItems=0; /*FR02A*/}

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data_data03'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data_data03 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data_data03* sequence, int desiredItems)
{
	int i, i0;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data_data03_data** tmp;
		tmp = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data_data03_data**)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data_data03_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data_data03_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data_data03_data*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data_data03_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data_data03_data));
			(sequence->data[i]->FRABAxis) = 0;
			sequence->data[i]->data04.items = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				for (i0=0; i0<sequence->data[i]->data04.items; i0++) {
					EDFree (sequence->data[i]->data04.data[i0]);
					sequence->data[i]->data04.data[i0] = NULL;
				}
				if (sequence->data[i]->data04.data) {EDFree (sequence->data[i]->data04.data); sequence->data[i]->data04.data = NULL; sequence->data[i]->data04.allocatedItems=0; /*FR02A*/}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data_data03_data */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data_data03_data (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data_data03_data* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data04.items; i0++) {
		EDFree (sp->data04.data[i0]);
		sp->data04.data[i0] = NULL;
	}
	if (sp->data04.data) {EDFree (sp->data04.data); sp->data04.data = NULL; sp->data04.allocatedItems=0; /*FR02A*/}

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data_data03_data_data04'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data_data03_data_data04 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data_data03_data_data04* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data_data03_data_data04_data** tmp;
		tmp = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data_data03_data_data04_data**)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data_data03_data_data04_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data_data03_data_data04_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data_data03_data_data04_data*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data_data03_data_data04_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data_data03_data_data04_data));
			(sequence->data[i]->BucketFactorT2PAxisFRABAxis) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data_data03_data_data04_data */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data_data03_data_data04_data (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN_data01_data_data02_data_data03_data_data04_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeConfigXX_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeConfigXX_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeConfigXX_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeConfigXX_data01_data** tmp;
		tmp = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeConfigXX_data01_data**)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeConfigXX_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeConfigXX_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeConfigXX_data01_data*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeConfigXX_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeConfigXX_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->T2PInflowmin) = 0;
			(sequence->data[i]->T2PInflowmax) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeConfigXX_data01_data */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeConfigXX_data01_data (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeConfigXX_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01* sequence, int desiredItems)
{
	int i, i0;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data** tmp;
		tmp = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data**)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->NumT2PAxisValues) = 0;
			(sequence->data[i]->NumFRABAxisValues) = 0;
			sequence->data[i]->data02.items = 0;
			sequence->data[i]->data03.items = 0;
			sequence->data[i]->data04.items = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				for (i0=0; i0<sequence->data[i]->data02.items; i0++) {
					EDFree (sequence->data[i]->data02.data[i0]);
					sequence->data[i]->data02.data[i0] = NULL;
				}
				if (sequence->data[i]->data02.data) {EDFree (sequence->data[i]->data02.data); sequence->data[i]->data02.data = NULL; sequence->data[i]->data02.allocatedItems=0; /*FR02A*/}
				for (i0=0; i0<sequence->data[i]->data03.items; i0++) {
					EDFree (sequence->data[i]->data03.data[i0]);
					sequence->data[i]->data03.data[i0] = NULL;
				}
				if (sequence->data[i]->data03.data) {EDFree (sequence->data[i]->data03.data); sequence->data[i]->data03.data = NULL; sequence->data[i]->data03.allocatedItems=0; /*FR02A*/}
				for (i0=0; i0<sequence->data[i]->data04.items; i0++) {
					EDFree (sequence->data[i]->data04.data[i0]);
					sequence->data[i]->data04.data[i0] = NULL;
				}
				if (sequence->data[i]->data04.data) {EDFree (sequence->data[i]->data04.data); sequence->data[i]->data04.data = NULL; sequence->data[i]->data04.allocatedItems=0; /*FR02A*/}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data02.items; i0++) {
		EDFree (sp->data02.data[i0]);
		sp->data02.data[i0] = NULL;
	}
	if (sp->data02.data) {EDFree (sp->data02.data); sp->data02.data = NULL; sp->data02.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data03.items; i0++) {
		EDFree (sp->data03.data[i0]);
		sp->data03.data[i0] = NULL;
	}
	if (sp->data03.data) {EDFree (sp->data03.data); sp->data03.data = NULL; sp->data03.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data04.items; i0++) {
		EDFree (sp->data04.data[i0]);
		sp->data04.data[i0] = NULL;
	}
	if (sp->data04.data) {EDFree (sp->data04.data); sp->data04.data = NULL; sp->data04.allocatedItems=0; /*FR02A*/}

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data02'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data02 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data02* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data02_data** tmp;
		tmp = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data02_data**)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data02_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data02_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data02_data*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data02_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data02_data));
			(sequence->data[i]->T2PAxis) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data02_data */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data02_data (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data02_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data03'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data03 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data03* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data03_data** tmp;
		tmp = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data03_data**)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data03_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data03_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data03_data*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data03_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data03_data));
			(sequence->data[i]->FRABAxis) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data03_data */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data03_data (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data03_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data04'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data04 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data04* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data04_data** tmp;
		tmp = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data04_data**)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data04_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data04_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data04_data*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data04_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data04_data));
			(sequence->data[i]->T2PUpT2PAxisFRABAxis) = 0;
			(sequence->data[i]->T2PDnT2PAxisFRABAxis) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data04_data */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data04_data (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX_data01_data_data04_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowConfigurationsNC_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowConfigurationsNC_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowConfigurationsNC_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowConfigurationsNC_data01_data** tmp;
		tmp = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowConfigurationsNC_data01_data**)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowConfigurationsNC_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowConfigurationsNC_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowConfigurationsNC_data01_data*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowConfigurationsNC_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowConfigurationsNC_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->T2PTransitionFunction) = 0;
			(sequence->data[i]->T2PInflowRange) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowConfigurationsNC_data01_data */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowConfigurationsNC_data01_data (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowConfigurationsNC_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedATConfigurationsCC_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedATConfigurationsCC_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedATConfigurationsCC_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedATConfigurationsCC_data01_data** tmp;
		tmp = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedATConfigurationsCC_data01_data**)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedATConfigurationsCC_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedATConfigurationsCC_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedATConfigurationsCC_data01_data*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedATConfigurationsCC_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedATConfigurationsCC_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->PilotStrength) = 0;
			(sequence->data[i]->TxT2PMax) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedATConfigurationsCC_data01_data */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedATConfigurationsCC_data01_data (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedATConfigurationsCC_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_DataTokenBucketNN_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_DataTokenBucketNN_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_DataTokenBucketNN_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_DataTokenBucketNN_data01_data** tmp;
		tmp = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_DataTokenBucketNN_data01_data**)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_DataTokenBucketNN_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_DataTokenBucketNN_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_DataTokenBucketNN_data01_data*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_DataTokenBucketNN_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_DataTokenBucketNN_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->DataTokenInflow) = 0;
			(sequence->data[i]->DataBucketLevelMax) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_DataTokenBucketNN_data01_data */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_DataTokenBucketNN_data01_data (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_DataTokenBucketNN_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPacketsCC_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPacketsCC_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPacketsCC_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPacketsCC_data01_data** tmp;
		tmp = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPacketsCC_data01_data**)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPacketsCC_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPacketsCC_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPacketsCC_data01_data*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPacketsCC_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPacketsCC_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->MaxNumSubPackets0) = 0;
			(sequence->data[i]->MaxNumSubPackets1) = 0;
			(sequence->data[i]->MaxNumSubPackets2) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPacketsCC_data01_data */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPacketsCC_data01_data (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPacketsCC_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrengthConfigXX_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrengthConfigXX_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrengthConfigXX_data01* sequence, int desiredItems)
{
	int i, i0;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrengthConfigXX_data01_data** tmp;
		tmp = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrengthConfigXX_data01_data**)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrengthConfigXX_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrengthConfigXX_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrengthConfigXX_data01_data*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrengthConfigXX_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrengthConfigXX_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->NumPilotStrengthAxisValues) = 0;
			sequence->data[i]->data02.items = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				for (i0=0; i0<sequence->data[i]->data02.items; i0++) {
					EDFree (sequence->data[i]->data02.data[i0]);
					sequence->data[i]->data02.data[i0] = NULL;
				}
				if (sequence->data[i]->data02.data) {EDFree (sequence->data[i]->data02.data); sequence->data[i]->data02.data = NULL; sequence->data[i]->data02.allocatedItems=0; /*FR02A*/}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrengthConfigXX_data01_data */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrengthConfigXX_data01_data (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrengthConfigXX_data01_data* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data02.items; i0++) {
		EDFree (sp->data02.data[i0]);
		sp->data02.data[i0] = NULL;
	}
	if (sp->data02.data) {EDFree (sp->data02.data); sp->data02.data = NULL; sp->data02.allocatedItems=0; /*FR02A*/}

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrengthConfigXX_data01_data_data02'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrengthConfigXX_data01_data_data02 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrengthConfigXX_data01_data_data02* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrengthConfigXX_data01_data_data02_data** tmp;
		tmp = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrengthConfigXX_data01_data_data02_data**)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrengthConfigXX_data01_data_data02_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrengthConfigXX_data01_data_data02_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrengthConfigXX_data01_data_data02_data*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrengthConfigXX_data01_data_data02_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrengthConfigXX_data01_data_data02_data));
			(sequence->data[i]->PilotStrengthAxis) = 0;
			(sequence->data[i]->PilotStrengthPilotStrengthAxis) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrengthConfigXX_data01_data_data02_data */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrengthConfigXX_data01_data_data02_data (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrengthConfigXX_data01_data_data02_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2PmaxConfigXX_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2PmaxConfigXX_data01 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2PmaxConfigXX_data01* sequence, int desiredItems)
{
	int i, i0;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2PmaxConfigXX_data01_data** tmp;
		tmp = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2PmaxConfigXX_data01_data**)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2PmaxConfigXX_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2PmaxConfigXX_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2PmaxConfigXX_data01_data*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2PmaxConfigXX_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2PmaxConfigXX_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->NumPilotStrengthAxisValues) = 0;
			sequence->data[i]->data02.items = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				for (i0=0; i0<sequence->data[i]->data02.items; i0++) {
					EDFree (sequence->data[i]->data02.data[i0]);
					sequence->data[i]->data02.data[i0] = NULL;
				}
				if (sequence->data[i]->data02.data) {EDFree (sequence->data[i]->data02.data); sequence->data[i]->data02.data = NULL; sequence->data[i]->data02.allocatedItems=0; /*FR02A*/}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2PmaxConfigXX_data01_data */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2PmaxConfigXX_data01_data (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2PmaxConfigXX_data01_data* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data02.items; i0++) {
		EDFree (sp->data02.data[i0]);
		sp->data02.data[i0] = NULL;
	}
	if (sp->data02.data) {EDFree (sp->data02.data); sp->data02.data = NULL; sp->data02.allocatedItems=0; /*FR02A*/}

}

/* SETITEMS commands for type 'c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2PmaxConfigXX_data01_data_data02'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2PmaxConfigXX_data01_data_data02 (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2PmaxConfigXX_data01_data_data02* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2PmaxConfigXX_data01_data_data02_data** tmp;
		tmp = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2PmaxConfigXX_data01_data_data02_data**)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2PmaxConfigXX_data01_data_data02_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2PmaxConfigXX_data01_data_data02_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2PmaxConfigXX_data01_data_data02_data*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2PmaxConfigXX_data01_data_data02_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2PmaxConfigXX_data01_data_data02_data));
			(sequence->data[i]->PilotStrengthAxis) = 0;
			(sequence->data[i]->TxT2PmaxPilotStrengthAxis) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2PmaxConfigXX_data01_data_data02_data */
void FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2PmaxConfigXX_data01_data_data02_data (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2PmaxConfigXX_data01_data_data02_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01 (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01* sequence, int desiredItems)
{
	int i, i0, i1;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data** tmp;
		tmp = (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data**)EDAlloc (sizeof (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data*)EDAlloc (sizeof (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->AdditionalCarriersAssigned) = 0;
			(sequence->data[i]->ReferenceCDMAChannel) = 0;
			(sequence->data[i]->NumAdditionalRLCDMAChannelsAssigned) = 0;
			sequence->data[i]->data02.items = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				for (i0=0; i0<sequence->data[i]->data02.items; i0++) {
					for (i1=0; i1<sequence->data[i]->data02.data[i0]->data03.items; i1++) {
						EDFree (sequence->data[i]->data02.data[i0]->data03.data[i1]);
						sequence->data[i]->data02.data[i0]->data03.data[i1] = NULL;
					}
					if (sequence->data[i]->data02.data[i0]->data03.data) {EDFree (sequence->data[i]->data02.data[i0]->data03.data); sequence->data[i]->data02.data[i0]->data03.data = NULL; sequence->data[i]->data02.data[i0]->data03.allocatedItems=0; /*FR02A*/}
					EDFree (sequence->data[i]->data02.data[i0]);
					sequence->data[i]->data02.data[i0] = NULL;
				}
				if (sequence->data[i]->data02.data) {EDFree (sequence->data[i]->data02.data); sequence->data[i]->data02.data = NULL; sequence->data[i]->data02.allocatedItems=0; /*FR02A*/}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data */
void FREE_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data* sp) {
	int i0;
	int i1;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data02.items; i0++) {
		for (i1=0; i1<sp->data02.data[i0]->data03.items; i1++) {
			EDFree (sp->data02.data[i0]->data03.data[i1]);
			sp->data02.data[i0]->data03.data[i1] = NULL;
		}
		if (sp->data02.data[i0]->data03.data) {EDFree (sp->data02.data[i0]->data03.data); sp->data02.data[i0]->data03.data = NULL; sp->data02.data[i0]->data03.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data02.data[i0]);
		sp->data02.data[i0] = NULL;
	}
	if (sp->data02.data) {EDFree (sp->data02.data); sp->data02.data = NULL; sp->data02.allocatedItems=0; /*FR02A*/}

}

/* SETITEMS commands for type 'c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data_data02'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data_data02 (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data_data02* sequence, int desiredItems)
{
	int i, i0;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data_data02_data** tmp;
		tmp = (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data_data02_data**)EDAlloc (sizeof (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data_data02_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data_data02_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data_data02_data*)EDAlloc (sizeof (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data_data02_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data_data02_data));
			(sequence->data[i]->ReverseCDMAChannel) = 0;
			(sequence->data[i]->NumSectors) = 0;
			sequence->data[i]->data03.items = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				for (i0=0; i0<sequence->data[i]->data03.items; i0++) {
					EDFree (sequence->data[i]->data03.data[i0]);
					sequence->data[i]->data03.data[i0] = NULL;
				}
				if (sequence->data[i]->data03.data) {EDFree (sequence->data[i]->data03.data); sequence->data[i]->data03.data = NULL; sequence->data[i]->data03.allocatedItems=0; /*FR02A*/}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data_data02_data */
void FREE_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data_data02_data (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data_data02_data* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data03.items; i0++) {
		EDFree (sp->data03.data[i0]);
		sp->data03.data[i0] = NULL;
	}
	if (sp->data03.data) {EDFree (sp->data03.data); sp->data03.data = NULL; sp->data03.allocatedItems=0; /*FR02A*/}

}

/* SETITEMS commands for type 'c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data_data02_data_data03'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data_data02_data_data03 (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data_data02_data_data03* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data_data02_data_data03_data** tmp;
		tmp = (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data_data02_data_data03_data**)EDAlloc (sizeof (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data_data02_data_data03_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data_data02_data_data03_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data_data02_data_data03_data*)EDAlloc (sizeof (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data_data02_data_data03_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data_data02_data_data03_data));
			(sequence->data[i]->PilotPNOffset) = 0;
			(sequence->data[i]->TxInitAdjustRelativeToReferenceCDMAChannel) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data_data02_data_data03_data */
void FREE_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data_data02_data_data03_data (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower_data01_data_data02_data_data03_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_ReversePilotTransmitSlots_data01'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_ReversePilotTransmitSlots_data01 (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_ReversePilotTransmitSlots_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_ReversePilotTransmitSlots_data01_data** tmp;
		tmp = (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_ReversePilotTransmitSlots_data01_data**)EDAlloc (sizeof (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_ReversePilotTransmitSlots_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_ReversePilotTransmitSlots_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_ReversePilotTransmitSlots_data01_data*)EDAlloc (sizeof (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_ReversePilotTransmitSlots_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_ReversePilotTransmitSlots_data01_data));
			(sequence->data[i]->ValueID) = 0;
			(sequence->data[i]->ReversePilotTransmitSlotsEnabled) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->ReversePilotTransmitSlotsDuration_Present) {
				}
				if (sequence->data[i]->ReversePilotTransmitSlotsPeriod_Present) {
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_ReversePilotTransmitSlots_data01_data */
void FREE_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_ReversePilotTransmitSlots_data01_data (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_ReversePilotTransmitSlots_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_Air_Default_Packet_Application_Attributes_Values'. Existing items are not changed. */
int SETITEMS_c_Air_Default_Packet_Application_Attributes_Values (c_Air_Default_Packet_Application_Attributes_Values* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		ED_LONG* tmp;
		tmp = (ED_LONG*)EDAlloc (sizeof (ED_LONG) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (ED_LONG) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			(sequence->data[i]) = 0;
		}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* SETITEMS commands for type 'c_Air_Multi_Flow_Packet_Application_Attributes_Values'. Existing items are not changed. */
int SETITEMS_c_Air_Multi_Flow_Packet_Application_Attributes_Values (c_Air_Multi_Flow_Packet_Application_Attributes_Values* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		ED_LONG* tmp;
		tmp = (ED_LONG*)EDAlloc (sizeof (ED_LONG) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (ED_LONG) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			(sequence->data[i]) = 0;
		}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Set-present function for c_Air_Multi_Flow_Packet_Application_Attributes_complex LEVEL = 0 */
void GLOB_SETPRESENT_c_Air_Multi_Flow_Packet_Application_Attributes_complex (c_Air_Multi_Flow_Packet_Application_Attributes_complex* sp, TPRESENT_c_Air_Multi_Flow_Packet_Application_Attributes_complex toBeSetPresent) 
{
	FREE_c_Air_Multi_Flow_Packet_Application_Attributes_complex (sp);
	sp->Present = toBeSetPresent;
	
	switch (toBeSetPresent) {
		case U_c_Air_Multi_Flow_Packet_Application_Attributes_complex_SupportedHigherLayerProtocols: {
			sp->u.SupportedHigherLayerProtocols = (c_Air_Multi_Flow_Packet_Application_Attributes_SupportedHigherLayerProtocols*)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_SupportedHigherLayerProtocols));
			INIT_c_Air_Multi_Flow_Packet_Application_Attributes_SupportedHigherLayerProtocols (sp->u.SupportedHigherLayerProtocols);

			break;
		}
		case U_c_Air_Multi_Flow_Packet_Application_Attributes_complex_ATSupportedQoSProfiles: {
			sp->u.ATSupportedQoSProfiles = (c_Air_Multi_Flow_Packet_Application_Attributes_ATSupportedQoSProfiles*)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_ATSupportedQoSProfiles));
			INIT_c_Air_Multi_Flow_Packet_Application_Attributes_ATSupportedQoSProfiles (sp->u.ATSupportedQoSProfiles);

			break;
		}
		case U_c_Air_Multi_Flow_Packet_Application_Attributes_complex_ANSupportedQoSProfiles: {
			sp->u.ANSupportedQoSProfiles = (c_Air_Multi_Flow_Packet_Application_Attributes_ANSupportedQoSProfiles*)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_ANSupportedQoSProfiles));
			INIT_c_Air_Multi_Flow_Packet_Application_Attributes_ANSupportedQoSProfiles (sp->u.ANSupportedQoSProfiles);

			break;
		}
		case U_c_Air_Multi_Flow_Packet_Application_Attributes_complex_MaxRLPFlows: {
			sp->u.MaxRLPFlows = (c_Air_Multi_Flow_Packet_Application_Attributes_MaxRLPFlows*)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_MaxRLPFlows));
			INIT_c_Air_Multi_Flow_Packet_Application_Attributes_MaxRLPFlows (sp->u.MaxRLPFlows);

			break;
		}
		case U_c_Air_Multi_Flow_Packet_Application_Attributes_complex_MaxReservations: {
			sp->u.MaxReservations = (c_Air_Multi_Flow_Packet_Application_Attributes_MaxReservations*)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_MaxReservations));
			INIT_c_Air_Multi_Flow_Packet_Application_Attributes_MaxReservations (sp->u.MaxReservations);

			break;
		}
		case U_c_Air_Multi_Flow_Packet_Application_Attributes_complex_FlowNNIdentificationFwd: {
			sp->u.FlowNNIdentificationFwd = (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationFwd*)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationFwd));
			INIT_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationFwd (sp->u.FlowNNIdentificationFwd);

			break;
		}
		case U_c_Air_Multi_Flow_Packet_Application_Attributes_complex_FlowNNIdentificationRev: {
			sp->u.FlowNNIdentificationRev = (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationRev*)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationRev));
			INIT_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNIdentificationRev (sp->u.FlowNNIdentificationRev);

			break;
		}
		case U_c_Air_Multi_Flow_Packet_Application_Attributes_complex_FlowNNTimersFwd: {
			sp->u.FlowNNTimersFwd = (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersFwd*)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersFwd));
			INIT_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersFwd (sp->u.FlowNNTimersFwd);

			break;
		}
		case U_c_Air_Multi_Flow_Packet_Application_Attributes_complex_FlowNNTimersRev: {
			sp->u.FlowNNTimersRev = (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersRev*)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersRev));
			INIT_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNTimersRev (sp->u.FlowNNTimersRev);

			break;
		}
		case U_c_Air_Multi_Flow_Packet_Application_Attributes_complex_FlowNNReservationFwd: {
			sp->u.FlowNNReservationFwd = (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationFwd*)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationFwd));
			INIT_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationFwd (sp->u.FlowNNReservationFwd);

			break;
		}
		case U_c_Air_Multi_Flow_Packet_Application_Attributes_complex_FlowNNReservationRev: {
			sp->u.FlowNNReservationRev = (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationRev*)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationRev));
			INIT_c_Air_Multi_Flow_Packet_Application_Attributes_FlowNNReservationRev (sp->u.FlowNNReservationRev);

			break;
		}
		case U_c_Air_Multi_Flow_Packet_Application_Attributes_complex_ReservationKKQoSRequestFwd: {
			sp->u.ReservationKKQoSRequestFwd = (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestFwd*)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestFwd));
			INIT_c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestFwd (sp->u.ReservationKKQoSRequestFwd);

			break;
		}
		case U_c_Air_Multi_Flow_Packet_Application_Attributes_complex_ReservationKKQoSRequestRev: {
			sp->u.ReservationKKQoSRequestRev = (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestRev*)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestRev));
			INIT_c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSRequestRev (sp->u.ReservationKKQoSRequestRev);

			break;
		}
		case U_c_Air_Multi_Flow_Packet_Application_Attributes_complex_ReservationKKQoSResponseFwd: {
			sp->u.ReservationKKQoSResponseFwd = (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseFwd*)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseFwd));
			INIT_c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseFwd (sp->u.ReservationKKQoSResponseFwd);

			break;
		}
		case U_c_Air_Multi_Flow_Packet_Application_Attributes_complex_ReservationKKQoSResponseRev: {
			sp->u.ReservationKKQoSResponseRev = (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseRev*)EDAlloc (sizeof (c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseRev));
			INIT_c_Air_Multi_Flow_Packet_Application_Attributes_ReservationKKQoSResponseRev (sp->u.ReservationKKQoSResponseRev);

			break;
		}
		default:;	}
}

/* Set-present function for c_Air_Default_Stream_Protocol_Attributes_complex LEVEL = -1 */
void GLOB_SETPRESENT_c_Air_Default_Stream_Protocol_Attributes_complex (c_Air_Default_Stream_Protocol_Attributes_complex* sp, TPRESENT_c_Air_Default_Stream_Protocol_Attributes_complex toBeSetPresent) 
{
	FREE_c_Air_Default_Stream_Protocol_Attributes_complex (sp);
	sp->Present = toBeSetPresent;
	
	switch (toBeSetPresent) {
		case U_c_Air_Default_Stream_Protocol_Attributes_complex_StreamConfiguration: {
			sp->u.StreamConfiguration = (c_Air_Default_Stream_Protocol_Attributes_StreamConfiguration*)EDAlloc (sizeof (c_Air_Default_Stream_Protocol_Attributes_StreamConfiguration));
			INIT_c_Air_Default_Stream_Protocol_Attributes_StreamConfiguration (sp->u.StreamConfiguration);

			break;
		}
		default:;	}
}

/* SETITEMS commands for type 'c_Air_Generic_Virtual_Stream_Protocol_Attributes_Values'. Existing items are not changed. */
int SETITEMS_c_Air_Generic_Virtual_Stream_Protocol_Attributes_Values (c_Air_Generic_Virtual_Stream_Protocol_Attributes_Values* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		ED_LONG* tmp;
		tmp = (ED_LONG*)EDAlloc (sizeof (ED_LONG) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (ED_LONG) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			(sequence->data[i]) = 0;
		}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* SETITEMS commands for type 'c_Air_Default_Session_Management_Protocol_Attributes_Values'. Existing items are not changed. */
int SETITEMS_c_Air_Default_Session_Management_Protocol_Attributes_Values (c_Air_Default_Session_Management_Protocol_Attributes_Values* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		ED_LONG* tmp;
		tmp = (ED_LONG*)EDAlloc (sizeof (ED_LONG) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (ED_LONG) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			(sequence->data[i]) = 0;
		}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* SETITEMS commands for type 'c_Air_Default_Address_Management_Protocol_Attributes_Values'. Existing items are not changed. */
int SETITEMS_c_Air_Default_Address_Management_Protocol_Attributes_Values (c_Air_Default_Address_Management_Protocol_Attributes_Values* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		ED_LONG* tmp;
		tmp = (ED_LONG*)EDAlloc (sizeof (ED_LONG) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (ED_LONG) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			(sequence->data[i]) = 0;
		}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* SETITEMS commands for type 'c_Air_Default_Session_Configuration_Protocol_Attributes_Values'. Existing items are not changed. */
int SETITEMS_c_Air_Default_Session_Configuration_Protocol_Attributes_Values (c_Air_Default_Session_Configuration_Protocol_Attributes_Values* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		ED_LONG* tmp;
		tmp = (ED_LONG*)EDAlloc (sizeof (ED_LONG) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (ED_LONG) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			(sequence->data[i]) = 0;
		}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Set-present function for c_Air_Default_Session_Configuration_Protocol_Attributes_complex LEVEL = 0 */
void GLOB_SETPRESENT_c_Air_Default_Session_Configuration_Protocol_Attributes_complex (c_Air_Default_Session_Configuration_Protocol_Attributes_complex* sp, TPRESENT_c_Air_Default_Session_Configuration_Protocol_Attributes_complex toBeSetPresent) 
{
	FREE_c_Air_Default_Session_Configuration_Protocol_Attributes_complex (sp);
	sp->Present = toBeSetPresent;
	
	switch (toBeSetPresent) {
		case U_c_Air_Default_Session_Configuration_Protocol_Attributes_complex_PriorSession: {
			sp->u.PriorSession = (c_Air_Default_Session_Configuration_Protocol_Attributes_PriorSession*)EDAlloc (sizeof (c_Air_Default_Session_Configuration_Protocol_Attributes_PriorSession));
			INIT_c_Air_Default_Session_Configuration_Protocol_Attributes_PriorSession (sp->u.PriorSession);

			break;
		}
		case U_c_Air_Default_Session_Configuration_Protocol_Attributes_complex_ATSupportedApplicationSubtypes: {
			sp->u.ATSupportedApplicationSubtypes = (c_Air_Default_Session_Configuration_Protocol_Attributes_ATSupportedApplicationSubtypes*)EDAlloc (sizeof (c_Air_Default_Session_Configuration_Protocol_Attributes_ATSupportedApplicationSubtypes));
			INIT_c_Air_Default_Session_Configuration_Protocol_Attributes_ATSupportedApplicationSubtypes (sp->u.ATSupportedApplicationSubtypes);

			break;
		}
		default:;	}
}

/* SETITEMS commands for type 'c_Air_Generic_Multimode_Capability_Discovery_Protocol_Attributes_Values'. Existing items are not changed. */
int SETITEMS_c_Air_Generic_Multimode_Capability_Discovery_Protocol_Attributes_Values (c_Air_Generic_Multimode_Capability_Discovery_Protocol_Attributes_Values* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		ED_LONG* tmp;
		tmp = (ED_LONG*)EDAlloc (sizeof (ED_LONG) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (ED_LONG) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			(sequence->data[i]) = 0;
		}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* SETITEMS commands for type 'c_Air_Default_Air_Link_Management_Protocol_Attributes_Values'. Existing items are not changed. */
int SETITEMS_c_Air_Default_Air_Link_Management_Protocol_Attributes_Values (c_Air_Default_Air_Link_Management_Protocol_Attributes_Values* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		ED_LONG* tmp;
		tmp = (ED_LONG*)EDAlloc (sizeof (ED_LONG) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (ED_LONG) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			(sequence->data[i]) = 0;
		}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Set-present function for c_Air_Default_Idle_State_Protocol_Attributes_complex LEVEL = -1 */
void GLOB_SETPRESENT_c_Air_Default_Idle_State_Protocol_Attributes_complex (c_Air_Default_Idle_State_Protocol_Attributes_complex* sp, TPRESENT_c_Air_Default_Idle_State_Protocol_Attributes_complex toBeSetPresent) 
{
	FREE_c_Air_Default_Idle_State_Protocol_Attributes_complex (sp);
	sp->Present = toBeSetPresent;
	
	switch (toBeSetPresent) {
		case U_c_Air_Default_Idle_State_Protocol_Attributes_complex_PreferredControlChannelCycle: {
			sp->u.PreferredControlChannelCycle = (c_Air_Default_Idle_State_Protocol_Attributes_PreferredControlChannelCycle*)EDAlloc (sizeof (c_Air_Default_Idle_State_Protocol_Attributes_PreferredControlChannelCycle));
			INIT_c_Air_Default_Idle_State_Protocol_Attributes_PreferredControlChannelCycle (sp->u.PreferredControlChannelCycle);

			break;
		}
		default:;	}
}

/* SETITEMS commands for type 'c_Air_Enhanced_Idle_State_Protocol_Attributes_Values'. Existing items are not changed. */
int SETITEMS_c_Air_Enhanced_Idle_State_Protocol_Attributes_Values (c_Air_Enhanced_Idle_State_Protocol_Attributes_Values* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		ED_LONG* tmp;
		tmp = (ED_LONG*)EDAlloc (sizeof (ED_LONG) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (ED_LONG) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			(sequence->data[i]) = 0;
		}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Set-present function for c_Air_Enhanced_Idle_State_Protocol_Attributes_complex LEVEL = 0 */
void GLOB_SETPRESENT_c_Air_Enhanced_Idle_State_Protocol_Attributes_complex (c_Air_Enhanced_Idle_State_Protocol_Attributes_complex* sp, TPRESENT_c_Air_Enhanced_Idle_State_Protocol_Attributes_complex toBeSetPresent) 
{
	FREE_c_Air_Enhanced_Idle_State_Protocol_Attributes_complex (sp);
	sp->Present = toBeSetPresent;
	
	switch (toBeSetPresent) {
		case U_c_Air_Enhanced_Idle_State_Protocol_Attributes_complex_PreferredControlChannelCycle: {
			sp->u.PreferredControlChannelCycle = (c_Air_Enhanced_Idle_State_Protocol_Attributes_PreferredControlChannelCycle*)EDAlloc (sizeof (c_Air_Enhanced_Idle_State_Protocol_Attributes_PreferredControlChannelCycle));
			INIT_c_Air_Enhanced_Idle_State_Protocol_Attributes_PreferredControlChannelCycle (sp->u.PreferredControlChannelCycle);

			break;
		}
		case U_c_Air_Enhanced_Idle_State_Protocol_Attributes_complex_SlottedMode: {
			sp->u.SlottedMode = (c_Air_Enhanced_Idle_State_Protocol_Attributes_SlottedMode*)EDAlloc (sizeof (c_Air_Enhanced_Idle_State_Protocol_Attributes_SlottedMode));
			INIT_c_Air_Enhanced_Idle_State_Protocol_Attributes_SlottedMode (sp->u.SlottedMode);

			break;
		}
		case U_c_Air_Enhanced_Idle_State_Protocol_Attributes_complex_PagingMask: {
			sp->u.PagingMask = (c_Air_Enhanced_Idle_State_Protocol_Attributes_PagingMask*)EDAlloc (sizeof (c_Air_Enhanced_Idle_State_Protocol_Attributes_PagingMask));
			INIT_c_Air_Enhanced_Idle_State_Protocol_Attributes_PagingMask (sp->u.PagingMask);

			break;
		}
		default:;	}
}

/* SETITEMS commands for type 'c_Air_Quick_Idle_State_Protocol_Attributes_Values'. Existing items are not changed. */
int SETITEMS_c_Air_Quick_Idle_State_Protocol_Attributes_Values (c_Air_Quick_Idle_State_Protocol_Attributes_Values* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		ED_LONG* tmp;
		tmp = (ED_LONG*)EDAlloc (sizeof (ED_LONG) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (ED_LONG) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			(sequence->data[i]) = 0;
		}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Set-present function for c_Air_Quick_Idle_State_Protocol_Attributes_complex LEVEL = 0 */
void GLOB_SETPRESENT_c_Air_Quick_Idle_State_Protocol_Attributes_complex (c_Air_Quick_Idle_State_Protocol_Attributes_complex* sp, TPRESENT_c_Air_Quick_Idle_State_Protocol_Attributes_complex toBeSetPresent) 
{
	FREE_c_Air_Quick_Idle_State_Protocol_Attributes_complex (sp);
	sp->Present = toBeSetPresent;
	
	switch (toBeSetPresent) {
		case U_c_Air_Quick_Idle_State_Protocol_Attributes_complex_PreferredControlChannelCycle: {
			sp->u.PreferredControlChannelCycle = (c_Air_Quick_Idle_State_Protocol_Attributes_PreferredControlChannelCycle*)EDAlloc (sizeof (c_Air_Quick_Idle_State_Protocol_Attributes_PreferredControlChannelCycle));
			INIT_c_Air_Quick_Idle_State_Protocol_Attributes_PreferredControlChannelCycle (sp->u.PreferredControlChannelCycle);

			break;
		}
		case U_c_Air_Quick_Idle_State_Protocol_Attributes_complex_SlottedMode: {
			sp->u.SlottedMode = (c_Air_Quick_Idle_State_Protocol_Attributes_SlottedMode*)EDAlloc (sizeof (c_Air_Quick_Idle_State_Protocol_Attributes_SlottedMode));
			INIT_c_Air_Quick_Idle_State_Protocol_Attributes_SlottedMode (sp->u.SlottedMode);

			break;
		}
		case U_c_Air_Quick_Idle_State_Protocol_Attributes_complex_PagingMask: {
			sp->u.PagingMask = (c_Air_Quick_Idle_State_Protocol_Attributes_PagingMask*)EDAlloc (sizeof (c_Air_Quick_Idle_State_Protocol_Attributes_PagingMask));
			INIT_c_Air_Quick_Idle_State_Protocol_Attributes_PagingMask (sp->u.PagingMask);

			break;
		}
		case U_c_Air_Quick_Idle_State_Protocol_Attributes_complex_QuickPaging: {
			sp->u.QuickPaging = (c_Air_Quick_Idle_State_Protocol_Attributes_QuickPaging*)EDAlloc (sizeof (c_Air_Quick_Idle_State_Protocol_Attributes_QuickPaging));
			INIT_c_Air_Quick_Idle_State_Protocol_Attributes_QuickPaging (sp->u.QuickPaging);

			break;
		}
		default:;	}
}

/* SETITEMS commands for type 'c_Air_Default_Route_Update_Protocol_Attributes_Values'. Existing items are not changed. */
int SETITEMS_c_Air_Default_Route_Update_Protocol_Attributes_Values (c_Air_Default_Route_Update_Protocol_Attributes_Values* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		ED_LONG* tmp;
		tmp = (ED_LONG*)EDAlloc (sizeof (ED_LONG) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (ED_LONG) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			(sequence->data[i]) = 0;
		}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Set-present function for c_Air_Default_Route_Update_Protocol_Attributes_complex LEVEL = 0 */
void GLOB_SETPRESENT_c_Air_Default_Route_Update_Protocol_Attributes_complex (c_Air_Default_Route_Update_Protocol_Attributes_complex* sp, TPRESENT_c_Air_Default_Route_Update_Protocol_Attributes_complex toBeSetPresent) 
{
	FREE_c_Air_Default_Route_Update_Protocol_Attributes_complex (sp);
	sp->Present = toBeSetPresent;
	
	switch (toBeSetPresent) {
		case U_c_Air_Default_Route_Update_Protocol_Attributes_complex_SearchParameters: {
			sp->u.SearchParameters = (c_Air_Default_Route_Update_Protocol_Attributes_SearchParameters*)EDAlloc (sizeof (c_Air_Default_Route_Update_Protocol_Attributes_SearchParameters));
			INIT_c_Air_Default_Route_Update_Protocol_Attributes_SearchParameters (sp->u.SearchParameters);

			break;
		}
		case U_c_Air_Default_Route_Update_Protocol_Attributes_complex_SetManagementSameChannelParameters: {
			sp->u.SetManagementSameChannelParameters = (c_Air_Default_Route_Update_Protocol_Attributes_SetManagementSameChannelParameters*)EDAlloc (sizeof (c_Air_Default_Route_Update_Protocol_Attributes_SetManagementSameChannelParameters));
			INIT_c_Air_Default_Route_Update_Protocol_Attributes_SetManagementSameChannelParameters (sp->u.SetManagementSameChannelParameters);

			break;
		}
		case U_c_Air_Default_Route_Update_Protocol_Attributes_complex_SetManagementDifferentChannelParameters: {
			sp->u.SetManagementDifferentChannelParameters = (c_Air_Default_Route_Update_Protocol_Attributes_SetManagementDifferentChannelParameters*)EDAlloc (sizeof (c_Air_Default_Route_Update_Protocol_Attributes_SetManagementDifferentChannelParameters));
			INIT_c_Air_Default_Route_Update_Protocol_Attributes_SetManagementDifferentChannelParameters (sp->u.SetManagementDifferentChannelParameters);

			break;
		}
		case U_c_Air_Default_Route_Update_Protocol_Attributes_complex_SupportedCDMAChannels: {
			sp->u.SupportedCDMAChannels = (c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels*)EDAlloc (sizeof (c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels));
			INIT_c_Air_Default_Route_Update_Protocol_Attributes_SupportedCDMAChannels (sp->u.SupportedCDMAChannels);

			break;
		}
		default:;	}
}

/* SETITEMS commands for type 'c_Air_Multicarrier_Route_Update_Protocol_Attributes_Values'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Route_Update_Protocol_Attributes_Values (c_Air_Multicarrier_Route_Update_Protocol_Attributes_Values* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		ED_LONG* tmp;
		tmp = (ED_LONG*)EDAlloc (sizeof (ED_LONG) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (ED_LONG) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			(sequence->data[i]) = 0;
		}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Set-present function for c_Air_Multicarrier_Route_Update_Protocol_Attributes_complex LEVEL = 0 */
void GLOB_SETPRESENT_c_Air_Multicarrier_Route_Update_Protocol_Attributes_complex (c_Air_Multicarrier_Route_Update_Protocol_Attributes_complex* sp, TPRESENT_c_Air_Multicarrier_Route_Update_Protocol_Attributes_complex toBeSetPresent) 
{
	FREE_c_Air_Multicarrier_Route_Update_Protocol_Attributes_complex (sp);
	sp->Present = toBeSetPresent;
	
	switch (toBeSetPresent) {
		case U_c_Air_Multicarrier_Route_Update_Protocol_Attributes_complex_SearchParameters: {
			sp->u.SearchParameters = (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SearchParameters*)EDAlloc (sizeof (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SearchParameters));
			INIT_c_Air_Multicarrier_Route_Update_Protocol_Attributes_SearchParameters (sp->u.SearchParameters);

			break;
		}
		case U_c_Air_Multicarrier_Route_Update_Protocol_Attributes_complex_SetManagementParameters: {
			sp->u.SetManagementParameters = (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SetManagementParameters*)EDAlloc (sizeof (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SetManagementParameters));
			INIT_c_Air_Multicarrier_Route_Update_Protocol_Attributes_SetManagementParameters (sp->u.SetManagementParameters);

			break;
		}
		case U_c_Air_Multicarrier_Route_Update_Protocol_Attributes_complex_SupportedCDMAChannels: {
			sp->u.SupportedCDMAChannels = (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels*)EDAlloc (sizeof (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels));
			INIT_c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedCDMAChannels (sp->u.SupportedCDMAChannels);

			break;
		}
		case U_c_Air_Multicarrier_Route_Update_Protocol_Attributes_complex_SupportedDRXPatterns: {
			sp->u.SupportedDRXPatterns = (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedDRXPatterns*)EDAlloc (sizeof (c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedDRXPatterns));
			INIT_c_Air_Multicarrier_Route_Update_Protocol_Attributes_SupportedDRXPatterns (sp->u.SupportedDRXPatterns);

			break;
		}
		default:;	}
}

/* SETITEMS commands for type 'c_Air_Overhead_Messages_Protocol_Attributes_Values'. Existing items are not changed. */
int SETITEMS_c_Air_Overhead_Messages_Protocol_Attributes_Values (c_Air_Overhead_Messages_Protocol_Attributes_Values* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		ED_LONG* tmp;
		tmp = (ED_LONG*)EDAlloc (sizeof (ED_LONG) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (ED_LONG) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			(sequence->data[i]) = 0;
		}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* SETITEMS commands for type 'c_Air_DH_Key_Exchange_Protocol_Attributes_Values'. Existing items are not changed. */
int SETITEMS_c_Air_DH_Key_Exchange_Protocol_Attributes_Values (c_Air_DH_Key_Exchange_Protocol_Attributes_Values* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		ED_LONG* tmp;
		tmp = (ED_LONG*)EDAlloc (sizeof (ED_LONG) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (ED_LONG) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			(sequence->data[i]) = 0;
		}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* SETITEMS commands for type 'c_Air_SHA_1_Authentication_Protocol_Attributes_Values'. Existing items are not changed. */
int SETITEMS_c_Air_SHA_1_Authentication_Protocol_Attributes_Values (c_Air_SHA_1_Authentication_Protocol_Attributes_Values* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		ED_LONG* tmp;
		tmp = (ED_LONG*)EDAlloc (sizeof (ED_LONG) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (ED_LONG) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			(sequence->data[i]) = 0;
		}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* SETITEMS commands for type 'c_Air_Enhanced_Control_Channel_MAC_Protocol_Attributes_Values'. Existing items are not changed. */
int SETITEMS_c_Air_Enhanced_Control_Channel_MAC_Protocol_Attributes_Values (c_Air_Enhanced_Control_Channel_MAC_Protocol_Attributes_Values* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		ED_LONG* tmp;
		tmp = (ED_LONG*)EDAlloc (sizeof (ED_LONG) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (ED_LONG) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			(sequence->data[i]) = 0;
		}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Set-present function for c_Air_Default_Access_Channel_MAC_Protocol_Attributes_complex LEVEL = -1 */
void GLOB_SETPRESENT_c_Air_Default_Access_Channel_MAC_Protocol_Attributes_complex (c_Air_Default_Access_Channel_MAC_Protocol_Attributes_complex* sp, TPRESENT_c_Air_Default_Access_Channel_MAC_Protocol_Attributes_complex toBeSetPresent) 
{
	FREE_c_Air_Default_Access_Channel_MAC_Protocol_Attributes_complex (sp);
	sp->Present = toBeSetPresent;
	
	switch (toBeSetPresent) {
		case U_c_Air_Default_Access_Channel_MAC_Protocol_Attributes_complex_InitialConfiguration: {
			sp->u.InitialConfiguration = (c_Air_Default_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration*)EDAlloc (sizeof (c_Air_Default_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration));
			INIT_c_Air_Default_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration (sp->u.InitialConfiguration);

			break;
		}
		case U_c_Air_Default_Access_Channel_MAC_Protocol_Attributes_complex_PowerParameters: {
			sp->u.PowerParameters = (c_Air_Default_Access_Channel_MAC_Protocol_Attributes_PowerParameters*)EDAlloc (sizeof (c_Air_Default_Access_Channel_MAC_Protocol_Attributes_PowerParameters));
			INIT_c_Air_Default_Access_Channel_MAC_Protocol_Attributes_PowerParameters (sp->u.PowerParameters);

			break;
		}
		default:;	}
}

/* SETITEMS commands for type 'c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_Values'. Existing items are not changed. */
int SETITEMS_c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_Values (c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_Values* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		ED_LONG* tmp;
		tmp = (ED_LONG*)EDAlloc (sizeof (ED_LONG) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (ED_LONG) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			(sequence->data[i]) = 0;
		}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Set-present function for c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_complex LEVEL = 0 */
void GLOB_SETPRESENT_c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_complex (c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_complex* sp, TPRESENT_c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_complex toBeSetPresent) 
{
	FREE_c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_complex (sp);
	sp->Present = toBeSetPresent;
	
	switch (toBeSetPresent) {
		case U_c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_complex_InitialConfiguration: {
			sp->u.InitialConfiguration = (c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration*)EDAlloc (sizeof (c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration));
			INIT_c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_InitialConfiguration (sp->u.InitialConfiguration);

			break;
		}
		default:;	}
}

/* SETITEMS commands for type 'c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_Values'. Existing items are not changed. */
int SETITEMS_c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_Values (c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_Values* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		ED_LONG* tmp;
		tmp = (ED_LONG*)EDAlloc (sizeof (ED_LONG) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (ED_LONG) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			(sequence->data[i]) = 0;
		}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Set-present function for c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex LEVEL = 0 */
void GLOB_SETPRESENT_c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex (c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex* sp, TPRESENT_c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex toBeSetPresent) 
{
	FREE_c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex (sp);
	sp->Present = toBeSetPresent;
	
	switch (toBeSetPresent) {
		case U_c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex_HandoffDelays: {
			sp->u.HandoffDelays = (c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays*)EDAlloc (sizeof (c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays));
			INIT_c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays (sp->u.HandoffDelays);

			break;
		}
		case U_c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex_DRCLock: {
			sp->u.DRCLock = (c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCLock*)EDAlloc (sizeof (c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCLock));
			INIT_c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCLock (sp->u.DRCLock);

			break;
		}
		default:;	}
}

/* SETITEMS commands for type 'c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_Values'. Existing items are not changed. */
int SETITEMS_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_Values (c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_Values* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		ED_LONG* tmp;
		tmp = (ED_LONG*)EDAlloc (sizeof (ED_LONG) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (ED_LONG) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			(sequence->data[i]) = 0;
		}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Set-present function for c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex LEVEL = 0 */
void GLOB_SETPRESENT_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex (c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex* sp, TPRESENT_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex toBeSetPresent) 
{
	FREE_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex (sp);
	sp->Present = toBeSetPresent;
	
	switch (toBeSetPresent) {
		case U_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex_HandoffDelays: {
			sp->u.HandoffDelays = (c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays*)EDAlloc (sizeof (c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays));
			INIT_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays (sp->u.HandoffDelays);

			break;
		}
		case U_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex_DRCTranslationOffset: {
			sp->u.DRCTranslationOffset = (c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCTranslationOffset*)EDAlloc (sizeof (c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCTranslationOffset));
			INIT_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_DRCTranslationOffset (sp->u.DRCTranslationOffset);

			break;
		}
		default:;	}
}

/* SETITEMS commands for type 'c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_Values'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_Values (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_Values* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		ED_LONG* tmp;
		tmp = (ED_LONG*)EDAlloc (sizeof (ED_LONG) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (ED_LONG) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			(sequence->data[i]) = 0;
		}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Set-present function for c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex LEVEL = 0 */
void GLOB_SETPRESENT_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex* sp, TPRESENT_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex toBeSetPresent) 
{
	FREE_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex (sp);
	sp->Present = toBeSetPresent;
	
	switch (toBeSetPresent) {
		case U_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex_HandoffDelays: {
			sp->u.HandoffDelays = (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays*)EDAlloc (sizeof (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays));
			INIT_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_HandoffDelays (sp->u.HandoffDelays);

			break;
		}
		case U_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex_ATSupportedPacketFormats: {
			sp->u.ATSupportedPacketFormats = (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ATSupportedPacketFormats*)EDAlloc (sizeof (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ATSupportedPacketFormats));
			INIT_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ATSupportedPacketFormats (sp->u.ATSupportedPacketFormats);

			break;
		}
		case U_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex_TentativeDRCtoTxDRCMap: {
			sp->u.TentativeDRCtoTxDRCMap = (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_TentativeDRCtoTxDRCMap*)EDAlloc (sizeof (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_TentativeDRCtoTxDRCMap));
			INIT_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_TentativeDRCtoTxDRCMap (sp->u.TentativeDRCtoTxDRCMap);

			break;
		}
		case U_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_complex_ExtendedSpans: {
			sp->u.ExtendedSpans = (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ExtendedSpans*)EDAlloc (sizeof (c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ExtendedSpans));
			INIT_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_ExtendedSpans (sp->u.ExtendedSpans);

			break;
		}
		default:;	}
}

/* Set-present function for c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex LEVEL = -1 */
void GLOB_SETPRESENT_c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex (c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex* sp, TPRESENT_c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex toBeSetPresent) 
{
	FREE_c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex (sp);
	sp->Present = toBeSetPresent;
	
	switch (toBeSetPresent) {
		case U_c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters: {
			sp->u.PowerParameters = (c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters*)EDAlloc (sizeof (c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters));
			INIT_c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters (sp->u.PowerParameters);

			break;
		}
		case U_c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_RateParameters: {
			sp->u.RateParameters = (c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters*)EDAlloc (sizeof (c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters));
			INIT_c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters (sp->u.RateParameters);

			break;
		}
		default:;	}
}

/* Set-present function for c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex LEVEL = -1 */
void GLOB_SETPRESENT_c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex (c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex* sp, TPRESENT_c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex toBeSetPresent) 
{
	FREE_c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex (sp);
	sp->Present = toBeSetPresent;
	
	switch (toBeSetPresent) {
		case U_c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters: {
			sp->u.PowerParameters = (c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters*)EDAlloc (sizeof (c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters));
			INIT_c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters (sp->u.PowerParameters);

			break;
		}
		case U_c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_RateParameters: {
			sp->u.RateParameters = (c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters*)EDAlloc (sizeof (c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters));
			INIT_c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RateParameters (sp->u.RateParameters);

			break;
		}
		default:;	}
}

/* SETITEMS commands for type 'c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Values'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Values (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Values* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		ED_LONG* tmp;
		tmp = (ED_LONG*)EDAlloc (sizeof (ED_LONG) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (ED_LONG) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			(sequence->data[i]) = 0;
		}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Set-present function for c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex LEVEL = 0 */
void GLOB_SETPRESENT_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex* sp, TPRESENT_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex toBeSetPresent) 
{
	FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex (sp);
	sp->Present = toBeSetPresent;
	
	switch (toBeSetPresent) {
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_AuxiliaryPilotChannelParameters: {
			sp->u.AuxiliaryPilotChannelParameters = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters));
			INIT_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters (sp->u.AuxiliaryPilotChannelParameters);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_CommonPowerParameters: {
			sp->u.CommonPowerParameters = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters));
			INIT_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters (sp->u.CommonPowerParameters);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_MaxNumSubPackets: {
			sp->u.MaxNumSubPackets = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPackets*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPackets));
			INIT_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPackets (sp->u.MaxNumSubPackets);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PermittedPayload: {
			sp->u.PermittedPayload = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload));
			INIT_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload (sp->u.PermittedPayload);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PilotStrength: {
			sp->u.PilotStrength = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrength*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrength));
			INIT_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrength (sp->u.PilotStrength);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters128: {
			sp->u.PowerParameters128 = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128));
			INIT_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128 (sp->u.PowerParameters128);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters256: {
			sp->u.PowerParameters256 = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256));
			INIT_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256 (sp->u.PowerParameters256);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters512: {
			sp->u.PowerParameters512 = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512));
			INIT_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512 (sp->u.PowerParameters512);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters768: {
			sp->u.PowerParameters768 = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768));
			INIT_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768 (sp->u.PowerParameters768);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters1024: {
			sp->u.PowerParameters1024 = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024));
			INIT_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024 (sp->u.PowerParameters1024);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters1536: {
			sp->u.PowerParameters1536 = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536));
			INIT_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536 (sp->u.PowerParameters1536);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters2048: {
			sp->u.PowerParameters2048 = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048));
			INIT_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048 (sp->u.PowerParameters2048);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters3072: {
			sp->u.PowerParameters3072 = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072));
			INIT_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072 (sp->u.PowerParameters3072);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters4096: {
			sp->u.PowerParameters4096 = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096));
			INIT_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096 (sp->u.PowerParameters4096);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters6144: {
			sp->u.PowerParameters6144 = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144));
			INIT_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144 (sp->u.PowerParameters6144);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters8192: {
			sp->u.PowerParameters8192 = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192));
			INIT_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192 (sp->u.PowerParameters8192);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters12288: {
			sp->u.PowerParameters12288 = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288));
			INIT_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288 (sp->u.PowerParameters12288);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_RequestParameters: {
			sp->u.RequestParameters = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters));
			INIT_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters (sp->u.RequestParameters);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_RRIChannelPowerParameters: {
			sp->u.RRIChannelPowerParameters = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters));
			INIT_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters (sp->u.RRIChannelPowerParameters);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_TxT2Pmax: {
			sp->u.TxT2Pmax = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2Pmax*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2Pmax));
			INIT_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2Pmax (sp->u.TxT2Pmax);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_MaxMACFlows: {
			sp->u.MaxMACFlows = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows));
			INIT_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows (sp->u.MaxMACFlows);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_AssociatedFlowsNN: {
			sp->u.AssociatedFlowsNN = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN));
			INIT_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN (sp->u.AssociatedFlowsNN);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_BucketFactorNN: {
			sp->u.BucketFactorNN = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN));
			INIT_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN (sp->u.BucketFactorNN);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_T2PInflowRangeNN: {
			sp->u.T2PInflowRangeNN = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeNN*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeNN));
			INIT_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeNN (sp->u.T2PInflowRangeNN);

			break;
		}
		case U_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_T2PTransitionFunctionNN: {
			sp->u.T2PTransitionFunctionNN = (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN*)EDAlloc (sizeof (c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN));
			INIT_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionNN (sp->u.T2PTransitionFunctionNN);

			break;
		}
		default:;	}
}

/* SETITEMS commands for type 'c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Values'. Existing items are not changed. */
int SETITEMS_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Values (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Values* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		ED_LONG* tmp;
		tmp = (ED_LONG*)EDAlloc (sizeof (ED_LONG) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (ED_LONG) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			(sequence->data[i]) = 0;
		}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Set-present function for c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex LEVEL = 0 */
void GLOB_SETPRESENT_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex* sp, TPRESENT_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex toBeSetPresent) 
{
	FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex (sp);
	sp->Present = toBeSetPresent;
	
	switch (toBeSetPresent) {
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_AuxiliaryPilotChannelParameters: {
			sp->u.AuxiliaryPilotChannelParameters = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters));
			INIT_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AuxiliaryPilotChannelParameters (sp->u.AuxiliaryPilotChannelParameters);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_CommonPowerParameters: {
			sp->u.CommonPowerParameters = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters));
			INIT_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_CommonPowerParameters (sp->u.CommonPowerParameters);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PermittedPayload: {
			sp->u.PermittedPayload = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload));
			INIT_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PermittedPayload (sp->u.PermittedPayload);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters128: {
			sp->u.PowerParameters128 = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128));
			INIT_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters128 (sp->u.PowerParameters128);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters256: {
			sp->u.PowerParameters256 = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256));
			INIT_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters256 (sp->u.PowerParameters256);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters512: {
			sp->u.PowerParameters512 = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512));
			INIT_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters512 (sp->u.PowerParameters512);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters768: {
			sp->u.PowerParameters768 = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768));
			INIT_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters768 (sp->u.PowerParameters768);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters1024: {
			sp->u.PowerParameters1024 = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024));
			INIT_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1024 (sp->u.PowerParameters1024);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters1536: {
			sp->u.PowerParameters1536 = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536));
			INIT_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters1536 (sp->u.PowerParameters1536);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters2048: {
			sp->u.PowerParameters2048 = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048));
			INIT_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters2048 (sp->u.PowerParameters2048);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters3072: {
			sp->u.PowerParameters3072 = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072));
			INIT_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters3072 (sp->u.PowerParameters3072);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters4096: {
			sp->u.PowerParameters4096 = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096));
			INIT_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters4096 (sp->u.PowerParameters4096);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters6144: {
			sp->u.PowerParameters6144 = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144));
			INIT_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters6144 (sp->u.PowerParameters6144);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters8192: {
			sp->u.PowerParameters8192 = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192));
			INIT_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters8192 (sp->u.PowerParameters8192);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PowerParameters12288: {
			sp->u.PowerParameters12288 = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288));
			INIT_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PowerParameters12288 (sp->u.PowerParameters12288);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_RequestParameters: {
			sp->u.RequestParameters = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters));
			INIT_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RequestParameters (sp->u.RequestParameters);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_RRIChannelPowerParameters: {
			sp->u.RRIChannelPowerParameters = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters));
			INIT_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_RRIChannelPowerParameters (sp->u.RRIChannelPowerParameters);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_MaxMACFlows: {
			sp->u.MaxMACFlows = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows));
			INIT_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxMACFlows (sp->u.MaxMACFlows);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_AssociatedFlowsNN: {
			sp->u.AssociatedFlowsNN = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN));
			INIT_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowsNN (sp->u.AssociatedFlowsNN);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_BucketFactorNN: {
			sp->u.BucketFactorNN = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN));
			INIT_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_BucketFactorNN (sp->u.BucketFactorNN);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_T2PInflowRangeConfigXX: {
			sp->u.T2PInflowRangeConfigXX = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeConfigXX*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeConfigXX));
			INIT_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PInflowRangeConfigXX (sp->u.T2PInflowRangeConfigXX);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_T2PTransitionFunctionConfigXX: {
			sp->u.T2PTransitionFunctionConfigXX = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX));
			INIT_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_T2PTransitionFunctionConfigXX (sp->u.T2PTransitionFunctionConfigXX);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_AssociatedFlowConfigurationsNC: {
			sp->u.AssociatedFlowConfigurationsNC = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowConfigurationsNC*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowConfigurationsNC));
			INIT_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedFlowConfigurationsNC (sp->u.AssociatedFlowConfigurationsNC);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_AssociatedATConfigurationsCC: {
			sp->u.AssociatedATConfigurationsCC = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedATConfigurationsCC*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedATConfigurationsCC));
			INIT_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_AssociatedATConfigurationsCC (sp->u.AssociatedATConfigurationsCC);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_DataTokenBucketNN: {
			sp->u.DataTokenBucketNN = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_DataTokenBucketNN*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_DataTokenBucketNN));
			INIT_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_DataTokenBucketNN (sp->u.DataTokenBucketNN);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_MaxNumSubPacketsCC: {
			sp->u.MaxNumSubPacketsCC = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPacketsCC*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPacketsCC));
			INIT_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_MaxNumSubPacketsCC (sp->u.MaxNumSubPacketsCC);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_PilotStrengthConfigXX: {
			sp->u.PilotStrengthConfigXX = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrengthConfigXX*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrengthConfigXX));
			INIT_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_PilotStrengthConfigXX (sp->u.PilotStrengthConfigXX);

			break;
		}
		case U_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_complex_TxT2PmaxConfigXX: {
			sp->u.TxT2PmaxConfigXX = (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2PmaxConfigXX*)EDAlloc (sizeof (c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2PmaxConfigXX));
			INIT_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_TxT2PmaxConfigXX (sp->u.TxT2PmaxConfigXX);

			break;
		}
		default:;	}
}

/* SETITEMS commands for type 'c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_Values'. Existing items are not changed. */
int SETITEMS_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_Values (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_Values* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		ED_LONG* tmp;
		tmp = (ED_LONG*)EDAlloc (sizeof (ED_LONG) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (ED_LONG) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			(sequence->data[i]) = 0;
		}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Set-present function for c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_complex LEVEL = 0 */
void GLOB_SETPRESENT_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_complex (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_complex* sp, TPRESENT_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_complex toBeSetPresent) 
{
	FREE_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_complex (sp);
	sp->Present = toBeSetPresent;
	
	switch (toBeSetPresent) {
		case U_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_complex_AdditionalCarriersInitTxPower: {
			sp->u.AdditionalCarriersInitTxPower = (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower*)EDAlloc (sizeof (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower));
			INIT_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_AdditionalCarriersInitTxPower (sp->u.AdditionalCarriersInitTxPower);

			break;
		}
		case U_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_complex_ReversePilotTransmitSlots: {
			sp->u.ReversePilotTransmitSlots = (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_ReversePilotTransmitSlots*)EDAlloc (sizeof (c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_ReversePilotTransmitSlots));
			INIT_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_ReversePilotTransmitSlots (sp->u.ReversePilotTransmitSlots);

			break;
		}
		default:;	}
}

/* SETITEMS commands for type 'c_SIGAPP_SLP_INCFG_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_SIGAPP_SLP_INCFG_ConfigurationRequest_contents_data01 (c_SIGAPP_SLP_INCFG_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_SIGAPP_SLP_INCFG_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_SIGAPP_SLP_INCFG_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_SIGAPP_SLP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_SIGAPP_SLP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_SIGAPP_SLP_INCFG_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_SIGAPP_SLP_INCFG_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_SIGAPP_SLP_INCFG_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeRecord.Length) = 0;
			(sequence->data[i]->AttributeRecord.AttributeID) = 0;
			sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
			sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
			
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->AttributeRecord.AttributeValue.value != NULL) {
					EDFree (sequence->data[i]->AttributeRecord.AttributeValue.value);
					sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
				}
				sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_SIGAPP_SLP_INCFG_ConfigurationRequest_contents_data01_data */
void FREE_c_SIGAPP_SLP_INCFG_ConfigurationRequest_contents_data01_data (c_SIGAPP_SLP_INCFG_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeRecord.AttributeValue.value != NULL) {
		EDFree (sp->AttributeRecord.AttributeValue.value);
		sp->AttributeRecord.AttributeValue.value = NULL;
	}
	sp->AttributeRecord.AttributeValue.usedBits = 0;

}

/* Free function for struct c_SIGAPP_SLP_INCFG_ConfigurationRequest_contents_data01_data_AttributeRecord */
void FREE_c_SIGAPP_SLP_INCFG_ConfigurationRequest_contents_data01_data_AttributeRecord (c_SIGAPP_SLP_INCFG_ConfigurationRequest_contents_data01_data_AttributeRecord* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeValue.value != NULL) {
		EDFree (sp->AttributeValue.value);
		sp->AttributeValue.value = NULL;
	}
	sp->AttributeValue.usedBits = 0;

}

/* SETITEMS commands for type 'c_SIGAPP_SLP_INCFG_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_SIGAPP_SLP_INCFG_ConfigurationResponse_contents_data01 (c_SIGAPP_SLP_INCFG_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_SIGAPP_SLP_INCFG_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_SIGAPP_SLP_INCFG_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_SIGAPP_SLP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_SIGAPP_SLP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_SIGAPP_SLP_INCFG_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_SIGAPP_SLP_INCFG_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_SIGAPP_SLP_INCFG_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeRecord.Length) = 0;
			(sequence->data[i]->AttributeRecord.AttributeID) = 0;
			sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
			sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
			
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->AttributeRecord.AttributeValue.value != NULL) {
					EDFree (sequence->data[i]->AttributeRecord.AttributeValue.value);
					sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
				}
				sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_SIGAPP_SLP_INCFG_ConfigurationResponse_contents_data01_data */
void FREE_c_SIGAPP_SLP_INCFG_ConfigurationResponse_contents_data01_data (c_SIGAPP_SLP_INCFG_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeRecord.AttributeValue.value != NULL) {
		EDFree (sp->AttributeRecord.AttributeValue.value);
		sp->AttributeRecord.AttributeValue.value = NULL;
	}
	sp->AttributeRecord.AttributeValue.usedBits = 0;

}

/* Free function for struct c_SIGAPP_SLP_INCFG_ConfigurationResponse_contents_data01_data_AttributeRecord */
void FREE_c_SIGAPP_SLP_INCFG_ConfigurationResponse_contents_data01_data_AttributeRecord (c_SIGAPP_SLP_INCFG_ConfigurationResponse_contents_data01_data_AttributeRecord* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeValue.value != NULL) {
		EDFree (sp->AttributeValue.value);
		sp->AttributeValue.value = NULL;
	}
	sp->AttributeValue.usedBits = 0;

}

/* SETITEMS commands for type 'c_PKTAPP_DPA_INCFG_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_PKTAPP_DPA_INCFG_ConfigurationRequest_contents_data01 (c_PKTAPP_DPA_INCFG_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_PKTAPP_DPA_INCFG_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_PKTAPP_DPA_INCFG_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_PKTAPP_DPA_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_PKTAPP_DPA_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_PKTAPP_DPA_INCFG_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_PKTAPP_DPA_INCFG_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_PKTAPP_DPA_INCFG_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Default_Packet_Application_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Default_Packet_Application_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_PKTAPP_DPA_INCFG_ConfigurationRequest_contents_data01_data */
void FREE_c_PKTAPP_DPA_INCFG_ConfigurationRequest_contents_data01_data (c_PKTAPP_DPA_INCFG_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Default_Packet_Application_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_PKTAPP_DPA_INCFG_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_PKTAPP_DPA_INCFG_ConfigurationResponse_contents_data01 (c_PKTAPP_DPA_INCFG_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_PKTAPP_DPA_INCFG_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_PKTAPP_DPA_INCFG_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_PKTAPP_DPA_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_PKTAPP_DPA_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_PKTAPP_DPA_INCFG_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_PKTAPP_DPA_INCFG_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_PKTAPP_DPA_INCFG_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Default_Packet_Application_Attributes_Response (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Default_Packet_Application_Attributes_Response (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_PKTAPP_DPA_INCFG_ConfigurationResponse_contents_data01_data */
void FREE_c_PKTAPP_DPA_INCFG_ConfigurationResponse_contents_data01_data (c_PKTAPP_DPA_INCFG_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Default_Packet_Application_Attributes_Response (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_PKTAPP_RLP_INUSE_Nak_contents_data01'. Existing items are not changed. */
int SETITEMS_c_PKTAPP_RLP_INUSE_Nak_contents_data01 (c_PKTAPP_RLP_INUSE_Nak_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_PKTAPP_RLP_INUSE_Nak_contents_data01_data** tmp;
		tmp = (c_PKTAPP_RLP_INUSE_Nak_contents_data01_data**)EDAlloc (sizeof (c_PKTAPP_RLP_INUSE_Nak_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_PKTAPP_RLP_INUSE_Nak_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_PKTAPP_RLP_INUSE_Nak_contents_data01_data*)EDAlloc (sizeof (c_PKTAPP_RLP_INUSE_Nak_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_PKTAPP_RLP_INUSE_Nak_contents_data01_data));
			(sequence->data[i]->Reserved) = 0;
			(sequence->data[i]->FirstErased) = 0;
			(sequence->data[i]->WindowLen) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_PKTAPP_RLP_INUSE_Nak_contents_data01_data */
void FREE_c_PKTAPP_RLP_INUSE_Nak_contents_data01_data (c_PKTAPP_RLP_INUSE_Nak_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_MFPAPP_MFPA_INCFG_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MFPAPP_MFPA_INCFG_ConfigurationRequest_contents_data01 (c_MFPAPP_MFPA_INCFG_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MFPAPP_MFPA_INCFG_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_MFPAPP_MFPA_INCFG_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_MFPAPP_MFPA_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MFPAPP_MFPA_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MFPAPP_MFPA_INCFG_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_MFPAPP_MFPA_INCFG_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MFPAPP_MFPA_INCFG_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Multi_Flow_Packet_Application_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Multi_Flow_Packet_Application_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MFPAPP_MFPA_INCFG_ConfigurationRequest_contents_data01_data */
void FREE_c_MFPAPP_MFPA_INCFG_ConfigurationRequest_contents_data01_data (c_MFPAPP_MFPA_INCFG_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Multi_Flow_Packet_Application_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_MFPAPP_MFPA_INCFG_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MFPAPP_MFPA_INCFG_ConfigurationResponse_contents_data01 (c_MFPAPP_MFPA_INCFG_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MFPAPP_MFPA_INCFG_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_MFPAPP_MFPA_INCFG_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_MFPAPP_MFPA_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MFPAPP_MFPA_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MFPAPP_MFPA_INCFG_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_MFPAPP_MFPA_INCFG_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MFPAPP_MFPA_INCFG_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Multi_Flow_Packet_Application_Attributes_Response (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Multi_Flow_Packet_Application_Attributes_Response (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MFPAPP_MFPA_INCFG_ConfigurationResponse_contents_data01_data */
void FREE_c_MFPAPP_MFPA_INCFG_ConfigurationResponse_contents_data01_data (c_MFPAPP_MFPA_INCFG_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Multi_Flow_Packet_Application_Attributes_Response (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_MFPAPP_RLP_INUSE_Nak_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MFPAPP_RLP_INUSE_Nak_contents_data01 (c_MFPAPP_RLP_INUSE_Nak_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MFPAPP_RLP_INUSE_Nak_contents_data01_data** tmp;
		tmp = (c_MFPAPP_RLP_INUSE_Nak_contents_data01_data**)EDAlloc (sizeof (c_MFPAPP_RLP_INUSE_Nak_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MFPAPP_RLP_INUSE_Nak_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MFPAPP_RLP_INUSE_Nak_contents_data01_data*)EDAlloc (sizeof (c_MFPAPP_RLP_INUSE_Nak_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MFPAPP_RLP_INUSE_Nak_contents_data01_data));
			sequence->data[i]->FirstErased.value = NULL;
			sequence->data[i]->FirstErased.usedBits = 0;
			
			(sequence->data[i]->WindowLen) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->FirstErased.value != NULL) {
					EDFree (sequence->data[i]->FirstErased.value);
					sequence->data[i]->FirstErased.value = NULL;
				}
				sequence->data[i]->FirstErased.usedBits = 0;
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MFPAPP_RLP_INUSE_Nak_contents_data01_data */
void FREE_c_MFPAPP_RLP_INUSE_Nak_contents_data01_data (c_MFPAPP_RLP_INUSE_Nak_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->FirstErased.value != NULL) {
		EDFree (sp->FirstErased.value);
		sp->FirstErased.value = NULL;
	}
	sp->FirstErased.usedBits = 0;

}

/* SETITEMS commands for type 'c_MFPAPP_RLP_INUSE_ReservationOnRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MFPAPP_RLP_INUSE_ReservationOnRequest_contents_data01 (c_MFPAPP_RLP_INUSE_ReservationOnRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MFPAPP_RLP_INUSE_ReservationOnRequest_contents_data01_data** tmp;
		tmp = (c_MFPAPP_RLP_INUSE_ReservationOnRequest_contents_data01_data**)EDAlloc (sizeof (c_MFPAPP_RLP_INUSE_ReservationOnRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MFPAPP_RLP_INUSE_ReservationOnRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MFPAPP_RLP_INUSE_ReservationOnRequest_contents_data01_data*)EDAlloc (sizeof (c_MFPAPP_RLP_INUSE_ReservationOnRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MFPAPP_RLP_INUSE_ReservationOnRequest_contents_data01_data));
			(sequence->data[i]->Link) = 0;
			(sequence->data[i]->ReservationLabel) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MFPAPP_RLP_INUSE_ReservationOnRequest_contents_data01_data */
void FREE_c_MFPAPP_RLP_INUSE_ReservationOnRequest_contents_data01_data (c_MFPAPP_RLP_INUSE_ReservationOnRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_MFPAPP_RLP_INUSE_ReservationOffRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MFPAPP_RLP_INUSE_ReservationOffRequest_contents_data01 (c_MFPAPP_RLP_INUSE_ReservationOffRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MFPAPP_RLP_INUSE_ReservationOffRequest_contents_data01_data** tmp;
		tmp = (c_MFPAPP_RLP_INUSE_ReservationOffRequest_contents_data01_data**)EDAlloc (sizeof (c_MFPAPP_RLP_INUSE_ReservationOffRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MFPAPP_RLP_INUSE_ReservationOffRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MFPAPP_RLP_INUSE_ReservationOffRequest_contents_data01_data*)EDAlloc (sizeof (c_MFPAPP_RLP_INUSE_ReservationOffRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MFPAPP_RLP_INUSE_ReservationOffRequest_contents_data01_data));
			(sequence->data[i]->Link) = 0;
			(sequence->data[i]->ReservationLabel) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MFPAPP_RLP_INUSE_ReservationOffRequest_contents_data01_data */
void FREE_c_MFPAPP_RLP_INUSE_ReservationOffRequest_contents_data01_data (c_MFPAPP_RLP_INUSE_ReservationOffRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_MFPAPP_RLP_INUSE_ReservationReject_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MFPAPP_RLP_INUSE_ReservationReject_contents_data01 (c_MFPAPP_RLP_INUSE_ReservationReject_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MFPAPP_RLP_INUSE_ReservationReject_contents_data01_data** tmp;
		tmp = (c_MFPAPP_RLP_INUSE_ReservationReject_contents_data01_data**)EDAlloc (sizeof (c_MFPAPP_RLP_INUSE_ReservationReject_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MFPAPP_RLP_INUSE_ReservationReject_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MFPAPP_RLP_INUSE_ReservationReject_contents_data01_data*)EDAlloc (sizeof (c_MFPAPP_RLP_INUSE_ReservationReject_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MFPAPP_RLP_INUSE_ReservationReject_contents_data01_data));
			(sequence->data[i]->AllowableLink) = 0;
			(sequence->data[i]->AllowableReservationLabel) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MFPAPP_RLP_INUSE_ReservationReject_contents_data01_data */
void FREE_c_MFPAPP_RLP_INUSE_ReservationReject_contents_data01_data (c_MFPAPP_RLP_INUSE_ReservationReject_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_MFPAPP_RLP_INUSE_RevReservationOn_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MFPAPP_RLP_INUSE_RevReservationOn_contents_data01 (c_MFPAPP_RLP_INUSE_RevReservationOn_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MFPAPP_RLP_INUSE_RevReservationOn_contents_data01_data** tmp;
		tmp = (c_MFPAPP_RLP_INUSE_RevReservationOn_contents_data01_data**)EDAlloc (sizeof (c_MFPAPP_RLP_INUSE_RevReservationOn_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MFPAPP_RLP_INUSE_RevReservationOn_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MFPAPP_RLP_INUSE_RevReservationOn_contents_data01_data*)EDAlloc (sizeof (c_MFPAPP_RLP_INUSE_RevReservationOn_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MFPAPP_RLP_INUSE_RevReservationOn_contents_data01_data));
			(sequence->data[i]->ReservationLabel) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MFPAPP_RLP_INUSE_RevReservationOn_contents_data01_data */
void FREE_c_MFPAPP_RLP_INUSE_RevReservationOn_contents_data01_data (c_MFPAPP_RLP_INUSE_RevReservationOn_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_MFPAPP_RLP_INUSE_RevReservationOff_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MFPAPP_RLP_INUSE_RevReservationOff_contents_data01 (c_MFPAPP_RLP_INUSE_RevReservationOff_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MFPAPP_RLP_INUSE_RevReservationOff_contents_data01_data** tmp;
		tmp = (c_MFPAPP_RLP_INUSE_RevReservationOff_contents_data01_data**)EDAlloc (sizeof (c_MFPAPP_RLP_INUSE_RevReservationOff_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MFPAPP_RLP_INUSE_RevReservationOff_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MFPAPP_RLP_INUSE_RevReservationOff_contents_data01_data*)EDAlloc (sizeof (c_MFPAPP_RLP_INUSE_RevReservationOff_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MFPAPP_RLP_INUSE_RevReservationOff_contents_data01_data));
			(sequence->data[i]->ReservationLabel) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MFPAPP_RLP_INUSE_RevReservationOff_contents_data01_data */
void FREE_c_MFPAPP_RLP_INUSE_RevReservationOff_contents_data01_data (c_MFPAPP_RLP_INUSE_RevReservationOff_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_MFPAPP_RLP_INUSE_FwdReservationOff_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MFPAPP_RLP_INUSE_FwdReservationOff_contents_data01 (c_MFPAPP_RLP_INUSE_FwdReservationOff_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MFPAPP_RLP_INUSE_FwdReservationOff_contents_data01_data** tmp;
		tmp = (c_MFPAPP_RLP_INUSE_FwdReservationOff_contents_data01_data**)EDAlloc (sizeof (c_MFPAPP_RLP_INUSE_FwdReservationOff_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MFPAPP_RLP_INUSE_FwdReservationOff_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MFPAPP_RLP_INUSE_FwdReservationOff_contents_data01_data*)EDAlloc (sizeof (c_MFPAPP_RLP_INUSE_FwdReservationOff_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MFPAPP_RLP_INUSE_FwdReservationOff_contents_data01_data));
			(sequence->data[i]->ReservationLabel) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MFPAPP_RLP_INUSE_FwdReservationOff_contents_data01_data */
void FREE_c_MFPAPP_RLP_INUSE_FwdReservationOff_contents_data01_data (c_MFPAPP_RLP_INUSE_FwdReservationOff_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_MFPAPP_RLP_INUSE_FwdReservationOn_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MFPAPP_RLP_INUSE_FwdReservationOn_contents_data01 (c_MFPAPP_RLP_INUSE_FwdReservationOn_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MFPAPP_RLP_INUSE_FwdReservationOn_contents_data01_data** tmp;
		tmp = (c_MFPAPP_RLP_INUSE_FwdReservationOn_contents_data01_data**)EDAlloc (sizeof (c_MFPAPP_RLP_INUSE_FwdReservationOn_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MFPAPP_RLP_INUSE_FwdReservationOn_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MFPAPP_RLP_INUSE_FwdReservationOn_contents_data01_data*)EDAlloc (sizeof (c_MFPAPP_RLP_INUSE_FwdReservationOn_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MFPAPP_RLP_INUSE_FwdReservationOn_contents_data01_data));
			(sequence->data[i]->ReservationLabel) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MFPAPP_RLP_INUSE_FwdReservationOn_contents_data01_data */
void FREE_c_MFPAPP_RLP_INUSE_FwdReservationOn_contents_data01_data (c_MFPAPP_RLP_INUSE_FwdReservationOn_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_MFPAPP_RLP_INUSE_AttributeUpdateRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MFPAPP_RLP_INUSE_AttributeUpdateRequest_contents_data01 (c_MFPAPP_RLP_INUSE_AttributeUpdateRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MFPAPP_RLP_INUSE_AttributeUpdateRequest_contents_data01_data** tmp;
		tmp = (c_MFPAPP_RLP_INUSE_AttributeUpdateRequest_contents_data01_data**)EDAlloc (sizeof (c_MFPAPP_RLP_INUSE_AttributeUpdateRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MFPAPP_RLP_INUSE_AttributeUpdateRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MFPAPP_RLP_INUSE_AttributeUpdateRequest_contents_data01_data*)EDAlloc (sizeof (c_MFPAPP_RLP_INUSE_AttributeUpdateRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MFPAPP_RLP_INUSE_AttributeUpdateRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Multi_Flow_Packet_Application_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Multi_Flow_Packet_Application_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MFPAPP_RLP_INUSE_AttributeUpdateRequest_contents_data01_data */
void FREE_c_MFPAPP_RLP_INUSE_AttributeUpdateRequest_contents_data01_data (c_MFPAPP_RLP_INUSE_AttributeUpdateRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Multi_Flow_Packet_Application_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_STREAM_DSP_INCFG_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_STREAM_DSP_INCFG_ConfigurationRequest_contents_data01 (c_STREAM_DSP_INCFG_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_STREAM_DSP_INCFG_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_STREAM_DSP_INCFG_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_STREAM_DSP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_STREAM_DSP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_STREAM_DSP_INCFG_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_STREAM_DSP_INCFG_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_STREAM_DSP_INCFG_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Default_Stream_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Default_Stream_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_STREAM_DSP_INCFG_ConfigurationRequest_contents_data01_data */
void FREE_c_STREAM_DSP_INCFG_ConfigurationRequest_contents_data01_data (c_STREAM_DSP_INCFG_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Default_Stream_Protocol_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_STREAM_DSP_INCFG_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_STREAM_DSP_INCFG_ConfigurationResponse_contents_data01 (c_STREAM_DSP_INCFG_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_STREAM_DSP_INCFG_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_STREAM_DSP_INCFG_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_STREAM_DSP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_STREAM_DSP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_STREAM_DSP_INCFG_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_STREAM_DSP_INCFG_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_STREAM_DSP_INCFG_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Default_Stream_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Default_Stream_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_STREAM_DSP_INCFG_ConfigurationResponse_contents_data01_data */
void FREE_c_STREAM_DSP_INCFG_ConfigurationResponse_contents_data01_data (c_STREAM_DSP_INCFG_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Default_Stream_Protocol_Attributes_Response (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_STREAM_GVSP_INCFG_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_STREAM_GVSP_INCFG_ConfigurationRequest_contents_data01 (c_STREAM_GVSP_INCFG_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_STREAM_GVSP_INCFG_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_STREAM_GVSP_INCFG_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_STREAM_GVSP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_STREAM_GVSP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_STREAM_GVSP_INCFG_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_STREAM_GVSP_INCFG_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_STREAM_GVSP_INCFG_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Generic_Virtual_Stream_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Generic_Virtual_Stream_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_STREAM_GVSP_INCFG_ConfigurationRequest_contents_data01_data */
void FREE_c_STREAM_GVSP_INCFG_ConfigurationRequest_contents_data01_data (c_STREAM_GVSP_INCFG_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Generic_Virtual_Stream_Protocol_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_STREAM_GVSP_INCFG_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_STREAM_GVSP_INCFG_ConfigurationResponse_contents_data01 (c_STREAM_GVSP_INCFG_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_STREAM_GVSP_INCFG_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_STREAM_GVSP_INCFG_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_STREAM_GVSP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_STREAM_GVSP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_STREAM_GVSP_INCFG_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_STREAM_GVSP_INCFG_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_STREAM_GVSP_INCFG_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Generic_Virtual_Stream_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Generic_Virtual_Stream_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_STREAM_GVSP_INCFG_ConfigurationResponse_contents_data01_data */
void FREE_c_STREAM_GVSP_INCFG_ConfigurationResponse_contents_data01_data (c_STREAM_GVSP_INCFG_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Generic_Virtual_Stream_Protocol_Attributes_Response (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_SESSION_DSMP_INCFG_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_SESSION_DSMP_INCFG_ConfigurationRequest_contents_data01 (c_SESSION_DSMP_INCFG_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_SESSION_DSMP_INCFG_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_SESSION_DSMP_INCFG_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_SESSION_DSMP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_SESSION_DSMP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_SESSION_DSMP_INCFG_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_SESSION_DSMP_INCFG_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_SESSION_DSMP_INCFG_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Default_Session_Management_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Default_Session_Management_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_SESSION_DSMP_INCFG_ConfigurationRequest_contents_data01_data */
void FREE_c_SESSION_DSMP_INCFG_ConfigurationRequest_contents_data01_data (c_SESSION_DSMP_INCFG_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Default_Session_Management_Protocol_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_SESSION_DSMP_INCFG_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_SESSION_DSMP_INCFG_ConfigurationResponse_contents_data01 (c_SESSION_DSMP_INCFG_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_SESSION_DSMP_INCFG_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_SESSION_DSMP_INCFG_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_SESSION_DSMP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_SESSION_DSMP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_SESSION_DSMP_INCFG_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_SESSION_DSMP_INCFG_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_SESSION_DSMP_INCFG_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Default_Session_Management_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Default_Session_Management_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_SESSION_DSMP_INCFG_ConfigurationResponse_contents_data01_data */
void FREE_c_SESSION_DSMP_INCFG_ConfigurationResponse_contents_data01_data (c_SESSION_DSMP_INCFG_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Default_Session_Management_Protocol_Attributes_Response (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_SESSION_DAMP_INCFG_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_SESSION_DAMP_INCFG_ConfigurationRequest_contents_data01 (c_SESSION_DAMP_INCFG_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_SESSION_DAMP_INCFG_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_SESSION_DAMP_INCFG_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_SESSION_DAMP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_SESSION_DAMP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_SESSION_DAMP_INCFG_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_SESSION_DAMP_INCFG_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_SESSION_DAMP_INCFG_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Default_Address_Management_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Default_Address_Management_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_SESSION_DAMP_INCFG_ConfigurationRequest_contents_data01_data */
void FREE_c_SESSION_DAMP_INCFG_ConfigurationRequest_contents_data01_data (c_SESSION_DAMP_INCFG_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Default_Address_Management_Protocol_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_SESSION_DAMP_INCFG_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_SESSION_DAMP_INCFG_ConfigurationResponse_contents_data01 (c_SESSION_DAMP_INCFG_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_SESSION_DAMP_INCFG_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_SESSION_DAMP_INCFG_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_SESSION_DAMP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_SESSION_DAMP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_SESSION_DAMP_INCFG_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_SESSION_DAMP_INCFG_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_SESSION_DAMP_INCFG_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Default_Address_Management_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Default_Address_Management_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_SESSION_DAMP_INCFG_ConfigurationResponse_contents_data01_data */
void FREE_c_SESSION_DAMP_INCFG_ConfigurationResponse_contents_data01_data (c_SESSION_DAMP_INCFG_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Default_Address_Management_Protocol_Attributes_Response (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_SESSION_DAMP_INUSE_AttributeUpdateRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_SESSION_DAMP_INUSE_AttributeUpdateRequest_contents_data01 (c_SESSION_DAMP_INUSE_AttributeUpdateRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_SESSION_DAMP_INUSE_AttributeUpdateRequest_contents_data01_data** tmp;
		tmp = (c_SESSION_DAMP_INUSE_AttributeUpdateRequest_contents_data01_data**)EDAlloc (sizeof (c_SESSION_DAMP_INUSE_AttributeUpdateRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_SESSION_DAMP_INUSE_AttributeUpdateRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_SESSION_DAMP_INUSE_AttributeUpdateRequest_contents_data01_data*)EDAlloc (sizeof (c_SESSION_DAMP_INUSE_AttributeUpdateRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_SESSION_DAMP_INUSE_AttributeUpdateRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Default_Address_Management_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Default_Address_Management_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_SESSION_DAMP_INUSE_AttributeUpdateRequest_contents_data01_data */
void FREE_c_SESSION_DAMP_INUSE_AttributeUpdateRequest_contents_data01_data (c_SESSION_DAMP_INUSE_AttributeUpdateRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Default_Address_Management_Protocol_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_SESSION_DSCP_INUSE_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_SESSION_DSCP_INUSE_ConfigurationRequest_contents_data01 (c_SESSION_DSCP_INUSE_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_SESSION_DSCP_INUSE_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_SESSION_DSCP_INUSE_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_SESSION_DSCP_INUSE_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_SESSION_DSCP_INUSE_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_SESSION_DSCP_INUSE_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_SESSION_DSCP_INUSE_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_SESSION_DSCP_INUSE_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Default_Session_Configuration_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Default_Session_Configuration_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_SESSION_DSCP_INUSE_ConfigurationRequest_contents_data01_data */
void FREE_c_SESSION_DSCP_INUSE_ConfigurationRequest_contents_data01_data (c_SESSION_DSCP_INUSE_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Default_Session_Configuration_Protocol_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_SESSION_DSCP_INUSE_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_SESSION_DSCP_INUSE_ConfigurationResponse_contents_data01 (c_SESSION_DSCP_INUSE_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_SESSION_DSCP_INUSE_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_SESSION_DSCP_INUSE_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_SESSION_DSCP_INUSE_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_SESSION_DSCP_INUSE_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_SESSION_DSCP_INUSE_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_SESSION_DSCP_INUSE_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_SESSION_DSCP_INUSE_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Default_Session_Configuration_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Default_Session_Configuration_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_SESSION_DSCP_INUSE_ConfigurationResponse_contents_data01_data */
void FREE_c_SESSION_DSCP_INUSE_ConfigurationResponse_contents_data01_data (c_SESSION_DSCP_INUSE_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Default_Session_Configuration_Protocol_Attributes_Response (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_SESSION_DSCP_INUSE_DeletePersonality_contents_data01'. Existing items are not changed. */
int SETITEMS_c_SESSION_DSCP_INUSE_DeletePersonality_contents_data01 (c_SESSION_DSCP_INUSE_DeletePersonality_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_SESSION_DSCP_INUSE_DeletePersonality_contents_data01_data** tmp;
		tmp = (c_SESSION_DSCP_INUSE_DeletePersonality_contents_data01_data**)EDAlloc (sizeof (c_SESSION_DSCP_INUSE_DeletePersonality_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_SESSION_DSCP_INUSE_DeletePersonality_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_SESSION_DSCP_INUSE_DeletePersonality_contents_data01_data*)EDAlloc (sizeof (c_SESSION_DSCP_INUSE_DeletePersonality_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_SESSION_DSCP_INUSE_DeletePersonality_contents_data01_data));
			(sequence->data[i]->PersonalityIndex) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_SESSION_DSCP_INUSE_DeletePersonality_contents_data01_data */
void FREE_c_SESSION_DSCP_INUSE_DeletePersonality_contents_data01_data (c_SESSION_DSCP_INUSE_DeletePersonality_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_SESSION_DSCP_INUSE_AttributeUpdateRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_SESSION_DSCP_INUSE_AttributeUpdateRequest_contents_data01 (c_SESSION_DSCP_INUSE_AttributeUpdateRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_SESSION_DSCP_INUSE_AttributeUpdateRequest_contents_data01_data** tmp;
		tmp = (c_SESSION_DSCP_INUSE_AttributeUpdateRequest_contents_data01_data**)EDAlloc (sizeof (c_SESSION_DSCP_INUSE_AttributeUpdateRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_SESSION_DSCP_INUSE_AttributeUpdateRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_SESSION_DSCP_INUSE_AttributeUpdateRequest_contents_data01_data*)EDAlloc (sizeof (c_SESSION_DSCP_INUSE_AttributeUpdateRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_SESSION_DSCP_INUSE_AttributeUpdateRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Default_Session_Configuration_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Default_Session_Configuration_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_SESSION_DSCP_INUSE_AttributeUpdateRequest_contents_data01_data */
void FREE_c_SESSION_DSCP_INUSE_AttributeUpdateRequest_contents_data01_data (c_SESSION_DSCP_INUSE_AttributeUpdateRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Default_Session_Configuration_Protocol_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_SESSION_GMCDP_INCFG_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_SESSION_GMCDP_INCFG_ConfigurationRequest_contents_data01 (c_SESSION_GMCDP_INCFG_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_SESSION_GMCDP_INCFG_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_SESSION_GMCDP_INCFG_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_SESSION_GMCDP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_SESSION_GMCDP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_SESSION_GMCDP_INCFG_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_SESSION_GMCDP_INCFG_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_SESSION_GMCDP_INCFG_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Generic_Multimode_Capability_Discovery_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Generic_Multimode_Capability_Discovery_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_SESSION_GMCDP_INCFG_ConfigurationRequest_contents_data01_data */
void FREE_c_SESSION_GMCDP_INCFG_ConfigurationRequest_contents_data01_data (c_SESSION_GMCDP_INCFG_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Generic_Multimode_Capability_Discovery_Protocol_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_SESSION_GMCDP_INCFG_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_SESSION_GMCDP_INCFG_ConfigurationResponse_contents_data01 (c_SESSION_GMCDP_INCFG_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_SESSION_GMCDP_INCFG_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_SESSION_GMCDP_INCFG_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_SESSION_GMCDP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_SESSION_GMCDP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_SESSION_GMCDP_INCFG_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_SESSION_GMCDP_INCFG_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_SESSION_GMCDP_INCFG_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Generic_Multimode_Capability_Discovery_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Generic_Multimode_Capability_Discovery_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_SESSION_GMCDP_INCFG_ConfigurationResponse_contents_data01_data */
void FREE_c_SESSION_GMCDP_INCFG_ConfigurationResponse_contents_data01_data (c_SESSION_GMCDP_INCFG_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Generic_Multimode_Capability_Discovery_Protocol_Attributes_Response (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_CONN_DALMP_INCFG_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_CONN_DALMP_INCFG_ConfigurationRequest_contents_data01 (c_CONN_DALMP_INCFG_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_DALMP_INCFG_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_CONN_DALMP_INCFG_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_CONN_DALMP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_DALMP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_DALMP_INCFG_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_CONN_DALMP_INCFG_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_DALMP_INCFG_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Default_Air_Link_Management_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Default_Air_Link_Management_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_DALMP_INCFG_ConfigurationRequest_contents_data01_data */
void FREE_c_CONN_DALMP_INCFG_ConfigurationRequest_contents_data01_data (c_CONN_DALMP_INCFG_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Default_Air_Link_Management_Protocol_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_CONN_DALMP_INCFG_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_CONN_DALMP_INCFG_ConfigurationResponse_contents_data01 (c_CONN_DALMP_INCFG_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_DALMP_INCFG_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_CONN_DALMP_INCFG_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_CONN_DALMP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_DALMP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_DALMP_INCFG_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_CONN_DALMP_INCFG_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_DALMP_INCFG_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Default_Air_Link_Management_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Default_Air_Link_Management_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_DALMP_INCFG_ConfigurationResponse_contents_data01_data */
void FREE_c_CONN_DALMP_INCFG_ConfigurationResponse_contents_data01_data (c_CONN_DALMP_INCFG_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Default_Air_Link_Management_Protocol_Attributes_Response (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_CONN_DALMP_INUSE_Redirect_contents_data01'. Existing items are not changed. */
int SETITEMS_c_CONN_DALMP_INUSE_Redirect_contents_data01 (c_CONN_DALMP_INUSE_Redirect_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_DALMP_INUSE_Redirect_contents_data01_data** tmp;
		tmp = (c_CONN_DALMP_INUSE_Redirect_contents_data01_data**)EDAlloc (sizeof (c_CONN_DALMP_INUSE_Redirect_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_DALMP_INUSE_Redirect_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_DALMP_INUSE_Redirect_contents_data01_data*)EDAlloc (sizeof (c_CONN_DALMP_INUSE_Redirect_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_DALMP_INUSE_Redirect_contents_data01_data));
			(sequence->data[i]->Channel.SystemType) = 0;
			(sequence->data[i]->Channel.BandClass) = 0;
			(sequence->data[i]->Channel.ChannelNumber) = 0;
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_DALMP_INUSE_Redirect_contents_data01_data */
void FREE_c_CONN_DALMP_INUSE_Redirect_contents_data01_data (c_CONN_DALMP_INUSE_Redirect_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_CONN_DALMP_INUSE_Redirect_contents_data01_data_Channel */
void FREE_c_CONN_DALMP_INUSE_Redirect_contents_data01_data_Channel (c_CONN_DALMP_INUSE_Redirect_contents_data01_data_Channel* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_DALMP_INUSE_ConnectionFailureReport_contents_data01'. Existing items are not changed. */
int SETITEMS_c_CONN_DALMP_INUSE_ConnectionFailureReport_contents_data01 (c_CONN_DALMP_INUSE_ConnectionFailureReport_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_DALMP_INUSE_ConnectionFailureReport_contents_data01_data** tmp;
		tmp = (c_CONN_DALMP_INUSE_ConnectionFailureReport_contents_data01_data**)EDAlloc (sizeof (c_CONN_DALMP_INUSE_ConnectionFailureReport_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_DALMP_INUSE_ConnectionFailureReport_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_DALMP_INUSE_ConnectionFailureReport_contents_data01_data*)EDAlloc (sizeof (c_CONN_DALMP_INUSE_ConnectionFailureReport_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_DALMP_INUSE_ConnectionFailureReport_contents_data01_data));
			(sequence->data[i]->ConnectionFailureReason) = 0;
			(sequence->data[i]->TimeStamp) = 0;
			ED_RESET_MEM (sequence->data[i]->SectorID, 16);
			
			(sequence->data[i]->ChannelRecord.SystemType) = 0;
			(sequence->data[i]->ChannelRecord.BandClass) = 0;
			(sequence->data[i]->ChannelRecord.ChannelNumber) = 0;
			
			(sequence->data[i]->LatLongIncluded) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->Latitude_Present) {
				}
				if (sequence->data[i]->Longitude_Present) {
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_DALMP_INUSE_ConnectionFailureReport_contents_data01_data */
void FREE_c_CONN_DALMP_INUSE_ConnectionFailureReport_contents_data01_data (c_CONN_DALMP_INUSE_ConnectionFailureReport_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_CONN_DALMP_INUSE_ConnectionFailureReport_contents_data01_data_ChannelRecord */
void FREE_c_CONN_DALMP_INUSE_ConnectionFailureReport_contents_data01_data_ChannelRecord (c_CONN_DALMP_INUSE_ConnectionFailureReport_contents_data01_data_ChannelRecord* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_DINSP_INCFG_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_CONN_DINSP_INCFG_ConfigurationRequest_contents_data01 (c_CONN_DINSP_INCFG_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_DINSP_INCFG_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_CONN_DINSP_INCFG_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_CONN_DINSP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_DINSP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_DINSP_INCFG_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_CONN_DINSP_INCFG_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_DINSP_INCFG_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeRecord.Length) = 0;
			(sequence->data[i]->AttributeRecord.AttributeID) = 0;
			sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
			sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
			
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->AttributeRecord.AttributeValue.value != NULL) {
					EDFree (sequence->data[i]->AttributeRecord.AttributeValue.value);
					sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
				}
				sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_DINSP_INCFG_ConfigurationRequest_contents_data01_data */
void FREE_c_CONN_DINSP_INCFG_ConfigurationRequest_contents_data01_data (c_CONN_DINSP_INCFG_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeRecord.AttributeValue.value != NULL) {
		EDFree (sp->AttributeRecord.AttributeValue.value);
		sp->AttributeRecord.AttributeValue.value = NULL;
	}
	sp->AttributeRecord.AttributeValue.usedBits = 0;

}

/* Free function for struct c_CONN_DINSP_INCFG_ConfigurationRequest_contents_data01_data_AttributeRecord */
void FREE_c_CONN_DINSP_INCFG_ConfigurationRequest_contents_data01_data_AttributeRecord (c_CONN_DINSP_INCFG_ConfigurationRequest_contents_data01_data_AttributeRecord* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeValue.value != NULL) {
		EDFree (sp->AttributeValue.value);
		sp->AttributeValue.value = NULL;
	}
	sp->AttributeValue.usedBits = 0;

}

/* SETITEMS commands for type 'c_CONN_DINSP_INCFG_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_CONN_DINSP_INCFG_ConfigurationResponse_contents_data01 (c_CONN_DINSP_INCFG_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_DINSP_INCFG_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_CONN_DINSP_INCFG_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_CONN_DINSP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_DINSP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_DINSP_INCFG_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_CONN_DINSP_INCFG_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_DINSP_INCFG_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeRecord.Length) = 0;
			(sequence->data[i]->AttributeRecord.AttributeID) = 0;
			sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
			sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
			
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->AttributeRecord.AttributeValue.value != NULL) {
					EDFree (sequence->data[i]->AttributeRecord.AttributeValue.value);
					sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
				}
				sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_DINSP_INCFG_ConfigurationResponse_contents_data01_data */
void FREE_c_CONN_DINSP_INCFG_ConfigurationResponse_contents_data01_data (c_CONN_DINSP_INCFG_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeRecord.AttributeValue.value != NULL) {
		EDFree (sp->AttributeRecord.AttributeValue.value);
		sp->AttributeRecord.AttributeValue.value = NULL;
	}
	sp->AttributeRecord.AttributeValue.usedBits = 0;

}

/* Free function for struct c_CONN_DINSP_INCFG_ConfigurationResponse_contents_data01_data_AttributeRecord */
void FREE_c_CONN_DINSP_INCFG_ConfigurationResponse_contents_data01_data_AttributeRecord (c_CONN_DINSP_INCFG_ConfigurationResponse_contents_data01_data_AttributeRecord* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeValue.value != NULL) {
		EDFree (sp->AttributeValue.value);
		sp->AttributeValue.value = NULL;
	}
	sp->AttributeValue.usedBits = 0;

}

/* SETITEMS commands for type 'c_CONN_DIDSP_INCFG_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_CONN_DIDSP_INCFG_ConfigurationRequest_contents_data01 (c_CONN_DIDSP_INCFG_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_DIDSP_INCFG_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_CONN_DIDSP_INCFG_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_CONN_DIDSP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_DIDSP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_DIDSP_INCFG_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_CONN_DIDSP_INCFG_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_DIDSP_INCFG_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Default_Idle_State_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Default_Idle_State_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_DIDSP_INCFG_ConfigurationRequest_contents_data01_data */
void FREE_c_CONN_DIDSP_INCFG_ConfigurationRequest_contents_data01_data (c_CONN_DIDSP_INCFG_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Default_Idle_State_Protocol_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_CONN_DIDSP_INCFG_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_CONN_DIDSP_INCFG_ConfigurationResponse_contents_data01 (c_CONN_DIDSP_INCFG_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_DIDSP_INCFG_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_CONN_DIDSP_INCFG_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_CONN_DIDSP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_DIDSP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_DIDSP_INCFG_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_CONN_DIDSP_INCFG_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_DIDSP_INCFG_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Default_Idle_State_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Default_Idle_State_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_DIDSP_INCFG_ConfigurationResponse_contents_data01_data */
void FREE_c_CONN_DIDSP_INCFG_ConfigurationResponse_contents_data01_data (c_CONN_DIDSP_INCFG_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Default_Idle_State_Protocol_Attributes_Response (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_CONN_EISP_INCFG_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_CONN_EISP_INCFG_ConfigurationRequest_contents_data01 (c_CONN_EISP_INCFG_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_EISP_INCFG_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_CONN_EISP_INCFG_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_CONN_EISP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_EISP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_EISP_INCFG_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_CONN_EISP_INCFG_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_EISP_INCFG_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Enhanced_Idle_State_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Enhanced_Idle_State_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_EISP_INCFG_ConfigurationRequest_contents_data01_data */
void FREE_c_CONN_EISP_INCFG_ConfigurationRequest_contents_data01_data (c_CONN_EISP_INCFG_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Enhanced_Idle_State_Protocol_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_CONN_EISP_INCFG_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_CONN_EISP_INCFG_ConfigurationResponse_contents_data01 (c_CONN_EISP_INCFG_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_EISP_INCFG_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_CONN_EISP_INCFG_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_CONN_EISP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_EISP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_EISP_INCFG_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_CONN_EISP_INCFG_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_EISP_INCFG_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Enhanced_Idle_State_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Enhanced_Idle_State_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_EISP_INCFG_ConfigurationResponse_contents_data01_data */
void FREE_c_CONN_EISP_INCFG_ConfigurationResponse_contents_data01_data (c_CONN_EISP_INCFG_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Enhanced_Idle_State_Protocol_Attributes_Response (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_CONN_EISP_INUSE_ConnectionRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_CONN_EISP_INUSE_ConnectionRequest_contents_data01 (c_CONN_EISP_INUSE_ConnectionRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_EISP_INUSE_ConnectionRequest_contents_data01_data** tmp;
		tmp = (c_CONN_EISP_INUSE_ConnectionRequest_contents_data01_data**)EDAlloc (sizeof (c_CONN_EISP_INUSE_ConnectionRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_EISP_INUSE_ConnectionRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_EISP_INUSE_ConnectionRequest_contents_data01_data*)EDAlloc (sizeof (c_CONN_EISP_INUSE_ConnectionRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_EISP_INUSE_ConnectionRequest_contents_data01_data));
			(sequence->data[i]->PreferredChannel.SystemType) = 0;
			(sequence->data[i]->PreferredChannel.BandClass) = 0;
			(sequence->data[i]->PreferredChannel.ChannelNumber) = 0;
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_EISP_INUSE_ConnectionRequest_contents_data01_data */
void FREE_c_CONN_EISP_INUSE_ConnectionRequest_contents_data01_data (c_CONN_EISP_INUSE_ConnectionRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_CONN_EISP_INUSE_ConnectionRequest_contents_data01_data_PreferredChannel */
void FREE_c_CONN_EISP_INUSE_ConnectionRequest_contents_data01_data_PreferredChannel (c_CONN_EISP_INUSE_ConnectionRequest_contents_data01_data_PreferredChannel* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_EISP_INUSE_AttributeUpdateRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_CONN_EISP_INUSE_AttributeUpdateRequest_contents_data01 (c_CONN_EISP_INUSE_AttributeUpdateRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_EISP_INUSE_AttributeUpdateRequest_contents_data01_data** tmp;
		tmp = (c_CONN_EISP_INUSE_AttributeUpdateRequest_contents_data01_data**)EDAlloc (sizeof (c_CONN_EISP_INUSE_AttributeUpdateRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_EISP_INUSE_AttributeUpdateRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_EISP_INUSE_AttributeUpdateRequest_contents_data01_data*)EDAlloc (sizeof (c_CONN_EISP_INUSE_AttributeUpdateRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_EISP_INUSE_AttributeUpdateRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Enhanced_Idle_State_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Enhanced_Idle_State_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_EISP_INUSE_AttributeUpdateRequest_contents_data01_data */
void FREE_c_CONN_EISP_INUSE_AttributeUpdateRequest_contents_data01_data (c_CONN_EISP_INUSE_AttributeUpdateRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Enhanced_Idle_State_Protocol_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_CONN_QISP_INCFG_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_CONN_QISP_INCFG_ConfigurationRequest_contents_data01 (c_CONN_QISP_INCFG_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_QISP_INCFG_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_CONN_QISP_INCFG_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_CONN_QISP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_QISP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_QISP_INCFG_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_CONN_QISP_INCFG_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_QISP_INCFG_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Quick_Idle_State_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Quick_Idle_State_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_QISP_INCFG_ConfigurationRequest_contents_data01_data */
void FREE_c_CONN_QISP_INCFG_ConfigurationRequest_contents_data01_data (c_CONN_QISP_INCFG_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Quick_Idle_State_Protocol_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_CONN_QISP_INCFG_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_CONN_QISP_INCFG_ConfigurationResponse_contents_data01 (c_CONN_QISP_INCFG_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_QISP_INCFG_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_CONN_QISP_INCFG_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_CONN_QISP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_QISP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_QISP_INCFG_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_CONN_QISP_INCFG_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_QISP_INCFG_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Quick_Idle_State_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Quick_Idle_State_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_QISP_INCFG_ConfigurationResponse_contents_data01_data */
void FREE_c_CONN_QISP_INCFG_ConfigurationResponse_contents_data01_data (c_CONN_QISP_INCFG_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Quick_Idle_State_Protocol_Attributes_Response (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_CONN_QISP_INUSE_ConnectionRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_CONN_QISP_INUSE_ConnectionRequest_contents_data01 (c_CONN_QISP_INUSE_ConnectionRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_QISP_INUSE_ConnectionRequest_contents_data01_data** tmp;
		tmp = (c_CONN_QISP_INUSE_ConnectionRequest_contents_data01_data**)EDAlloc (sizeof (c_CONN_QISP_INUSE_ConnectionRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_QISP_INUSE_ConnectionRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_QISP_INUSE_ConnectionRequest_contents_data01_data*)EDAlloc (sizeof (c_CONN_QISP_INUSE_ConnectionRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_QISP_INUSE_ConnectionRequest_contents_data01_data));
			(sequence->data[i]->PreferredChannel.SystemType) = 0;
			(sequence->data[i]->PreferredChannel.BandClass) = 0;
			(sequence->data[i]->PreferredChannel.ChannelNumber) = 0;
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_QISP_INUSE_ConnectionRequest_contents_data01_data */
void FREE_c_CONN_QISP_INUSE_ConnectionRequest_contents_data01_data (c_CONN_QISP_INUSE_ConnectionRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_CONN_QISP_INUSE_ConnectionRequest_contents_data01_data_PreferredChannel */
void FREE_c_CONN_QISP_INUSE_ConnectionRequest_contents_data01_data_PreferredChannel (c_CONN_QISP_INUSE_ConnectionRequest_contents_data01_data_PreferredChannel* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_QISP_INUSE_QuickPage_contents_data01'. Existing items are not changed. */
int SETITEMS_c_CONN_QISP_INUSE_QuickPage_contents_data01 (c_CONN_QISP_INUSE_QuickPage_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_QISP_INUSE_QuickPage_contents_data01_data** tmp;
		tmp = (c_CONN_QISP_INUSE_QuickPage_contents_data01_data**)EDAlloc (sizeof (c_CONN_QISP_INUSE_QuickPage_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_QISP_INUSE_QuickPage_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_QISP_INUSE_QuickPage_contents_data01_data*)EDAlloc (sizeof (c_CONN_QISP_INUSE_QuickPage_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_QISP_INUSE_QuickPage_contents_data01_data));
			(sequence->data[i]->QuickPageIndicator) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_QISP_INUSE_QuickPage_contents_data01_data */
void FREE_c_CONN_QISP_INUSE_QuickPage_contents_data01_data (c_CONN_QISP_INUSE_QuickPage_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_QISP_INUSE_AttributeUpdateRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_CONN_QISP_INUSE_AttributeUpdateRequest_contents_data01 (c_CONN_QISP_INUSE_AttributeUpdateRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_QISP_INUSE_AttributeUpdateRequest_contents_data01_data** tmp;
		tmp = (c_CONN_QISP_INUSE_AttributeUpdateRequest_contents_data01_data**)EDAlloc (sizeof (c_CONN_QISP_INUSE_AttributeUpdateRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_QISP_INUSE_AttributeUpdateRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_QISP_INUSE_AttributeUpdateRequest_contents_data01_data*)EDAlloc (sizeof (c_CONN_QISP_INUSE_AttributeUpdateRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_QISP_INUSE_AttributeUpdateRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Quick_Idle_State_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Quick_Idle_State_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_QISP_INUSE_AttributeUpdateRequest_contents_data01_data */
void FREE_c_CONN_QISP_INUSE_AttributeUpdateRequest_contents_data01_data (c_CONN_QISP_INUSE_AttributeUpdateRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Quick_Idle_State_Protocol_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_CONN_DCSP_INCFG_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_CONN_DCSP_INCFG_ConfigurationRequest_contents_data01 (c_CONN_DCSP_INCFG_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_DCSP_INCFG_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_CONN_DCSP_INCFG_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_CONN_DCSP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_DCSP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_DCSP_INCFG_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_CONN_DCSP_INCFG_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_DCSP_INCFG_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeRecord.Length) = 0;
			(sequence->data[i]->AttributeRecord.AttributeID) = 0;
			sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
			sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
			
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->AttributeRecord.AttributeValue.value != NULL) {
					EDFree (sequence->data[i]->AttributeRecord.AttributeValue.value);
					sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
				}
				sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_DCSP_INCFG_ConfigurationRequest_contents_data01_data */
void FREE_c_CONN_DCSP_INCFG_ConfigurationRequest_contents_data01_data (c_CONN_DCSP_INCFG_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeRecord.AttributeValue.value != NULL) {
		EDFree (sp->AttributeRecord.AttributeValue.value);
		sp->AttributeRecord.AttributeValue.value = NULL;
	}
	sp->AttributeRecord.AttributeValue.usedBits = 0;

}

/* Free function for struct c_CONN_DCSP_INCFG_ConfigurationRequest_contents_data01_data_AttributeRecord */
void FREE_c_CONN_DCSP_INCFG_ConfigurationRequest_contents_data01_data_AttributeRecord (c_CONN_DCSP_INCFG_ConfigurationRequest_contents_data01_data_AttributeRecord* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeValue.value != NULL) {
		EDFree (sp->AttributeValue.value);
		sp->AttributeValue.value = NULL;
	}
	sp->AttributeValue.usedBits = 0;

}

/* SETITEMS commands for type 'c_CONN_DCSP_INCFG_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_CONN_DCSP_INCFG_ConfigurationResponse_contents_data01 (c_CONN_DCSP_INCFG_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_DCSP_INCFG_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_CONN_DCSP_INCFG_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_CONN_DCSP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_DCSP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_DCSP_INCFG_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_CONN_DCSP_INCFG_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_DCSP_INCFG_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeRecord.Length) = 0;
			(sequence->data[i]->AttributeRecord.AttributeID) = 0;
			sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
			sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
			
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->AttributeRecord.AttributeValue.value != NULL) {
					EDFree (sequence->data[i]->AttributeRecord.AttributeValue.value);
					sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
				}
				sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_DCSP_INCFG_ConfigurationResponse_contents_data01_data */
void FREE_c_CONN_DCSP_INCFG_ConfigurationResponse_contents_data01_data (c_CONN_DCSP_INCFG_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeRecord.AttributeValue.value != NULL) {
		EDFree (sp->AttributeRecord.AttributeValue.value);
		sp->AttributeRecord.AttributeValue.value = NULL;
	}
	sp->AttributeRecord.AttributeValue.usedBits = 0;

}

/* Free function for struct c_CONN_DCSP_INCFG_ConfigurationResponse_contents_data01_data_AttributeRecord */
void FREE_c_CONN_DCSP_INCFG_ConfigurationResponse_contents_data01_data_AttributeRecord (c_CONN_DCSP_INCFG_ConfigurationResponse_contents_data01_data_AttributeRecord* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeValue.value != NULL) {
		EDFree (sp->AttributeValue.value);
		sp->AttributeValue.value = NULL;
	}
	sp->AttributeValue.usedBits = 0;

}

/* SETITEMS commands for type 'c_CONN_DRUP_INCFG_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_CONN_DRUP_INCFG_ConfigurationRequest_contents_data01 (c_CONN_DRUP_INCFG_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_DRUP_INCFG_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_CONN_DRUP_INCFG_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_CONN_DRUP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_DRUP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_DRUP_INCFG_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_CONN_DRUP_INCFG_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_DRUP_INCFG_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Default_Route_Update_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Default_Route_Update_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_DRUP_INCFG_ConfigurationRequest_contents_data01_data */
void FREE_c_CONN_DRUP_INCFG_ConfigurationRequest_contents_data01_data (c_CONN_DRUP_INCFG_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Default_Route_Update_Protocol_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_CONN_DRUP_INCFG_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_CONN_DRUP_INCFG_ConfigurationResponse_contents_data01 (c_CONN_DRUP_INCFG_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_DRUP_INCFG_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_CONN_DRUP_INCFG_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_CONN_DRUP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_DRUP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_DRUP_INCFG_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_CONN_DRUP_INCFG_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_DRUP_INCFG_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Default_Route_Update_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Default_Route_Update_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_DRUP_INCFG_ConfigurationResponse_contents_data01_data */
void FREE_c_CONN_DRUP_INCFG_ConfigurationResponse_contents_data01_data (c_CONN_DRUP_INCFG_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Default_Route_Update_Protocol_Attributes_Response (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_CONN_DRUP_INUSE_RouteUpdate_contents_data01'. Existing items are not changed. */
int SETITEMS_c_CONN_DRUP_INUSE_RouteUpdate_contents_data01 (c_CONN_DRUP_INUSE_RouteUpdate_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_DRUP_INUSE_RouteUpdate_contents_data01_data** tmp;
		tmp = (c_CONN_DRUP_INUSE_RouteUpdate_contents_data01_data**)EDAlloc (sizeof (c_CONN_DRUP_INUSE_RouteUpdate_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_DRUP_INUSE_RouteUpdate_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_DRUP_INUSE_RouteUpdate_contents_data01_data*)EDAlloc (sizeof (c_CONN_DRUP_INUSE_RouteUpdate_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_DRUP_INUSE_RouteUpdate_contents_data01_data));
			(sequence->data[i]->PilotPNPhase) = 0;
			(sequence->data[i]->ChannelIncluded) = 0;
			(sequence->data[i]->PilotStrength) = 0;
			(sequence->data[i]->Keep) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->Channel_Present) {
					EDFree (sequence->data[i]->Channel);
					sequence->data[i]->Channel = NULL;
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_DRUP_INUSE_RouteUpdate_contents_data01_data */
void FREE_c_CONN_DRUP_INUSE_RouteUpdate_contents_data01_data (c_CONN_DRUP_INUSE_RouteUpdate_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->Channel_Present) {
		EDFree (sp->Channel);
		sp->Channel = NULL;
		sp->Channel_Present = ED_FALSE;
	}

}

void SETPRESENT_c_CONN_DRUP_INUSE_RouteUpdate_contents_data01_data_Channel (c_CONN_DRUP_INUSE_RouteUpdate_contents_data01_data* sp, ED_BOOLEAN present)
{
	/* Do nothing if already compliant to the request */
	if (sp->Channel_Present == present) return;
	sp->Channel_Present = present;
	if (present) {
		/*-->*/sp->Channel = (c_CONN_DRUP_INUSE_RouteUpdate_contents_data01_data_Channel*)EDAlloc (sizeof (c_CONN_DRUP_INUSE_RouteUpdate_contents_data01_data_Channel));
		ED_RESET_MEM (sp->Channel, sizeof (c_CONN_DRUP_INUSE_RouteUpdate_contents_data01_data_Channel));
		(sp->Channel->SystemType) = 0;
		(sp->Channel->BandClass) = 0;
		(sp->Channel->ChannelNumber) = 0;
	} else {
		EDFree (sp->Channel);
		sp->Channel = NULL;
	}
}

/* Free function for struct c_CONN_DRUP_INUSE_RouteUpdate_contents_data01_data_Channel */
void FREE_c_CONN_DRUP_INUSE_RouteUpdate_contents_data01_data_Channel (c_CONN_DRUP_INUSE_RouteUpdate_contents_data01_data_Channel* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_Channel */
void FREE_c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_Channel (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_Channel* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data01'. Existing items are not changed. */
int SETITEMS_c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data01 (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data01_data** tmp;
		tmp = (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data01_data**)EDAlloc (sizeof (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data01_data*)EDAlloc (sizeof (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data01_data));
			(sequence->data[i]->PilotPN) = 0;
			(sequence->data[i]->SofterHandoff) = 0;
			(sequence->data[i]->MACIndexLSBs) = 0;
			(sequence->data[i]->DRCCover) = 0;
			(sequence->data[i]->RABLength) = 0;
			(sequence->data[i]->RABOffset) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data01_data */
void FREE_c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data01_data (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data02'. Existing items are not changed. */
int SETITEMS_c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data02 (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data02* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data02_data** tmp;
		tmp = (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data02_data**)EDAlloc (sizeof (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data02_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data02_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data02_data*)EDAlloc (sizeof (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data02_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data02_data));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->RAChannelGain_Present) {
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data02_data */
void FREE_c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data02_data (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data02_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data03'. Existing items are not changed. */
int SETITEMS_c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data03 (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data03* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data03_data** tmp;
		tmp = (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data03_data**)EDAlloc (sizeof (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data03_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data03_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data03_data*)EDAlloc (sizeof (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data03_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data03_data));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->MACIndexMSB_Present) {
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data03_data */
void FREE_c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data03_data (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data03_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data04'. Existing items are not changed. */
int SETITEMS_c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data04 (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data04* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data04_data** tmp;
		tmp = (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data04_data**)EDAlloc (sizeof (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data04_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data04_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data04_data*)EDAlloc (sizeof (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data04_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data04_data));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->DSC_Present) {
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data04_data */
void FREE_c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data04_data (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data04_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data05'. Existing items are not changed. */
int SETITEMS_c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data05 (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data05* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data05_data** tmp;
		tmp = (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data05_data**)EDAlloc (sizeof (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data05_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data05_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data05_data*)EDAlloc (sizeof (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data05_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data05_data));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->DeltaT2P_Present) {
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data05_data */
void FREE_c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data05_data (c_CONN_DRUP_INUSE_TrafficChannelAssignment_contents_data05_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_DRUP_INUSE_NeighborList_contents_data01'. Existing items are not changed. */
int SETITEMS_c_CONN_DRUP_INUSE_NeighborList_contents_data01 (c_CONN_DRUP_INUSE_NeighborList_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_DRUP_INUSE_NeighborList_contents_data01_data** tmp;
		tmp = (c_CONN_DRUP_INUSE_NeighborList_contents_data01_data**)EDAlloc (sizeof (c_CONN_DRUP_INUSE_NeighborList_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_DRUP_INUSE_NeighborList_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_DRUP_INUSE_NeighborList_contents_data01_data*)EDAlloc (sizeof (c_CONN_DRUP_INUSE_NeighborList_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_DRUP_INUSE_NeighborList_contents_data01_data));
			(sequence->data[i]->PilotPN) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_DRUP_INUSE_NeighborList_contents_data01_data */
void FREE_c_CONN_DRUP_INUSE_NeighborList_contents_data01_data (c_CONN_DRUP_INUSE_NeighborList_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_DRUP_INUSE_NeighborList_contents_data02'. Existing items are not changed. */
int SETITEMS_c_CONN_DRUP_INUSE_NeighborList_contents_data02 (c_CONN_DRUP_INUSE_NeighborList_contents_data02* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_DRUP_INUSE_NeighborList_contents_data02_data** tmp;
		tmp = (c_CONN_DRUP_INUSE_NeighborList_contents_data02_data**)EDAlloc (sizeof (c_CONN_DRUP_INUSE_NeighborList_contents_data02_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_DRUP_INUSE_NeighborList_contents_data02_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_DRUP_INUSE_NeighborList_contents_data02_data*)EDAlloc (sizeof (c_CONN_DRUP_INUSE_NeighborList_contents_data02_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_DRUP_INUSE_NeighborList_contents_data02_data));
			(sequence->data[i]->ChannelIncluded) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->Channel_Present) {
					EDFree (sequence->data[i]->Channel);
					sequence->data[i]->Channel = NULL;
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_DRUP_INUSE_NeighborList_contents_data02_data */
void FREE_c_CONN_DRUP_INUSE_NeighborList_contents_data02_data (c_CONN_DRUP_INUSE_NeighborList_contents_data02_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->Channel_Present) {
		EDFree (sp->Channel);
		sp->Channel = NULL;
		sp->Channel_Present = ED_FALSE;
	}

}

void SETPRESENT_c_CONN_DRUP_INUSE_NeighborList_contents_data02_data_Channel (c_CONN_DRUP_INUSE_NeighborList_contents_data02_data* sp, ED_BOOLEAN present)
{
	/* Do nothing if already compliant to the request */
	if (sp->Channel_Present == present) return;
	sp->Channel_Present = present;
	if (present) {
		/*-->*/sp->Channel = (c_CONN_DRUP_INUSE_NeighborList_contents_data02_data_Channel*)EDAlloc (sizeof (c_CONN_DRUP_INUSE_NeighborList_contents_data02_data_Channel));
		ED_RESET_MEM (sp->Channel, sizeof (c_CONN_DRUP_INUSE_NeighborList_contents_data02_data_Channel));
		(sp->Channel->SystemType) = 0;
		(sp->Channel->BandClass) = 0;
		(sp->Channel->ChannelNumber) = 0;
	} else {
		EDFree (sp->Channel);
		sp->Channel = NULL;
	}
}

/* Free function for struct c_CONN_DRUP_INUSE_NeighborList_contents_data02_data_Channel */
void FREE_c_CONN_DRUP_INUSE_NeighborList_contents_data02_data_Channel (c_CONN_DRUP_INUSE_NeighborList_contents_data02_data_Channel* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_DRUP_INUSE_NeighborList_contents_data03'. Existing items are not changed. */
int SETITEMS_c_CONN_DRUP_INUSE_NeighborList_contents_data03 (c_CONN_DRUP_INUSE_NeighborList_contents_data03* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_DRUP_INUSE_NeighborList_contents_data03_data** tmp;
		tmp = (c_CONN_DRUP_INUSE_NeighborList_contents_data03_data**)EDAlloc (sizeof (c_CONN_DRUP_INUSE_NeighborList_contents_data03_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_DRUP_INUSE_NeighborList_contents_data03_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_DRUP_INUSE_NeighborList_contents_data03_data*)EDAlloc (sizeof (c_CONN_DRUP_INUSE_NeighborList_contents_data03_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_DRUP_INUSE_NeighborList_contents_data03_data));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->SearchWindowSize_Present) {
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_DRUP_INUSE_NeighborList_contents_data03_data */
void FREE_c_CONN_DRUP_INUSE_NeighborList_contents_data03_data (c_CONN_DRUP_INUSE_NeighborList_contents_data03_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_DRUP_INUSE_NeighborList_contents_data04'. Existing items are not changed. */
int SETITEMS_c_CONN_DRUP_INUSE_NeighborList_contents_data04 (c_CONN_DRUP_INUSE_NeighborList_contents_data04* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_DRUP_INUSE_NeighborList_contents_data04_data** tmp;
		tmp = (c_CONN_DRUP_INUSE_NeighborList_contents_data04_data**)EDAlloc (sizeof (c_CONN_DRUP_INUSE_NeighborList_contents_data04_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_DRUP_INUSE_NeighborList_contents_data04_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_DRUP_INUSE_NeighborList_contents_data04_data*)EDAlloc (sizeof (c_CONN_DRUP_INUSE_NeighborList_contents_data04_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_DRUP_INUSE_NeighborList_contents_data04_data));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->SearchWindowOffset_Present) {
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_DRUP_INUSE_NeighborList_contents_data04_data */
void FREE_c_CONN_DRUP_INUSE_NeighborList_contents_data04_data (c_CONN_DRUP_INUSE_NeighborList_contents_data04_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_DRUP_INUSE_NeighborList_contents_data05'. Existing items are not changed. */
int SETITEMS_c_CONN_DRUP_INUSE_NeighborList_contents_data05 (c_CONN_DRUP_INUSE_NeighborList_contents_data05* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_DRUP_INUSE_NeighborList_contents_data05_data** tmp;
		tmp = (c_CONN_DRUP_INUSE_NeighborList_contents_data05_data**)EDAlloc (sizeof (c_CONN_DRUP_INUSE_NeighborList_contents_data05_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_DRUP_INUSE_NeighborList_contents_data05_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_DRUP_INUSE_NeighborList_contents_data05_data*)EDAlloc (sizeof (c_CONN_DRUP_INUSE_NeighborList_contents_data05_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_DRUP_INUSE_NeighborList_contents_data05_data));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->FPDCHSupported_Present) {
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_DRUP_INUSE_NeighborList_contents_data05_data */
void FREE_c_CONN_DRUP_INUSE_NeighborList_contents_data05_data (c_CONN_DRUP_INUSE_NeighborList_contents_data05_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_DRUP_INUSE_AttributeOverride_contents_data01'. Existing items are not changed. */
int SETITEMS_c_CONN_DRUP_INUSE_AttributeOverride_contents_data01 (c_CONN_DRUP_INUSE_AttributeOverride_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_DRUP_INUSE_AttributeOverride_contents_data01_data** tmp;
		tmp = (c_CONN_DRUP_INUSE_AttributeOverride_contents_data01_data**)EDAlloc (sizeof (c_CONN_DRUP_INUSE_AttributeOverride_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_DRUP_INUSE_AttributeOverride_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_DRUP_INUSE_AttributeOverride_contents_data01_data*)EDAlloc (sizeof (c_CONN_DRUP_INUSE_AttributeOverride_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_DRUP_INUSE_AttributeOverride_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Default_Route_Update_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Default_Route_Update_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_DRUP_INUSE_AttributeOverride_contents_data01_data */
void FREE_c_CONN_DRUP_INUSE_AttributeOverride_contents_data01_data (c_CONN_DRUP_INUSE_AttributeOverride_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Default_Route_Update_Protocol_Attributes (&(sp->AttributeRecord));

}

/* Free function for struct c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_Channel */
void FREE_c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_Channel (c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_Channel* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data01 (c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data01_data** tmp;
		tmp = (c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data01_data**)EDAlloc (sizeof (c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data01_data*)EDAlloc (sizeof (c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data01_data));
			(sequence->data[i]->SectorPilotPN) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data01_data */
void FREE_c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data01_data (c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data02'. Existing items are not changed. */
int SETITEMS_c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data02 (c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data02* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data02_data** tmp;
		tmp = (c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data02_data**)EDAlloc (sizeof (c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data02_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data02_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data02_data*)EDAlloc (sizeof (c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data02_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data02_data));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->SectorSearchWindowSize_Present) {
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data02_data */
void FREE_c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data02_data (c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data02_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data03'. Existing items are not changed. */
int SETITEMS_c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data03 (c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data03* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data03_data** tmp;
		tmp = (c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data03_data**)EDAlloc (sizeof (c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data03_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data03_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data03_data*)EDAlloc (sizeof (c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data03_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data03_data));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->SectorSearchWindowOffset_Present) {
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data03_data */
void FREE_c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data03_data (c_CONN_DRUP_INUSE_RouteUpdateRequest_contents_data03_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_DRUP_INUSE_AttributeUpdateRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_CONN_DRUP_INUSE_AttributeUpdateRequest_contents_data01 (c_CONN_DRUP_INUSE_AttributeUpdateRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_DRUP_INUSE_AttributeUpdateRequest_contents_data01_data** tmp;
		tmp = (c_CONN_DRUP_INUSE_AttributeUpdateRequest_contents_data01_data**)EDAlloc (sizeof (c_CONN_DRUP_INUSE_AttributeUpdateRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_DRUP_INUSE_AttributeUpdateRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_DRUP_INUSE_AttributeUpdateRequest_contents_data01_data*)EDAlloc (sizeof (c_CONN_DRUP_INUSE_AttributeUpdateRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_DRUP_INUSE_AttributeUpdateRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Default_Route_Update_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Default_Route_Update_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_DRUP_INUSE_AttributeUpdateRequest_contents_data01_data */
void FREE_c_CONN_DRUP_INUSE_AttributeUpdateRequest_contents_data01_data (c_CONN_DRUP_INUSE_AttributeUpdateRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Default_Route_Update_Protocol_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_CONN_MRUP_INCFG_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_CONN_MRUP_INCFG_ConfigurationRequest_contents_data01 (c_CONN_MRUP_INCFG_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_MRUP_INCFG_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_CONN_MRUP_INCFG_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_CONN_MRUP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_MRUP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_MRUP_INCFG_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_CONN_MRUP_INCFG_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_MRUP_INCFG_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Multicarrier_Route_Update_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Multicarrier_Route_Update_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_MRUP_INCFG_ConfigurationRequest_contents_data01_data */
void FREE_c_CONN_MRUP_INCFG_ConfigurationRequest_contents_data01_data (c_CONN_MRUP_INCFG_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Multicarrier_Route_Update_Protocol_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_CONN_MRUP_INCFG_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_CONN_MRUP_INCFG_ConfigurationResponse_contents_data01 (c_CONN_MRUP_INCFG_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_MRUP_INCFG_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_CONN_MRUP_INCFG_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_CONN_MRUP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_MRUP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_MRUP_INCFG_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_CONN_MRUP_INCFG_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_MRUP_INCFG_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Multicarrier_Route_Update_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Multicarrier_Route_Update_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_MRUP_INCFG_ConfigurationResponse_contents_data01_data */
void FREE_c_CONN_MRUP_INCFG_ConfigurationResponse_contents_data01_data (c_CONN_MRUP_INCFG_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Multicarrier_Route_Update_Protocol_Attributes_Response (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_CONN_MRUP_INUSE_RouteUpdate_contents_data01'. Existing items are not changed. */
int SETITEMS_c_CONN_MRUP_INUSE_RouteUpdate_contents_data01 (c_CONN_MRUP_INUSE_RouteUpdate_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_MRUP_INUSE_RouteUpdate_contents_data01_data** tmp;
		tmp = (c_CONN_MRUP_INUSE_RouteUpdate_contents_data01_data**)EDAlloc (sizeof (c_CONN_MRUP_INUSE_RouteUpdate_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_MRUP_INUSE_RouteUpdate_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_MRUP_INUSE_RouteUpdate_contents_data01_data*)EDAlloc (sizeof (c_CONN_MRUP_INUSE_RouteUpdate_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_MRUP_INUSE_RouteUpdate_contents_data01_data));
			(sequence->data[i]->PilotPNPhase) = 0;
			(sequence->data[i]->ChannelIncluded) = 0;
			(sequence->data[i]->PilotStrength) = 0;
			(sequence->data[i]->Keep) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->Channel_Present) {
					EDFree (sequence->data[i]->Channel);
					sequence->data[i]->Channel = NULL;
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_MRUP_INUSE_RouteUpdate_contents_data01_data */
void FREE_c_CONN_MRUP_INUSE_RouteUpdate_contents_data01_data (c_CONN_MRUP_INUSE_RouteUpdate_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->Channel_Present) {
		EDFree (sp->Channel);
		sp->Channel = NULL;
		sp->Channel_Present = ED_FALSE;
	}

}

void SETPRESENT_c_CONN_MRUP_INUSE_RouteUpdate_contents_data01_data_Channel (c_CONN_MRUP_INUSE_RouteUpdate_contents_data01_data* sp, ED_BOOLEAN present)
{
	/* Do nothing if already compliant to the request */
	if (sp->Channel_Present == present) return;
	sp->Channel_Present = present;
	if (present) {
		/*-->*/sp->Channel = (c_CONN_MRUP_INUSE_RouteUpdate_contents_data01_data_Channel*)EDAlloc (sizeof (c_CONN_MRUP_INUSE_RouteUpdate_contents_data01_data_Channel));
		ED_RESET_MEM (sp->Channel, sizeof (c_CONN_MRUP_INUSE_RouteUpdate_contents_data01_data_Channel));
		(sp->Channel->SystemType) = 0;
		(sp->Channel->BandClass) = 0;
		(sp->Channel->ChannelNumber) = 0;
	} else {
		EDFree (sp->Channel);
		sp->Channel = NULL;
	}
}

/* Free function for struct c_CONN_MRUP_INUSE_RouteUpdate_contents_data01_data_Channel */
void FREE_c_CONN_MRUP_INUSE_RouteUpdate_contents_data01_data_Channel (c_CONN_MRUP_INUSE_RouteUpdate_contents_data01_data_Channel* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_CONN_MRUP_INUSE_RouteUpdate_contents_ReferencePilotChannel */
void FREE_c_CONN_MRUP_INUSE_RouteUpdate_contents_ReferencePilotChannel (c_CONN_MRUP_INUSE_RouteUpdate_contents_ReferencePilotChannel* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data01'. Existing items are not changed. */
int SETITEMS_c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data01 (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data01_data** tmp;
		tmp = (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data01_data**)EDAlloc (sizeof (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data01_data*)EDAlloc (sizeof (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data01_data));
			(sequence->data[i]->RAChannelGain) = 0;
			(sequence->data[i]->PilotPN) = 0;
			(sequence->data[i]->DRCCover) = 0;
			(sequence->data[i]->SofterHandoff) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data01_data */
void FREE_c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data01_data (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data02'. Existing items are not changed. */
int SETITEMS_c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data02 (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data02* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data02_data** tmp;
		tmp = (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data02_data**)EDAlloc (sizeof (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data02_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data02_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data02_data*)EDAlloc (sizeof (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data02_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data02_data));
			(sequence->data[i]->DSC) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data02_data */
void FREE_c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data02_data (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data02_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03'. Existing items are not changed. */
int SETITEMS_c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03 (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03* sequence, int desiredItems)
{
	int i, i0, i1;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data** tmp;
		tmp = (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data**)EDAlloc (sizeof (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data*)EDAlloc (sizeof (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data));
			sequence->data[i]->data04.items = 0;
			(sequence->data[i]->FeedbackEnabled) = 0;
			(sequence->data[i]->SubActiveSetCarriesControlChannel) = 0;
			(sequence->data[i]->ThisSubActiveSetNotReportable) = 0;
			(sequence->data[i]->NumReverseChannelsIncluded) = 0;
			sequence->data[i]->data05.items = 0;
			sequence->data[i]->data06.items = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->NumFwdChannelsThisSubActiveSet_Present) {
				}
				for (i0=0; i0<sequence->data[i]->data04.items; i0++) {
					if (sequence->data[i]->data04.data[i0]->AssignedChannel_Present) {
						EDFree (sequence->data[i]->data04.data[i0]->AssignedChannel);
						sequence->data[i]->data04.data[i0]->AssignedChannel = NULL;
					}
					EDFree (sequence->data[i]->data04.data[i0]);
					sequence->data[i]->data04.data[i0] = NULL;
				}
				if (sequence->data[i]->data04.data) {EDFree (sequence->data[i]->data04.data); sequence->data[i]->data04.data = NULL; sequence->data[i]->data04.allocatedItems=0; /*FR02A*/}
				if (sequence->data[i]->FeedbackMultiplexingIndex_Present) {
				}
				if (sequence->data[i]->FeedbackReverseChannelIndex_Present) {
				}
				if (sequence->data[i]->DSCForThisSubActiveSetEnabled_Present) {
				}
				if (sequence->data[i]->Next3FieldsSameAsBefore_Present) {
				}
				if (sequence->data[i]->DRCLength_Present) {
				}
				if (sequence->data[i]->DRCChannelGainBase_Present) {
				}
				if (sequence->data[i]->ACKChannelGain_Present) {
				}
				if (sequence->data[i]->NumReverseChannels_Present) {
				}
				for (i0=0; i0<sequence->data[i]->data05.items; i0++) {
					if (sequence->data[i]->data05.data[i0]->ReverseBandClass_Present) {
					}
					if (sequence->data[i]->data05.data[i0]->ReverseChannelNumber_Present) {
					}
					if (sequence->data[i]->data05.data[i0]->ReverseChannelDroppingRank_Present) {
					}
					EDFree (sequence->data[i]->data05.data[i0]);
					sequence->data[i]->data05.data[i0] = NULL;
				}
				if (sequence->data[i]->data05.data) {EDFree (sequence->data[i]->data05.data); sequence->data[i]->data05.data = NULL; sequence->data[i]->data05.allocatedItems=0; /*FR02A*/}
				for (i0=0; i0<sequence->data[i]->data06.items; i0++) {
					if (sequence->data[i]->data06.data[i0]->ForwardChannelIndexThisPilot_Present) {
					}
					if (sequence->data[i]->data06.data[i0]->PilotGroupID_Present) {
					}
					if (sequence->data[i]->data06.data[i0]->NumUniqueForwardTrafficMACIndices_Present) {
					}
					if (sequence->data[i]->data06.data[i0]->SchedulerTag_Present) {
					}
					if (sequence->data[i]->data06.data[i0]->AuxDRCCoverIncluded_Present) {
					}
					if (sequence->data[i]->data06.data[i0]->AuxDRCCover_Present) {
					}
					if (sequence->data[i]->data06.data[i0]->ForwardTrafficMACIndexPerInterlaceEnabled_Present) {
					}
					for (i1=0; i1<sequence->data[i]->data06.data[i0]->data07.items; i1++) {
						if (sequence->data[i]->data06.data[i0]->data07.data[i1]->ForwardTrafficMACIndex_Present) {
						}
						if (sequence->data[i]->data06.data[i0]->data07.data[i1]->AssignedInterlaces_Present) {
						}
						EDFree (sequence->data[i]->data06.data[i0]->data07.data[i1]);
						sequence->data[i]->data06.data[i0]->data07.data[i1] = NULL;
					}
					if (sequence->data[i]->data06.data[i0]->data07.data) {EDFree (sequence->data[i]->data06.data[i0]->data07.data); sequence->data[i]->data06.data[i0]->data07.data = NULL; sequence->data[i]->data06.data[i0]->data07.allocatedItems=0; /*FR02A*/}
					for (i1=0; i1<sequence->data[i]->data06.data[i0]->data08.items; i1++) {
						if (sequence->data[i]->data06.data[i0]->data08.data[i1]->ReverseLinkMACIndex_Present) {
						}
						if (sequence->data[i]->data06.data[i0]->data08.data[i1]->RABMACIndex_Present) {
						}
						if (sequence->data[i]->data06.data[i0]->data08.data[i1]->DeltaT2P_Present) {
						}
						EDFree (sequence->data[i]->data06.data[i0]->data08.data[i1]);
						sequence->data[i]->data06.data[i0]->data08.data[i1] = NULL;
					}
					if (sequence->data[i]->data06.data[i0]->data08.data) {EDFree (sequence->data[i]->data06.data[i0]->data08.data); sequence->data[i]->data06.data[i0]->data08.data = NULL; sequence->data[i]->data06.data[i0]->data08.allocatedItems=0; /*FR02A*/}
					EDFree (sequence->data[i]->data06.data[i0]);
					sequence->data[i]->data06.data[i0] = NULL;
				}
				if (sequence->data[i]->data06.data) {EDFree (sequence->data[i]->data06.data); sequence->data[i]->data06.data = NULL; sequence->data[i]->data06.allocatedItems=0; /*FR02A*/}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data */
void FREE_c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data* sp) {
	int i0;
	int i1;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data04.items; i0++) {
		if (sp->data04.data[i0]->AssignedChannel_Present) {
			EDFree (sp->data04.data[i0]->AssignedChannel);
			sp->data04.data[i0]->AssignedChannel = NULL;
		}
		EDFree (sp->data04.data[i0]);
		sp->data04.data[i0] = NULL;
	}
	if (sp->data04.data) {EDFree (sp->data04.data); sp->data04.data = NULL; sp->data04.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data05.items; i0++) {
		if (sp->data05.data[i0]->ReverseBandClass_Present) {
		}
		if (sp->data05.data[i0]->ReverseChannelNumber_Present) {
		}
		if (sp->data05.data[i0]->ReverseChannelDroppingRank_Present) {
		}
		EDFree (sp->data05.data[i0]);
		sp->data05.data[i0] = NULL;
	}
	if (sp->data05.data) {EDFree (sp->data05.data); sp->data05.data = NULL; sp->data05.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data06.items; i0++) {
		if (sp->data06.data[i0]->ForwardChannelIndexThisPilot_Present) {
		}
		if (sp->data06.data[i0]->PilotGroupID_Present) {
		}
		if (sp->data06.data[i0]->NumUniqueForwardTrafficMACIndices_Present) {
		}
		if (sp->data06.data[i0]->SchedulerTag_Present) {
		}
		if (sp->data06.data[i0]->AuxDRCCoverIncluded_Present) {
		}
		if (sp->data06.data[i0]->AuxDRCCover_Present) {
		}
		if (sp->data06.data[i0]->ForwardTrafficMACIndexPerInterlaceEnabled_Present) {
		}
		for (i1=0; i1<sp->data06.data[i0]->data07.items; i1++) {
			if (sp->data06.data[i0]->data07.data[i1]->ForwardTrafficMACIndex_Present) {
			}
			if (sp->data06.data[i0]->data07.data[i1]->AssignedInterlaces_Present) {
			}
			EDFree (sp->data06.data[i0]->data07.data[i1]);
			sp->data06.data[i0]->data07.data[i1] = NULL;
		}
		if (sp->data06.data[i0]->data07.data) {EDFree (sp->data06.data[i0]->data07.data); sp->data06.data[i0]->data07.data = NULL; sp->data06.data[i0]->data07.allocatedItems=0; /*FR02A*/}
		for (i1=0; i1<sp->data06.data[i0]->data08.items; i1++) {
			if (sp->data06.data[i0]->data08.data[i1]->ReverseLinkMACIndex_Present) {
			}
			if (sp->data06.data[i0]->data08.data[i1]->RABMACIndex_Present) {
			}
			if (sp->data06.data[i0]->data08.data[i1]->DeltaT2P_Present) {
			}
			EDFree (sp->data06.data[i0]->data08.data[i1]);
			sp->data06.data[i0]->data08.data[i1] = NULL;
		}
		if (sp->data06.data[i0]->data08.data) {EDFree (sp->data06.data[i0]->data08.data); sp->data06.data[i0]->data08.data = NULL; sp->data06.data[i0]->data08.allocatedItems=0; /*FR02A*/}
		EDFree (sp->data06.data[i0]);
		sp->data06.data[i0] = NULL;
	}
	if (sp->data06.data) {EDFree (sp->data06.data); sp->data06.data = NULL; sp->data06.allocatedItems=0; /*FR02A*/}

}

/* SETITEMS commands for type 'c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data04'. Existing items are not changed. */
int SETITEMS_c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data04 (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data04* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data04_data** tmp;
		tmp = (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data04_data**)EDAlloc (sizeof (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data04_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data04_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data04_data*)EDAlloc (sizeof (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data04_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data04_data));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->AssignedChannel_Present) {
					EDFree (sequence->data[i]->AssignedChannel);
					sequence->data[i]->AssignedChannel = NULL;
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data04_data */
void FREE_c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data04_data (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data04_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AssignedChannel_Present) {
		EDFree (sp->AssignedChannel);
		sp->AssignedChannel = NULL;
		sp->AssignedChannel_Present = ED_FALSE;
	}

}

void SETPRESENT_c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data04_data_AssignedChannel (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data04_data* sp, ED_BOOLEAN present)
{
	/* Do nothing if already compliant to the request */
	if (sp->AssignedChannel_Present == present) return;
	sp->AssignedChannel_Present = present;
	if (present) {
		/*-->*/sp->AssignedChannel = (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data04_data_AssignedChannel*)EDAlloc (sizeof (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data04_data_AssignedChannel));
		ED_RESET_MEM (sp->AssignedChannel, sizeof (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data04_data_AssignedChannel));
		(sp->AssignedChannel->SystemType) = 0;
		(sp->AssignedChannel->BandClass) = 0;
		(sp->AssignedChannel->ChannelNumber) = 0;
	} else {
		EDFree (sp->AssignedChannel);
		sp->AssignedChannel = NULL;
	}
}

/* Free function for struct c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data04_data_AssignedChannel */
void FREE_c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data04_data_AssignedChannel (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data04_data_AssignedChannel* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data05'. Existing items are not changed. */
int SETITEMS_c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data05 (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data05* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data05_data** tmp;
		tmp = (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data05_data**)EDAlloc (sizeof (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data05_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data05_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data05_data*)EDAlloc (sizeof (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data05_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data05_data));
			(sequence->data[i]->ReverseChannelConfiguration) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->ReverseBandClass_Present) {
				}
				if (sequence->data[i]->ReverseChannelNumber_Present) {
				}
				if (sequence->data[i]->ReverseChannelDroppingRank_Present) {
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data05_data */
void FREE_c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data05_data (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data05_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06'. Existing items are not changed. */
int SETITEMS_c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06 (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06* sequence, int desiredItems)
{
	int i, i0;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data** tmp;
		tmp = (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data**)EDAlloc (sizeof (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data*)EDAlloc (sizeof (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data));
			(sequence->data[i]->PilotInThisSectorIncluded) = 0;
			sequence->data[i]->data07.items = 0;
			sequence->data[i]->data08.items = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->ForwardChannelIndexThisPilot_Present) {
				}
				if (sequence->data[i]->PilotGroupID_Present) {
				}
				if (sequence->data[i]->NumUniqueForwardTrafficMACIndices_Present) {
				}
				if (sequence->data[i]->SchedulerTag_Present) {
				}
				if (sequence->data[i]->AuxDRCCoverIncluded_Present) {
				}
				if (sequence->data[i]->AuxDRCCover_Present) {
				}
				if (sequence->data[i]->ForwardTrafficMACIndexPerInterlaceEnabled_Present) {
				}
				for (i0=0; i0<sequence->data[i]->data07.items; i0++) {
					if (sequence->data[i]->data07.data[i0]->ForwardTrafficMACIndex_Present) {
					}
					if (sequence->data[i]->data07.data[i0]->AssignedInterlaces_Present) {
					}
					EDFree (sequence->data[i]->data07.data[i0]);
					sequence->data[i]->data07.data[i0] = NULL;
				}
				if (sequence->data[i]->data07.data) {EDFree (sequence->data[i]->data07.data); sequence->data[i]->data07.data = NULL; sequence->data[i]->data07.allocatedItems=0; /*FR02A*/}
				for (i0=0; i0<sequence->data[i]->data08.items; i0++) {
					if (sequence->data[i]->data08.data[i0]->ReverseLinkMACIndex_Present) {
					}
					if (sequence->data[i]->data08.data[i0]->RABMACIndex_Present) {
					}
					if (sequence->data[i]->data08.data[i0]->DeltaT2P_Present) {
					}
					EDFree (sequence->data[i]->data08.data[i0]);
					sequence->data[i]->data08.data[i0] = NULL;
				}
				if (sequence->data[i]->data08.data) {EDFree (sequence->data[i]->data08.data); sequence->data[i]->data08.data = NULL; sequence->data[i]->data08.allocatedItems=0; /*FR02A*/}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data */
void FREE_c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data* sp) {
	int i0;
ED_WARNING_REMOVER(sp);
	for (i0=0; i0<sp->data07.items; i0++) {
		if (sp->data07.data[i0]->ForwardTrafficMACIndex_Present) {
		}
		if (sp->data07.data[i0]->AssignedInterlaces_Present) {
		}
		EDFree (sp->data07.data[i0]);
		sp->data07.data[i0] = NULL;
	}
	if (sp->data07.data) {EDFree (sp->data07.data); sp->data07.data = NULL; sp->data07.allocatedItems=0; /*FR02A*/}
	for (i0=0; i0<sp->data08.items; i0++) {
		if (sp->data08.data[i0]->ReverseLinkMACIndex_Present) {
		}
		if (sp->data08.data[i0]->RABMACIndex_Present) {
		}
		if (sp->data08.data[i0]->DeltaT2P_Present) {
		}
		EDFree (sp->data08.data[i0]);
		sp->data08.data[i0] = NULL;
	}
	if (sp->data08.data) {EDFree (sp->data08.data); sp->data08.data = NULL; sp->data08.allocatedItems=0; /*FR02A*/}

}

/* SETITEMS commands for type 'c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data_data07'. Existing items are not changed. */
int SETITEMS_c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data_data07 (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data_data07* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data_data07_data** tmp;
		tmp = (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data_data07_data**)EDAlloc (sizeof (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data_data07_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data_data07_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data_data07_data*)EDAlloc (sizeof (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data_data07_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data_data07_data));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->ForwardTrafficMACIndex_Present) {
				}
				if (sequence->data[i]->AssignedInterlaces_Present) {
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data_data07_data */
void FREE_c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data_data07_data (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data_data07_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data_data08'. Existing items are not changed. */
int SETITEMS_c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data_data08 (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data_data08* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data_data08_data** tmp;
		tmp = (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data_data08_data**)EDAlloc (sizeof (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data_data08_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data_data08_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data_data08_data*)EDAlloc (sizeof (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data_data08_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data_data08_data));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->ReverseLinkMACIndex_Present) {
				}
				if (sequence->data[i]->RABMACIndex_Present) {
				}
				if (sequence->data[i]->DeltaT2P_Present) {
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data_data08_data */
void FREE_c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data_data08_data (c_CONN_MRUP_INUSE_TrafficChannelAssignment_contents_data03_data_data06_data_data08_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_MRUP_INUSE_NeighborList_contents_data01'. Existing items are not changed. */
int SETITEMS_c_CONN_MRUP_INUSE_NeighborList_contents_data01 (c_CONN_MRUP_INUSE_NeighborList_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_MRUP_INUSE_NeighborList_contents_data01_data** tmp;
		tmp = (c_CONN_MRUP_INUSE_NeighborList_contents_data01_data**)EDAlloc (sizeof (c_CONN_MRUP_INUSE_NeighborList_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_MRUP_INUSE_NeighborList_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_MRUP_INUSE_NeighborList_contents_data01_data*)EDAlloc (sizeof (c_CONN_MRUP_INUSE_NeighborList_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_MRUP_INUSE_NeighborList_contents_data01_data));
			(sequence->data[i]->PilotPN) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_MRUP_INUSE_NeighborList_contents_data01_data */
void FREE_c_CONN_MRUP_INUSE_NeighborList_contents_data01_data (c_CONN_MRUP_INUSE_NeighborList_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_MRUP_INUSE_NeighborList_contents_data02'. Existing items are not changed. */
int SETITEMS_c_CONN_MRUP_INUSE_NeighborList_contents_data02 (c_CONN_MRUP_INUSE_NeighborList_contents_data02* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_MRUP_INUSE_NeighborList_contents_data02_data** tmp;
		tmp = (c_CONN_MRUP_INUSE_NeighborList_contents_data02_data**)EDAlloc (sizeof (c_CONN_MRUP_INUSE_NeighborList_contents_data02_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_MRUP_INUSE_NeighborList_contents_data02_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_MRUP_INUSE_NeighborList_contents_data02_data*)EDAlloc (sizeof (c_CONN_MRUP_INUSE_NeighborList_contents_data02_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_MRUP_INUSE_NeighborList_contents_data02_data));
			(sequence->data[i]->ChannelIncluded) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->Channel_Present) {
					EDFree (sequence->data[i]->Channel);
					sequence->data[i]->Channel = NULL;
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_MRUP_INUSE_NeighborList_contents_data02_data */
void FREE_c_CONN_MRUP_INUSE_NeighborList_contents_data02_data (c_CONN_MRUP_INUSE_NeighborList_contents_data02_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->Channel_Present) {
		EDFree (sp->Channel);
		sp->Channel = NULL;
		sp->Channel_Present = ED_FALSE;
	}

}

void SETPRESENT_c_CONN_MRUP_INUSE_NeighborList_contents_data02_data_Channel (c_CONN_MRUP_INUSE_NeighborList_contents_data02_data* sp, ED_BOOLEAN present)
{
	/* Do nothing if already compliant to the request */
	if (sp->Channel_Present == present) return;
	sp->Channel_Present = present;
	if (present) {
		/*-->*/sp->Channel = (c_CONN_MRUP_INUSE_NeighborList_contents_data02_data_Channel*)EDAlloc (sizeof (c_CONN_MRUP_INUSE_NeighborList_contents_data02_data_Channel));
		ED_RESET_MEM (sp->Channel, sizeof (c_CONN_MRUP_INUSE_NeighborList_contents_data02_data_Channel));
		(sp->Channel->SystemType) = 0;
		(sp->Channel->BandClass) = 0;
		(sp->Channel->ChannelNumber) = 0;
	} else {
		EDFree (sp->Channel);
		sp->Channel = NULL;
	}
}

/* Free function for struct c_CONN_MRUP_INUSE_NeighborList_contents_data02_data_Channel */
void FREE_c_CONN_MRUP_INUSE_NeighborList_contents_data02_data_Channel (c_CONN_MRUP_INUSE_NeighborList_contents_data02_data_Channel* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_MRUP_INUSE_NeighborList_contents_data03'. Existing items are not changed. */
int SETITEMS_c_CONN_MRUP_INUSE_NeighborList_contents_data03 (c_CONN_MRUP_INUSE_NeighborList_contents_data03* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_MRUP_INUSE_NeighborList_contents_data03_data** tmp;
		tmp = (c_CONN_MRUP_INUSE_NeighborList_contents_data03_data**)EDAlloc (sizeof (c_CONN_MRUP_INUSE_NeighborList_contents_data03_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_MRUP_INUSE_NeighborList_contents_data03_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_MRUP_INUSE_NeighborList_contents_data03_data*)EDAlloc (sizeof (c_CONN_MRUP_INUSE_NeighborList_contents_data03_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_MRUP_INUSE_NeighborList_contents_data03_data));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->SearchWindowSize_Present) {
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_MRUP_INUSE_NeighborList_contents_data03_data */
void FREE_c_CONN_MRUP_INUSE_NeighborList_contents_data03_data (c_CONN_MRUP_INUSE_NeighborList_contents_data03_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_MRUP_INUSE_NeighborList_contents_data04'. Existing items are not changed. */
int SETITEMS_c_CONN_MRUP_INUSE_NeighborList_contents_data04 (c_CONN_MRUP_INUSE_NeighborList_contents_data04* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_MRUP_INUSE_NeighborList_contents_data04_data** tmp;
		tmp = (c_CONN_MRUP_INUSE_NeighborList_contents_data04_data**)EDAlloc (sizeof (c_CONN_MRUP_INUSE_NeighborList_contents_data04_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_MRUP_INUSE_NeighborList_contents_data04_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_MRUP_INUSE_NeighborList_contents_data04_data*)EDAlloc (sizeof (c_CONN_MRUP_INUSE_NeighborList_contents_data04_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_MRUP_INUSE_NeighborList_contents_data04_data));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->SearchWindowOffset_Present) {
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_MRUP_INUSE_NeighborList_contents_data04_data */
void FREE_c_CONN_MRUP_INUSE_NeighborList_contents_data04_data (c_CONN_MRUP_INUSE_NeighborList_contents_data04_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_MRUP_INUSE_NeighborList_contents_data05'. Existing items are not changed. */
int SETITEMS_c_CONN_MRUP_INUSE_NeighborList_contents_data05 (c_CONN_MRUP_INUSE_NeighborList_contents_data05* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_MRUP_INUSE_NeighborList_contents_data05_data** tmp;
		tmp = (c_CONN_MRUP_INUSE_NeighborList_contents_data05_data**)EDAlloc (sizeof (c_CONN_MRUP_INUSE_NeighborList_contents_data05_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_MRUP_INUSE_NeighborList_contents_data05_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_MRUP_INUSE_NeighborList_contents_data05_data*)EDAlloc (sizeof (c_CONN_MRUP_INUSE_NeighborList_contents_data05_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_MRUP_INUSE_NeighborList_contents_data05_data));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->FPDCHSupported_Present) {
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_MRUP_INUSE_NeighborList_contents_data05_data */
void FREE_c_CONN_MRUP_INUSE_NeighborList_contents_data05_data (c_CONN_MRUP_INUSE_NeighborList_contents_data05_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_MRUP_INUSE_NeighborList_contents_data06'. Existing items are not changed. */
int SETITEMS_c_CONN_MRUP_INUSE_NeighborList_contents_data06 (c_CONN_MRUP_INUSE_NeighborList_contents_data06* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_MRUP_INUSE_NeighborList_contents_data06_data** tmp;
		tmp = (c_CONN_MRUP_INUSE_NeighborList_contents_data06_data**)EDAlloc (sizeof (c_CONN_MRUP_INUSE_NeighborList_contents_data06_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_MRUP_INUSE_NeighborList_contents_data06_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_MRUP_INUSE_NeighborList_contents_data06_data*)EDAlloc (sizeof (c_CONN_MRUP_INUSE_NeighborList_contents_data06_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_MRUP_INUSE_NeighborList_contents_data06_data));
			(sequence->data[i]->PilotGroupIDIncluded) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->PilotGroupID_Present) {
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_MRUP_INUSE_NeighborList_contents_data06_data */
void FREE_c_CONN_MRUP_INUSE_NeighborList_contents_data06_data (c_CONN_MRUP_INUSE_NeighborList_contents_data06_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_Channel */
void FREE_c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_Channel (c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_Channel* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data01 (c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data01_data** tmp;
		tmp = (c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data01_data**)EDAlloc (sizeof (c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data01_data*)EDAlloc (sizeof (c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data01_data));
			(sequence->data[i]->SectorPilotPN) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data01_data */
void FREE_c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data01_data (c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data02'. Existing items are not changed. */
int SETITEMS_c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data02 (c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data02* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data02_data** tmp;
		tmp = (c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data02_data**)EDAlloc (sizeof (c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data02_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data02_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data02_data*)EDAlloc (sizeof (c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data02_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data02_data));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->SectorSearchWindowSize_Present) {
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data02_data */
void FREE_c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data02_data (c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data02_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data03'. Existing items are not changed. */
int SETITEMS_c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data03 (c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data03* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data03_data** tmp;
		tmp = (c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data03_data**)EDAlloc (sizeof (c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data03_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data03_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data03_data*)EDAlloc (sizeof (c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data03_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data03_data));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->SectorSearchWindowOffset_Present) {
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data03_data */
void FREE_c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data03_data (c_CONN_MRUP_INUSE_RouteUpdateRequest_contents_data03_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_MRUP_INUSE_AttributeUpdateRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_CONN_MRUP_INUSE_AttributeUpdateRequest_contents_data01 (c_CONN_MRUP_INUSE_AttributeUpdateRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_MRUP_INUSE_AttributeUpdateRequest_contents_data01_data** tmp;
		tmp = (c_CONN_MRUP_INUSE_AttributeUpdateRequest_contents_data01_data**)EDAlloc (sizeof (c_CONN_MRUP_INUSE_AttributeUpdateRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_MRUP_INUSE_AttributeUpdateRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_MRUP_INUSE_AttributeUpdateRequest_contents_data01_data*)EDAlloc (sizeof (c_CONN_MRUP_INUSE_AttributeUpdateRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_MRUP_INUSE_AttributeUpdateRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Multicarrier_Route_Update_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Multicarrier_Route_Update_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_MRUP_INUSE_AttributeUpdateRequest_contents_data01_data */
void FREE_c_CONN_MRUP_INUSE_AttributeUpdateRequest_contents_data01_data (c_CONN_MRUP_INUSE_AttributeUpdateRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Multicarrier_Route_Update_Protocol_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_CONN_DPCP_INCFG_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_CONN_DPCP_INCFG_ConfigurationRequest_contents_data01 (c_CONN_DPCP_INCFG_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_DPCP_INCFG_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_CONN_DPCP_INCFG_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_CONN_DPCP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_DPCP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_DPCP_INCFG_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_CONN_DPCP_INCFG_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_DPCP_INCFG_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeRecord.Length) = 0;
			(sequence->data[i]->AttributeRecord.AttributeID) = 0;
			sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
			sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
			
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->AttributeRecord.AttributeValue.value != NULL) {
					EDFree (sequence->data[i]->AttributeRecord.AttributeValue.value);
					sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
				}
				sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_DPCP_INCFG_ConfigurationRequest_contents_data01_data */
void FREE_c_CONN_DPCP_INCFG_ConfigurationRequest_contents_data01_data (c_CONN_DPCP_INCFG_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeRecord.AttributeValue.value != NULL) {
		EDFree (sp->AttributeRecord.AttributeValue.value);
		sp->AttributeRecord.AttributeValue.value = NULL;
	}
	sp->AttributeRecord.AttributeValue.usedBits = 0;

}

/* Free function for struct c_CONN_DPCP_INCFG_ConfigurationRequest_contents_data01_data_AttributeRecord */
void FREE_c_CONN_DPCP_INCFG_ConfigurationRequest_contents_data01_data_AttributeRecord (c_CONN_DPCP_INCFG_ConfigurationRequest_contents_data01_data_AttributeRecord* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeValue.value != NULL) {
		EDFree (sp->AttributeValue.value);
		sp->AttributeValue.value = NULL;
	}
	sp->AttributeValue.usedBits = 0;

}

/* SETITEMS commands for type 'c_CONN_DPCP_INCFG_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_CONN_DPCP_INCFG_ConfigurationResponse_contents_data01 (c_CONN_DPCP_INCFG_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_DPCP_INCFG_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_CONN_DPCP_INCFG_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_CONN_DPCP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_DPCP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_DPCP_INCFG_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_CONN_DPCP_INCFG_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_DPCP_INCFG_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeRecord.Length) = 0;
			(sequence->data[i]->AttributeRecord.AttributeID) = 0;
			sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
			sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
			
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->AttributeRecord.AttributeValue.value != NULL) {
					EDFree (sequence->data[i]->AttributeRecord.AttributeValue.value);
					sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
				}
				sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_DPCP_INCFG_ConfigurationResponse_contents_data01_data */
void FREE_c_CONN_DPCP_INCFG_ConfigurationResponse_contents_data01_data (c_CONN_DPCP_INCFG_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeRecord.AttributeValue.value != NULL) {
		EDFree (sp->AttributeRecord.AttributeValue.value);
		sp->AttributeRecord.AttributeValue.value = NULL;
	}
	sp->AttributeRecord.AttributeValue.usedBits = 0;

}

/* Free function for struct c_CONN_DPCP_INCFG_ConfigurationResponse_contents_data01_data_AttributeRecord */
void FREE_c_CONN_DPCP_INCFG_ConfigurationResponse_contents_data01_data_AttributeRecord (c_CONN_DPCP_INCFG_ConfigurationResponse_contents_data01_data_AttributeRecord* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeValue.value != NULL) {
		EDFree (sp->AttributeValue.value);
		sp->AttributeValue.value = NULL;
	}
	sp->AttributeValue.usedBits = 0;

}

/* SETITEMS commands for type 'c_CONN_OMP_INCFG_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_CONN_OMP_INCFG_ConfigurationRequest_contents_data01 (c_CONN_OMP_INCFG_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_OMP_INCFG_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_CONN_OMP_INCFG_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_CONN_OMP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_OMP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_OMP_INCFG_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_CONN_OMP_INCFG_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_OMP_INCFG_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Overhead_Messages_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Overhead_Messages_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_OMP_INCFG_ConfigurationRequest_contents_data01_data */
void FREE_c_CONN_OMP_INCFG_ConfigurationRequest_contents_data01_data (c_CONN_OMP_INCFG_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Overhead_Messages_Protocol_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_CONN_OMP_INCFG_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_CONN_OMP_INCFG_ConfigurationResponse_contents_data01 (c_CONN_OMP_INCFG_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_OMP_INCFG_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_CONN_OMP_INCFG_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_CONN_OMP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_OMP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_OMP_INCFG_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_CONN_OMP_INCFG_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_OMP_INCFG_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Overhead_Messages_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Overhead_Messages_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_OMP_INCFG_ConfigurationResponse_contents_data01_data */
void FREE_c_CONN_OMP_INCFG_ConfigurationResponse_contents_data01_data (c_CONN_OMP_INCFG_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Overhead_Messages_Protocol_Attributes_Response (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_CONN_OMP_INUSE_QuickConfig_contents_data01'. Existing items are not changed. */
int SETITEMS_c_CONN_OMP_INUSE_QuickConfig_contents_data01 (c_CONN_OMP_INUSE_QuickConfig_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_OMP_INUSE_QuickConfig_contents_data01_data** tmp;
		tmp = (c_CONN_OMP_INUSE_QuickConfig_contents_data01_data**)EDAlloc (sizeof (c_CONN_OMP_INUSE_QuickConfig_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_OMP_INUSE_QuickConfig_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_OMP_INUSE_QuickConfig_contents_data01_data*)EDAlloc (sizeof (c_CONN_OMP_INUSE_QuickConfig_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_OMP_INUSE_QuickConfig_contents_data01_data));
			(sequence->data[i]->ForwardTrafficValid63To0) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_OMP_INUSE_QuickConfig_contents_data01_data */
void FREE_c_CONN_OMP_INUSE_QuickConfig_contents_data01_data (c_CONN_OMP_INUSE_QuickConfig_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_OMP_INUSE_QuickConfig_contents_data02'. Existing items are not changed. */
int SETITEMS_c_CONN_OMP_INUSE_QuickConfig_contents_data02 (c_CONN_OMP_INUSE_QuickConfig_contents_data02* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_OMP_INUSE_QuickConfig_contents_data02_data** tmp;
		tmp = (c_CONN_OMP_INUSE_QuickConfig_contents_data02_data**)EDAlloc (sizeof (c_CONN_OMP_INUSE_QuickConfig_contents_data02_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_OMP_INUSE_QuickConfig_contents_data02_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_OMP_INUSE_QuickConfig_contents_data02_data*)EDAlloc (sizeof (c_CONN_OMP_INUSE_QuickConfig_contents_data02_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_OMP_INUSE_QuickConfig_contents_data02_data));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->ForwardTrafficValid127To64_Present) {
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_OMP_INUSE_QuickConfig_contents_data02_data */
void FREE_c_CONN_OMP_INUSE_QuickConfig_contents_data02_data (c_CONN_OMP_INUSE_QuickConfig_contents_data02_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_OMP_INUSE_QuickConfig_contents_data03'. Existing items are not changed. */
int SETITEMS_c_CONN_OMP_INUSE_QuickConfig_contents_data03 (c_CONN_OMP_INUSE_QuickConfig_contents_data03* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_OMP_INUSE_QuickConfig_contents_data03_data** tmp;
		tmp = (c_CONN_OMP_INUSE_QuickConfig_contents_data03_data**)EDAlloc (sizeof (c_CONN_OMP_INUSE_QuickConfig_contents_data03_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_OMP_INUSE_QuickConfig_contents_data03_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_OMP_INUSE_QuickConfig_contents_data03_data*)EDAlloc (sizeof (c_CONN_OMP_INUSE_QuickConfig_contents_data03_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_OMP_INUSE_QuickConfig_contents_data03_data));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->ForwardTrafficValid130To383_Present) {
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_OMP_INUSE_QuickConfig_contents_data03_data */
void FREE_c_CONN_OMP_INUSE_QuickConfig_contents_data03_data (c_CONN_OMP_INUSE_QuickConfig_contents_data03_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_OMP_INUSE_SectorParameters_contents_data01'. Existing items are not changed. */
int SETITEMS_c_CONN_OMP_INUSE_SectorParameters_contents_data01 (c_CONN_OMP_INUSE_SectorParameters_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_OMP_INUSE_SectorParameters_contents_data01_data** tmp;
		tmp = (c_CONN_OMP_INUSE_SectorParameters_contents_data01_data**)EDAlloc (sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_OMP_INUSE_SectorParameters_contents_data01_data*)EDAlloc (sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data01_data));
			(sequence->data[i]->Channel.SystemType) = 0;
			(sequence->data[i]->Channel.BandClass) = 0;
			(sequence->data[i]->Channel.ChannelNumber) = 0;
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_OMP_INUSE_SectorParameters_contents_data01_data */
void FREE_c_CONN_OMP_INUSE_SectorParameters_contents_data01_data (c_CONN_OMP_INUSE_SectorParameters_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_CONN_OMP_INUSE_SectorParameters_contents_data01_data_Channel */
void FREE_c_CONN_OMP_INUSE_SectorParameters_contents_data01_data_Channel (c_CONN_OMP_INUSE_SectorParameters_contents_data01_data_Channel* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_OMP_INUSE_SectorParameters_contents_data02'. Existing items are not changed. */
int SETITEMS_c_CONN_OMP_INUSE_SectorParameters_contents_data02 (c_CONN_OMP_INUSE_SectorParameters_contents_data02* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_OMP_INUSE_SectorParameters_contents_data02_data** tmp;
		tmp = (c_CONN_OMP_INUSE_SectorParameters_contents_data02_data**)EDAlloc (sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data02_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data02_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_OMP_INUSE_SectorParameters_contents_data02_data*)EDAlloc (sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data02_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data02_data));
			(sequence->data[i]->NeighborPilotPN) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_OMP_INUSE_SectorParameters_contents_data02_data */
void FREE_c_CONN_OMP_INUSE_SectorParameters_contents_data02_data (c_CONN_OMP_INUSE_SectorParameters_contents_data02_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_OMP_INUSE_SectorParameters_contents_data03'. Existing items are not changed. */
int SETITEMS_c_CONN_OMP_INUSE_SectorParameters_contents_data03 (c_CONN_OMP_INUSE_SectorParameters_contents_data03* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_OMP_INUSE_SectorParameters_contents_data03_data** tmp;
		tmp = (c_CONN_OMP_INUSE_SectorParameters_contents_data03_data**)EDAlloc (sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data03_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data03_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_OMP_INUSE_SectorParameters_contents_data03_data*)EDAlloc (sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data03_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data03_data));
			(sequence->data[i]->NeighborChannelIncluded) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->NeighborChannel_Present) {
					EDFree (sequence->data[i]->NeighborChannel);
					sequence->data[i]->NeighborChannel = NULL;
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_OMP_INUSE_SectorParameters_contents_data03_data */
void FREE_c_CONN_OMP_INUSE_SectorParameters_contents_data03_data (c_CONN_OMP_INUSE_SectorParameters_contents_data03_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->NeighborChannel_Present) {
		EDFree (sp->NeighborChannel);
		sp->NeighborChannel = NULL;
		sp->NeighborChannel_Present = ED_FALSE;
	}

}

void SETPRESENT_c_CONN_OMP_INUSE_SectorParameters_contents_data03_data_NeighborChannel (c_CONN_OMP_INUSE_SectorParameters_contents_data03_data* sp, ED_BOOLEAN present)
{
	/* Do nothing if already compliant to the request */
	if (sp->NeighborChannel_Present == present) return;
	sp->NeighborChannel_Present = present;
	if (present) {
		/*-->*/sp->NeighborChannel = (c_CONN_OMP_INUSE_SectorParameters_contents_data03_data_NeighborChannel*)EDAlloc (sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data03_data_NeighborChannel));
		ED_RESET_MEM (sp->NeighborChannel, sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data03_data_NeighborChannel));
		(sp->NeighborChannel->SystemType) = 0;
		(sp->NeighborChannel->BandClass) = 0;
		(sp->NeighborChannel->ChannelNumber) = 0;
	} else {
		EDFree (sp->NeighborChannel);
		sp->NeighborChannel = NULL;
	}
}

/* Free function for struct c_CONN_OMP_INUSE_SectorParameters_contents_data03_data_NeighborChannel */
void FREE_c_CONN_OMP_INUSE_SectorParameters_contents_data03_data_NeighborChannel (c_CONN_OMP_INUSE_SectorParameters_contents_data03_data_NeighborChannel* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_OMP_INUSE_SectorParameters_contents_data04'. Existing items are not changed. */
int SETITEMS_c_CONN_OMP_INUSE_SectorParameters_contents_data04 (c_CONN_OMP_INUSE_SectorParameters_contents_data04* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_OMP_INUSE_SectorParameters_contents_data04_data** tmp;
		tmp = (c_CONN_OMP_INUSE_SectorParameters_contents_data04_data**)EDAlloc (sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data04_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data04_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_OMP_INUSE_SectorParameters_contents_data04_data*)EDAlloc (sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data04_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data04_data));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->NeighborSearchWindowSize_Present) {
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_OMP_INUSE_SectorParameters_contents_data04_data */
void FREE_c_CONN_OMP_INUSE_SectorParameters_contents_data04_data (c_CONN_OMP_INUSE_SectorParameters_contents_data04_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_OMP_INUSE_SectorParameters_contents_data05'. Existing items are not changed. */
int SETITEMS_c_CONN_OMP_INUSE_SectorParameters_contents_data05 (c_CONN_OMP_INUSE_SectorParameters_contents_data05* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_OMP_INUSE_SectorParameters_contents_data05_data** tmp;
		tmp = (c_CONN_OMP_INUSE_SectorParameters_contents_data05_data**)EDAlloc (sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data05_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data05_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_OMP_INUSE_SectorParameters_contents_data05_data*)EDAlloc (sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data05_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data05_data));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->NeighborSearchWindowOffset_Present) {
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_OMP_INUSE_SectorParameters_contents_data05_data */
void FREE_c_CONN_OMP_INUSE_SectorParameters_contents_data05_data (c_CONN_OMP_INUSE_SectorParameters_contents_data05_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_OMP_INUSE_SectorParameters_contents_data06'. Existing items are not changed. */
int SETITEMS_c_CONN_OMP_INUSE_SectorParameters_contents_data06 (c_CONN_OMP_INUSE_SectorParameters_contents_data06* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_OMP_INUSE_SectorParameters_contents_data06_data** tmp;
		tmp = (c_CONN_OMP_INUSE_SectorParameters_contents_data06_data**)EDAlloc (sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data06_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data06_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_OMP_INUSE_SectorParameters_contents_data06_data*)EDAlloc (sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data06_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data06_data));
			(sequence->data[i]->ExtendedChannel.SystemType) = 0;
			(sequence->data[i]->ExtendedChannel.BandClass) = 0;
			(sequence->data[i]->ExtendedChannel.ChannelNumber) = 0;
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_OMP_INUSE_SectorParameters_contents_data06_data */
void FREE_c_CONN_OMP_INUSE_SectorParameters_contents_data06_data (c_CONN_OMP_INUSE_SectorParameters_contents_data06_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_CONN_OMP_INUSE_SectorParameters_contents_data06_data_ExtendedChannel */
void FREE_c_CONN_OMP_INUSE_SectorParameters_contents_data06_data_ExtendedChannel (c_CONN_OMP_INUSE_SectorParameters_contents_data06_data_ExtendedChannel* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_OMP_INUSE_SectorParameters_contents_data07'. Existing items are not changed. */
int SETITEMS_c_CONN_OMP_INUSE_SectorParameters_contents_data07 (c_CONN_OMP_INUSE_SectorParameters_contents_data07* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_OMP_INUSE_SectorParameters_contents_data07_data** tmp;
		tmp = (c_CONN_OMP_INUSE_SectorParameters_contents_data07_data**)EDAlloc (sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data07_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data07_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_OMP_INUSE_SectorParameters_contents_data07_data*)EDAlloc (sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data07_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data07_data));
			(sequence->data[i]->AccessHashingChannelMaskSameAsPrevious) = 0;
			sequence->data[i]->AccessHashingChannelMask.value = NULL;
			sequence->data[i]->AccessHashingChannelMask.usedBits = 0;
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->AccessHashingChannelMask.value != NULL) {
					EDFree (sequence->data[i]->AccessHashingChannelMask.value);
					sequence->data[i]->AccessHashingChannelMask.value = NULL;
				}
				sequence->data[i]->AccessHashingChannelMask.usedBits = 0;
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_OMP_INUSE_SectorParameters_contents_data07_data */
void FREE_c_CONN_OMP_INUSE_SectorParameters_contents_data07_data (c_CONN_OMP_INUSE_SectorParameters_contents_data07_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AccessHashingChannelMask.value != NULL) {
		EDFree (sp->AccessHashingChannelMask.value);
		sp->AccessHashingChannelMask.value = NULL;
	}
	sp->AccessHashingChannelMask.usedBits = 0;

}

/* SETITEMS commands for type 'c_CONN_OMP_INUSE_SectorParameters_contents_data08'. Existing items are not changed. */
int SETITEMS_c_CONN_OMP_INUSE_SectorParameters_contents_data08 (c_CONN_OMP_INUSE_SectorParameters_contents_data08* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_OMP_INUSE_SectorParameters_contents_data08_data** tmp;
		tmp = (c_CONN_OMP_INUSE_SectorParameters_contents_data08_data**)EDAlloc (sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data08_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data08_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_OMP_INUSE_SectorParameters_contents_data08_data*)EDAlloc (sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data08_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data08_data));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->FPDCHSupported_Present) {
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_OMP_INUSE_SectorParameters_contents_data08_data */
void FREE_c_CONN_OMP_INUSE_SectorParameters_contents_data08_data (c_CONN_OMP_INUSE_SectorParameters_contents_data08_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_OMP_INUSE_SectorParameters_contents_data09'. Existing items are not changed. */
int SETITEMS_c_CONN_OMP_INUSE_SectorParameters_contents_data09 (c_CONN_OMP_INUSE_SectorParameters_contents_data09* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_OMP_INUSE_SectorParameters_contents_data09_data** tmp;
		tmp = (c_CONN_OMP_INUSE_SectorParameters_contents_data09_data**)EDAlloc (sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data09_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data09_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_OMP_INUSE_SectorParameters_contents_data09_data*)EDAlloc (sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data09_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data09_data));
			(sequence->data[i]->SecondaryColorCode) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_OMP_INUSE_SectorParameters_contents_data09_data */
void FREE_c_CONN_OMP_INUSE_SectorParameters_contents_data09_data (c_CONN_OMP_INUSE_SectorParameters_contents_data09_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_OMP_INUSE_SectorParameters_contents_data10'. Existing items are not changed. */
int SETITEMS_c_CONN_OMP_INUSE_SectorParameters_contents_data10 (c_CONN_OMP_INUSE_SectorParameters_contents_data10* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_OMP_INUSE_SectorParameters_contents_data10_data** tmp;
		tmp = (c_CONN_OMP_INUSE_SectorParameters_contents_data10_data**)EDAlloc (sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data10_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data10_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_OMP_INUSE_SectorParameters_contents_data10_data*)EDAlloc (sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data10_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data10_data));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->PilotGroupIDIncluded_Present) {
				}
				if (sequence->data[i]->PilotGroupID_Present) {
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_OMP_INUSE_SectorParameters_contents_data10_data */
void FREE_c_CONN_OMP_INUSE_SectorParameters_contents_data10_data (c_CONN_OMP_INUSE_SectorParameters_contents_data10_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_CONN_OMP_INUSE_SectorParameters_contents_data11'. Existing items are not changed. */
int SETITEMS_c_CONN_OMP_INUSE_SectorParameters_contents_data11 (c_CONN_OMP_INUSE_SectorParameters_contents_data11* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_CONN_OMP_INUSE_SectorParameters_contents_data11_data** tmp;
		tmp = (c_CONN_OMP_INUSE_SectorParameters_contents_data11_data**)EDAlloc (sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data11_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data11_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_CONN_OMP_INUSE_SectorParameters_contents_data11_data*)EDAlloc (sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data11_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_CONN_OMP_INUSE_SectorParameters_contents_data11_data));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->ReverseBandClass_Present) {
				}
				if (sequence->data[i]->ReverseChannelNumber_Present) {
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_CONN_OMP_INUSE_SectorParameters_contents_data11_data */
void FREE_c_CONN_OMP_INUSE_SectorParameters_contents_data11_data (c_CONN_OMP_INUSE_SectorParameters_contents_data11_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_SECURITY_DSP_INCFG_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_SECURITY_DSP_INCFG_ConfigurationRequest_contents_data01 (c_SECURITY_DSP_INCFG_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_SECURITY_DSP_INCFG_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_SECURITY_DSP_INCFG_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_SECURITY_DSP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_SECURITY_DSP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_SECURITY_DSP_INCFG_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_SECURITY_DSP_INCFG_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_SECURITY_DSP_INCFG_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeRecord.Length) = 0;
			(sequence->data[i]->AttributeRecord.AttributeID) = 0;
			sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
			sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
			
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->AttributeRecord.AttributeValue.value != NULL) {
					EDFree (sequence->data[i]->AttributeRecord.AttributeValue.value);
					sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
				}
				sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_SECURITY_DSP_INCFG_ConfigurationRequest_contents_data01_data */
void FREE_c_SECURITY_DSP_INCFG_ConfigurationRequest_contents_data01_data (c_SECURITY_DSP_INCFG_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeRecord.AttributeValue.value != NULL) {
		EDFree (sp->AttributeRecord.AttributeValue.value);
		sp->AttributeRecord.AttributeValue.value = NULL;
	}
	sp->AttributeRecord.AttributeValue.usedBits = 0;

}

/* Free function for struct c_SECURITY_DSP_INCFG_ConfigurationRequest_contents_data01_data_AttributeRecord */
void FREE_c_SECURITY_DSP_INCFG_ConfigurationRequest_contents_data01_data_AttributeRecord (c_SECURITY_DSP_INCFG_ConfigurationRequest_contents_data01_data_AttributeRecord* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeValue.value != NULL) {
		EDFree (sp->AttributeValue.value);
		sp->AttributeValue.value = NULL;
	}
	sp->AttributeValue.usedBits = 0;

}

/* SETITEMS commands for type 'c_SECURITY_DSP_INCFG_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_SECURITY_DSP_INCFG_ConfigurationResponse_contents_data01 (c_SECURITY_DSP_INCFG_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_SECURITY_DSP_INCFG_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_SECURITY_DSP_INCFG_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_SECURITY_DSP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_SECURITY_DSP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_SECURITY_DSP_INCFG_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_SECURITY_DSP_INCFG_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_SECURITY_DSP_INCFG_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeRecord.Length) = 0;
			(sequence->data[i]->AttributeRecord.AttributeID) = 0;
			sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
			sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
			
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->AttributeRecord.AttributeValue.value != NULL) {
					EDFree (sequence->data[i]->AttributeRecord.AttributeValue.value);
					sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
				}
				sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_SECURITY_DSP_INCFG_ConfigurationResponse_contents_data01_data */
void FREE_c_SECURITY_DSP_INCFG_ConfigurationResponse_contents_data01_data (c_SECURITY_DSP_INCFG_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeRecord.AttributeValue.value != NULL) {
		EDFree (sp->AttributeRecord.AttributeValue.value);
		sp->AttributeRecord.AttributeValue.value = NULL;
	}
	sp->AttributeRecord.AttributeValue.usedBits = 0;

}

/* Free function for struct c_SECURITY_DSP_INCFG_ConfigurationResponse_contents_data01_data_AttributeRecord */
void FREE_c_SECURITY_DSP_INCFG_ConfigurationResponse_contents_data01_data_AttributeRecord (c_SECURITY_DSP_INCFG_ConfigurationResponse_contents_data01_data_AttributeRecord* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeValue.value != NULL) {
		EDFree (sp->AttributeValue.value);
		sp->AttributeValue.value = NULL;
	}
	sp->AttributeValue.usedBits = 0;

}

/* SETITEMS commands for type 'c_SECURITY_GSP_INCFG_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_SECURITY_GSP_INCFG_ConfigurationRequest_contents_data01 (c_SECURITY_GSP_INCFG_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_SECURITY_GSP_INCFG_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_SECURITY_GSP_INCFG_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_SECURITY_GSP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_SECURITY_GSP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_SECURITY_GSP_INCFG_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_SECURITY_GSP_INCFG_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_SECURITY_GSP_INCFG_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeRecord.Length) = 0;
			(sequence->data[i]->AttributeRecord.AttributeID) = 0;
			sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
			sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
			
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->AttributeRecord.AttributeValue.value != NULL) {
					EDFree (sequence->data[i]->AttributeRecord.AttributeValue.value);
					sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
				}
				sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_SECURITY_GSP_INCFG_ConfigurationRequest_contents_data01_data */
void FREE_c_SECURITY_GSP_INCFG_ConfigurationRequest_contents_data01_data (c_SECURITY_GSP_INCFG_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeRecord.AttributeValue.value != NULL) {
		EDFree (sp->AttributeRecord.AttributeValue.value);
		sp->AttributeRecord.AttributeValue.value = NULL;
	}
	sp->AttributeRecord.AttributeValue.usedBits = 0;

}

/* Free function for struct c_SECURITY_GSP_INCFG_ConfigurationRequest_contents_data01_data_AttributeRecord */
void FREE_c_SECURITY_GSP_INCFG_ConfigurationRequest_contents_data01_data_AttributeRecord (c_SECURITY_GSP_INCFG_ConfigurationRequest_contents_data01_data_AttributeRecord* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeValue.value != NULL) {
		EDFree (sp->AttributeValue.value);
		sp->AttributeValue.value = NULL;
	}
	sp->AttributeValue.usedBits = 0;

}

/* SETITEMS commands for type 'c_SECURITY_GSP_INCFG_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_SECURITY_GSP_INCFG_ConfigurationResponse_contents_data01 (c_SECURITY_GSP_INCFG_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_SECURITY_GSP_INCFG_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_SECURITY_GSP_INCFG_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_SECURITY_GSP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_SECURITY_GSP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_SECURITY_GSP_INCFG_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_SECURITY_GSP_INCFG_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_SECURITY_GSP_INCFG_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeRecord.Length) = 0;
			(sequence->data[i]->AttributeRecord.AttributeID) = 0;
			sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
			sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
			
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->AttributeRecord.AttributeValue.value != NULL) {
					EDFree (sequence->data[i]->AttributeRecord.AttributeValue.value);
					sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
				}
				sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_SECURITY_GSP_INCFG_ConfigurationResponse_contents_data01_data */
void FREE_c_SECURITY_GSP_INCFG_ConfigurationResponse_contents_data01_data (c_SECURITY_GSP_INCFG_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeRecord.AttributeValue.value != NULL) {
		EDFree (sp->AttributeRecord.AttributeValue.value);
		sp->AttributeRecord.AttributeValue.value = NULL;
	}
	sp->AttributeRecord.AttributeValue.usedBits = 0;

}

/* Free function for struct c_SECURITY_GSP_INCFG_ConfigurationResponse_contents_data01_data_AttributeRecord */
void FREE_c_SECURITY_GSP_INCFG_ConfigurationResponse_contents_data01_data_AttributeRecord (c_SECURITY_GSP_INCFG_ConfigurationResponse_contents_data01_data_AttributeRecord* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeValue.value != NULL) {
		EDFree (sp->AttributeValue.value);
		sp->AttributeValue.value = NULL;
	}
	sp->AttributeValue.usedBits = 0;

}

/* SETITEMS commands for type 'c_SECURITY_DKEP_INCFG_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_SECURITY_DKEP_INCFG_ConfigurationRequest_contents_data01 (c_SECURITY_DKEP_INCFG_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_SECURITY_DKEP_INCFG_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_SECURITY_DKEP_INCFG_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_SECURITY_DKEP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_SECURITY_DKEP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_SECURITY_DKEP_INCFG_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_SECURITY_DKEP_INCFG_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_SECURITY_DKEP_INCFG_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeRecord.Length) = 0;
			(sequence->data[i]->AttributeRecord.AttributeID) = 0;
			sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
			sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
			
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->AttributeRecord.AttributeValue.value != NULL) {
					EDFree (sequence->data[i]->AttributeRecord.AttributeValue.value);
					sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
				}
				sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_SECURITY_DKEP_INCFG_ConfigurationRequest_contents_data01_data */
void FREE_c_SECURITY_DKEP_INCFG_ConfigurationRequest_contents_data01_data (c_SECURITY_DKEP_INCFG_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeRecord.AttributeValue.value != NULL) {
		EDFree (sp->AttributeRecord.AttributeValue.value);
		sp->AttributeRecord.AttributeValue.value = NULL;
	}
	sp->AttributeRecord.AttributeValue.usedBits = 0;

}

/* Free function for struct c_SECURITY_DKEP_INCFG_ConfigurationRequest_contents_data01_data_AttributeRecord */
void FREE_c_SECURITY_DKEP_INCFG_ConfigurationRequest_contents_data01_data_AttributeRecord (c_SECURITY_DKEP_INCFG_ConfigurationRequest_contents_data01_data_AttributeRecord* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeValue.value != NULL) {
		EDFree (sp->AttributeValue.value);
		sp->AttributeValue.value = NULL;
	}
	sp->AttributeValue.usedBits = 0;

}

/* SETITEMS commands for type 'c_SECURITY_DKEP_INCFG_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_SECURITY_DKEP_INCFG_ConfigurationResponse_contents_data01 (c_SECURITY_DKEP_INCFG_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_SECURITY_DKEP_INCFG_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_SECURITY_DKEP_INCFG_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_SECURITY_DKEP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_SECURITY_DKEP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_SECURITY_DKEP_INCFG_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_SECURITY_DKEP_INCFG_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_SECURITY_DKEP_INCFG_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeRecord.Length) = 0;
			(sequence->data[i]->AttributeRecord.AttributeID) = 0;
			sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
			sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
			
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->AttributeRecord.AttributeValue.value != NULL) {
					EDFree (sequence->data[i]->AttributeRecord.AttributeValue.value);
					sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
				}
				sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_SECURITY_DKEP_INCFG_ConfigurationResponse_contents_data01_data */
void FREE_c_SECURITY_DKEP_INCFG_ConfigurationResponse_contents_data01_data (c_SECURITY_DKEP_INCFG_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeRecord.AttributeValue.value != NULL) {
		EDFree (sp->AttributeRecord.AttributeValue.value);
		sp->AttributeRecord.AttributeValue.value = NULL;
	}
	sp->AttributeRecord.AttributeValue.usedBits = 0;

}

/* Free function for struct c_SECURITY_DKEP_INCFG_ConfigurationResponse_contents_data01_data_AttributeRecord */
void FREE_c_SECURITY_DKEP_INCFG_ConfigurationResponse_contents_data01_data_AttributeRecord (c_SECURITY_DKEP_INCFG_ConfigurationResponse_contents_data01_data_AttributeRecord* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeValue.value != NULL) {
		EDFree (sp->AttributeValue.value);
		sp->AttributeValue.value = NULL;
	}
	sp->AttributeValue.usedBits = 0;

}

/* SETITEMS commands for type 'c_SECURITY_DHKEP_INCFG_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_SECURITY_DHKEP_INCFG_ConfigurationRequest_contents_data01 (c_SECURITY_DHKEP_INCFG_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_SECURITY_DHKEP_INCFG_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_SECURITY_DHKEP_INCFG_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_SECURITY_DHKEP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_SECURITY_DHKEP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_SECURITY_DHKEP_INCFG_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_SECURITY_DHKEP_INCFG_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_SECURITY_DHKEP_INCFG_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_DH_Key_Exchange_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_DH_Key_Exchange_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_SECURITY_DHKEP_INCFG_ConfigurationRequest_contents_data01_data */
void FREE_c_SECURITY_DHKEP_INCFG_ConfigurationRequest_contents_data01_data (c_SECURITY_DHKEP_INCFG_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_DH_Key_Exchange_Protocol_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_SECURITY_DHKEP_INCFG_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_SECURITY_DHKEP_INCFG_ConfigurationResponse_contents_data01 (c_SECURITY_DHKEP_INCFG_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_SECURITY_DHKEP_INCFG_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_SECURITY_DHKEP_INCFG_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_SECURITY_DHKEP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_SECURITY_DHKEP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_SECURITY_DHKEP_INCFG_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_SECURITY_DHKEP_INCFG_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_SECURITY_DHKEP_INCFG_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_DH_Key_Exchange_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_DH_Key_Exchange_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_SECURITY_DHKEP_INCFG_ConfigurationResponse_contents_data01_data */
void FREE_c_SECURITY_DHKEP_INCFG_ConfigurationResponse_contents_data01_data (c_SECURITY_DHKEP_INCFG_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_DH_Key_Exchange_Protocol_Attributes_Response (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_SECURITY_DAP_INCFG_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_SECURITY_DAP_INCFG_ConfigurationRequest_contents_data01 (c_SECURITY_DAP_INCFG_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_SECURITY_DAP_INCFG_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_SECURITY_DAP_INCFG_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_SECURITY_DAP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_SECURITY_DAP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_SECURITY_DAP_INCFG_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_SECURITY_DAP_INCFG_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_SECURITY_DAP_INCFG_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeRecord.Length) = 0;
			(sequence->data[i]->AttributeRecord.AttributeID) = 0;
			sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
			sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
			
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->AttributeRecord.AttributeValue.value != NULL) {
					EDFree (sequence->data[i]->AttributeRecord.AttributeValue.value);
					sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
				}
				sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_SECURITY_DAP_INCFG_ConfigurationRequest_contents_data01_data */
void FREE_c_SECURITY_DAP_INCFG_ConfigurationRequest_contents_data01_data (c_SECURITY_DAP_INCFG_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeRecord.AttributeValue.value != NULL) {
		EDFree (sp->AttributeRecord.AttributeValue.value);
		sp->AttributeRecord.AttributeValue.value = NULL;
	}
	sp->AttributeRecord.AttributeValue.usedBits = 0;

}

/* Free function for struct c_SECURITY_DAP_INCFG_ConfigurationRequest_contents_data01_data_AttributeRecord */
void FREE_c_SECURITY_DAP_INCFG_ConfigurationRequest_contents_data01_data_AttributeRecord (c_SECURITY_DAP_INCFG_ConfigurationRequest_contents_data01_data_AttributeRecord* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeValue.value != NULL) {
		EDFree (sp->AttributeValue.value);
		sp->AttributeValue.value = NULL;
	}
	sp->AttributeValue.usedBits = 0;

}

/* SETITEMS commands for type 'c_SECURITY_DAP_INCFG_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_SECURITY_DAP_INCFG_ConfigurationResponse_contents_data01 (c_SECURITY_DAP_INCFG_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_SECURITY_DAP_INCFG_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_SECURITY_DAP_INCFG_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_SECURITY_DAP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_SECURITY_DAP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_SECURITY_DAP_INCFG_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_SECURITY_DAP_INCFG_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_SECURITY_DAP_INCFG_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeRecord.Length) = 0;
			(sequence->data[i]->AttributeRecord.AttributeID) = 0;
			sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
			sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
			
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->AttributeRecord.AttributeValue.value != NULL) {
					EDFree (sequence->data[i]->AttributeRecord.AttributeValue.value);
					sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
				}
				sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_SECURITY_DAP_INCFG_ConfigurationResponse_contents_data01_data */
void FREE_c_SECURITY_DAP_INCFG_ConfigurationResponse_contents_data01_data (c_SECURITY_DAP_INCFG_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeRecord.AttributeValue.value != NULL) {
		EDFree (sp->AttributeRecord.AttributeValue.value);
		sp->AttributeRecord.AttributeValue.value = NULL;
	}
	sp->AttributeRecord.AttributeValue.usedBits = 0;

}

/* Free function for struct c_SECURITY_DAP_INCFG_ConfigurationResponse_contents_data01_data_AttributeRecord */
void FREE_c_SECURITY_DAP_INCFG_ConfigurationResponse_contents_data01_data_AttributeRecord (c_SECURITY_DAP_INCFG_ConfigurationResponse_contents_data01_data_AttributeRecord* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeValue.value != NULL) {
		EDFree (sp->AttributeValue.value);
		sp->AttributeValue.value = NULL;
	}
	sp->AttributeValue.usedBits = 0;

}

/* SETITEMS commands for type 'c_SECURITY_SHA1AP_INCFG_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_SECURITY_SHA1AP_INCFG_ConfigurationRequest_contents_data01 (c_SECURITY_SHA1AP_INCFG_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_SECURITY_SHA1AP_INCFG_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_SECURITY_SHA1AP_INCFG_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_SECURITY_SHA1AP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_SECURITY_SHA1AP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_SECURITY_SHA1AP_INCFG_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_SECURITY_SHA1AP_INCFG_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_SECURITY_SHA1AP_INCFG_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_SHA_1_Authentication_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_SHA_1_Authentication_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_SECURITY_SHA1AP_INCFG_ConfigurationRequest_contents_data01_data */
void FREE_c_SECURITY_SHA1AP_INCFG_ConfigurationRequest_contents_data01_data (c_SECURITY_SHA1AP_INCFG_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_SHA_1_Authentication_Protocol_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_SECURITY_SHA1AP_INCFG_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_SECURITY_SHA1AP_INCFG_ConfigurationResponse_contents_data01 (c_SECURITY_SHA1AP_INCFG_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_SECURITY_SHA1AP_INCFG_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_SECURITY_SHA1AP_INCFG_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_SECURITY_SHA1AP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_SECURITY_SHA1AP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_SECURITY_SHA1AP_INCFG_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_SECURITY_SHA1AP_INCFG_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_SECURITY_SHA1AP_INCFG_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_SHA_1_Authentication_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_SHA_1_Authentication_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_SECURITY_SHA1AP_INCFG_ConfigurationResponse_contents_data01_data */
void FREE_c_SECURITY_SHA1AP_INCFG_ConfigurationResponse_contents_data01_data (c_SECURITY_SHA1AP_INCFG_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_SHA_1_Authentication_Protocol_Attributes_Response (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_SECURITY_DEP_INCFG_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_SECURITY_DEP_INCFG_ConfigurationRequest_contents_data01 (c_SECURITY_DEP_INCFG_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_SECURITY_DEP_INCFG_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_SECURITY_DEP_INCFG_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_SECURITY_DEP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_SECURITY_DEP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_SECURITY_DEP_INCFG_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_SECURITY_DEP_INCFG_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_SECURITY_DEP_INCFG_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeRecord.Length) = 0;
			(sequence->data[i]->AttributeRecord.AttributeID) = 0;
			sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
			sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
			
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->AttributeRecord.AttributeValue.value != NULL) {
					EDFree (sequence->data[i]->AttributeRecord.AttributeValue.value);
					sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
				}
				sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_SECURITY_DEP_INCFG_ConfigurationRequest_contents_data01_data */
void FREE_c_SECURITY_DEP_INCFG_ConfigurationRequest_contents_data01_data (c_SECURITY_DEP_INCFG_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeRecord.AttributeValue.value != NULL) {
		EDFree (sp->AttributeRecord.AttributeValue.value);
		sp->AttributeRecord.AttributeValue.value = NULL;
	}
	sp->AttributeRecord.AttributeValue.usedBits = 0;

}

/* Free function for struct c_SECURITY_DEP_INCFG_ConfigurationRequest_contents_data01_data_AttributeRecord */
void FREE_c_SECURITY_DEP_INCFG_ConfigurationRequest_contents_data01_data_AttributeRecord (c_SECURITY_DEP_INCFG_ConfigurationRequest_contents_data01_data_AttributeRecord* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeValue.value != NULL) {
		EDFree (sp->AttributeValue.value);
		sp->AttributeValue.value = NULL;
	}
	sp->AttributeValue.usedBits = 0;

}

/* SETITEMS commands for type 'c_SECURITY_DEP_INCFG_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_SECURITY_DEP_INCFG_ConfigurationResponse_contents_data01 (c_SECURITY_DEP_INCFG_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_SECURITY_DEP_INCFG_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_SECURITY_DEP_INCFG_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_SECURITY_DEP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_SECURITY_DEP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_SECURITY_DEP_INCFG_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_SECURITY_DEP_INCFG_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_SECURITY_DEP_INCFG_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeRecord.Length) = 0;
			(sequence->data[i]->AttributeRecord.AttributeID) = 0;
			sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
			sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
			
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->AttributeRecord.AttributeValue.value != NULL) {
					EDFree (sequence->data[i]->AttributeRecord.AttributeValue.value);
					sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
				}
				sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_SECURITY_DEP_INCFG_ConfigurationResponse_contents_data01_data */
void FREE_c_SECURITY_DEP_INCFG_ConfigurationResponse_contents_data01_data (c_SECURITY_DEP_INCFG_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeRecord.AttributeValue.value != NULL) {
		EDFree (sp->AttributeRecord.AttributeValue.value);
		sp->AttributeRecord.AttributeValue.value = NULL;
	}
	sp->AttributeRecord.AttributeValue.usedBits = 0;

}

/* Free function for struct c_SECURITY_DEP_INCFG_ConfigurationResponse_contents_data01_data_AttributeRecord */
void FREE_c_SECURITY_DEP_INCFG_ConfigurationResponse_contents_data01_data_AttributeRecord (c_SECURITY_DEP_INCFG_ConfigurationResponse_contents_data01_data_AttributeRecord* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeValue.value != NULL) {
		EDFree (sp->AttributeValue.value);
		sp->AttributeValue.value = NULL;
	}
	sp->AttributeValue.usedBits = 0;

}

/* SETITEMS commands for type 'c_MAC_DCCMACP_INCFG_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MAC_DCCMACP_INCFG_ConfigurationRequest_contents_data01 (c_MAC_DCCMACP_INCFG_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_DCCMACP_INCFG_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_MAC_DCCMACP_INCFG_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_MAC_DCCMACP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_DCCMACP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_DCCMACP_INCFG_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_MAC_DCCMACP_INCFG_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_DCCMACP_INCFG_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeRecord.Length) = 0;
			(sequence->data[i]->AttributeRecord.AttributeID) = 0;
			sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
			sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
			
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->AttributeRecord.AttributeValue.value != NULL) {
					EDFree (sequence->data[i]->AttributeRecord.AttributeValue.value);
					sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
				}
				sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_DCCMACP_INCFG_ConfigurationRequest_contents_data01_data */
void FREE_c_MAC_DCCMACP_INCFG_ConfigurationRequest_contents_data01_data (c_MAC_DCCMACP_INCFG_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeRecord.AttributeValue.value != NULL) {
		EDFree (sp->AttributeRecord.AttributeValue.value);
		sp->AttributeRecord.AttributeValue.value = NULL;
	}
	sp->AttributeRecord.AttributeValue.usedBits = 0;

}

/* Free function for struct c_MAC_DCCMACP_INCFG_ConfigurationRequest_contents_data01_data_AttributeRecord */
void FREE_c_MAC_DCCMACP_INCFG_ConfigurationRequest_contents_data01_data_AttributeRecord (c_MAC_DCCMACP_INCFG_ConfigurationRequest_contents_data01_data_AttributeRecord* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeValue.value != NULL) {
		EDFree (sp->AttributeValue.value);
		sp->AttributeValue.value = NULL;
	}
	sp->AttributeValue.usedBits = 0;

}

/* SETITEMS commands for type 'c_MAC_DCCMACP_INCFG_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MAC_DCCMACP_INCFG_ConfigurationResponse_contents_data01 (c_MAC_DCCMACP_INCFG_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_DCCMACP_INCFG_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_MAC_DCCMACP_INCFG_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_MAC_DCCMACP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_DCCMACP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_DCCMACP_INCFG_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_MAC_DCCMACP_INCFG_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_DCCMACP_INCFG_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeRecord.Length) = 0;
			(sequence->data[i]->AttributeRecord.AttributeID) = 0;
			sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
			sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
			
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->AttributeRecord.AttributeValue.value != NULL) {
					EDFree (sequence->data[i]->AttributeRecord.AttributeValue.value);
					sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
				}
				sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_DCCMACP_INCFG_ConfigurationResponse_contents_data01_data */
void FREE_c_MAC_DCCMACP_INCFG_ConfigurationResponse_contents_data01_data (c_MAC_DCCMACP_INCFG_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeRecord.AttributeValue.value != NULL) {
		EDFree (sp->AttributeRecord.AttributeValue.value);
		sp->AttributeRecord.AttributeValue.value = NULL;
	}
	sp->AttributeRecord.AttributeValue.usedBits = 0;

}

/* Free function for struct c_MAC_DCCMACP_INCFG_ConfigurationResponse_contents_data01_data_AttributeRecord */
void FREE_c_MAC_DCCMACP_INCFG_ConfigurationResponse_contents_data01_data_AttributeRecord (c_MAC_DCCMACP_INCFG_ConfigurationResponse_contents_data01_data_AttributeRecord* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeValue.value != NULL) {
		EDFree (sp->AttributeValue.value);
		sp->AttributeValue.value = NULL;
	}
	sp->AttributeValue.usedBits = 0;

}

/* SETITEMS commands for type 'c_MAC_ECCMACP_INCFG_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MAC_ECCMACP_INCFG_ConfigurationRequest_contents_data01 (c_MAC_ECCMACP_INCFG_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_ECCMACP_INCFG_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_MAC_ECCMACP_INCFG_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_MAC_ECCMACP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_ECCMACP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_ECCMACP_INCFG_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_MAC_ECCMACP_INCFG_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_ECCMACP_INCFG_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Enhanced_Control_Channel_MAC_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Enhanced_Control_Channel_MAC_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_ECCMACP_INCFG_ConfigurationRequest_contents_data01_data */
void FREE_c_MAC_ECCMACP_INCFG_ConfigurationRequest_contents_data01_data (c_MAC_ECCMACP_INCFG_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Enhanced_Control_Channel_MAC_Protocol_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_MAC_ECCMACP_INCFG_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MAC_ECCMACP_INCFG_ConfigurationResponse_contents_data01 (c_MAC_ECCMACP_INCFG_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_ECCMACP_INCFG_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_MAC_ECCMACP_INCFG_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_MAC_ECCMACP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_ECCMACP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_ECCMACP_INCFG_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_MAC_ECCMACP_INCFG_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_ECCMACP_INCFG_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Enhanced_Control_Channel_MAC_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Enhanced_Control_Channel_MAC_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_ECCMACP_INCFG_ConfigurationResponse_contents_data01_data */
void FREE_c_MAC_ECCMACP_INCFG_ConfigurationResponse_contents_data01_data (c_MAC_ECCMACP_INCFG_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Enhanced_Control_Channel_MAC_Protocol_Attributes_Response (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_MAC_DACMACP_INCFG_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MAC_DACMACP_INCFG_ConfigurationRequest_contents_data01 (c_MAC_DACMACP_INCFG_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_DACMACP_INCFG_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_MAC_DACMACP_INCFG_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_MAC_DACMACP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_DACMACP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_DACMACP_INCFG_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_MAC_DACMACP_INCFG_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_DACMACP_INCFG_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Default_Access_Channel_MAC_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Default_Access_Channel_MAC_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_DACMACP_INCFG_ConfigurationRequest_contents_data01_data */
void FREE_c_MAC_DACMACP_INCFG_ConfigurationRequest_contents_data01_data (c_MAC_DACMACP_INCFG_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Default_Access_Channel_MAC_Protocol_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_MAC_DACMACP_INCFG_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MAC_DACMACP_INCFG_ConfigurationResponse_contents_data01 (c_MAC_DACMACP_INCFG_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_DACMACP_INCFG_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_MAC_DACMACP_INCFG_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_MAC_DACMACP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_DACMACP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_DACMACP_INCFG_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_MAC_DACMACP_INCFG_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_DACMACP_INCFG_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Default_Access_Channel_MAC_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Default_Access_Channel_MAC_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_DACMACP_INCFG_ConfigurationResponse_contents_data01_data */
void FREE_c_MAC_DACMACP_INCFG_ConfigurationResponse_contents_data01_data (c_MAC_DACMACP_INCFG_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Default_Access_Channel_MAC_Protocol_Attributes_Response (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_MAC_DACMACP_INUSE_AccessParameters_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MAC_DACMACP_INUSE_AccessParameters_contents_data01 (c_MAC_DACMACP_INUSE_AccessParameters_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_DACMACP_INUSE_AccessParameters_contents_data01_data** tmp;
		tmp = (c_MAC_DACMACP_INUSE_AccessParameters_contents_data01_data**)EDAlloc (sizeof (c_MAC_DACMACP_INUSE_AccessParameters_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_DACMACP_INUSE_AccessParameters_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_DACMACP_INUSE_AccessParameters_contents_data01_data*)EDAlloc (sizeof (c_MAC_DACMACP_INUSE_AccessParameters_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_DACMACP_INUSE_AccessParameters_contents_data01_data));
			(sequence->data[i]->APersistence) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_DACMACP_INUSE_AccessParameters_contents_data01_data */
void FREE_c_MAC_DACMACP_INUSE_AccessParameters_contents_data01_data (c_MAC_DACMACP_INUSE_AccessParameters_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_MAC_EACMACP_INCFG_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MAC_EACMACP_INCFG_ConfigurationRequest_contents_data01 (c_MAC_EACMACP_INCFG_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_EACMACP_INCFG_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_MAC_EACMACP_INCFG_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_MAC_EACMACP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_EACMACP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_EACMACP_INCFG_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_MAC_EACMACP_INCFG_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_EACMACP_INCFG_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_EACMACP_INCFG_ConfigurationRequest_contents_data01_data */
void FREE_c_MAC_EACMACP_INCFG_ConfigurationRequest_contents_data01_data (c_MAC_EACMACP_INCFG_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_MAC_EACMACP_INCFG_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MAC_EACMACP_INCFG_ConfigurationResponse_contents_data01 (c_MAC_EACMACP_INCFG_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_EACMACP_INCFG_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_MAC_EACMACP_INCFG_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_MAC_EACMACP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_EACMACP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_EACMACP_INCFG_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_MAC_EACMACP_INCFG_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_EACMACP_INCFG_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_EACMACP_INCFG_ConfigurationResponse_contents_data01_data */
void FREE_c_MAC_EACMACP_INCFG_ConfigurationResponse_contents_data01_data (c_MAC_EACMACP_INCFG_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes_Response (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_MAC_EACMACP_INUSE_AccessParameters_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MAC_EACMACP_INUSE_AccessParameters_contents_data01 (c_MAC_EACMACP_INUSE_AccessParameters_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_EACMACP_INUSE_AccessParameters_contents_data01_data** tmp;
		tmp = (c_MAC_EACMACP_INUSE_AccessParameters_contents_data01_data**)EDAlloc (sizeof (c_MAC_EACMACP_INUSE_AccessParameters_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_EACMACP_INUSE_AccessParameters_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_EACMACP_INUSE_AccessParameters_contents_data01_data*)EDAlloc (sizeof (c_MAC_EACMACP_INUSE_AccessParameters_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_EACMACP_INUSE_AccessParameters_contents_data01_data));
			(sequence->data[i]->APersistence) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_EACMACP_INUSE_AccessParameters_contents_data01_data */
void FREE_c_MAC_EACMACP_INUSE_AccessParameters_contents_data01_data (c_MAC_EACMACP_INUSE_AccessParameters_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_MAC_EACMACP_INUSE_AccessParameters_contents_data02'. Existing items are not changed. */
int SETITEMS_c_MAC_EACMACP_INUSE_AccessParameters_contents_data02 (c_MAC_EACMACP_INUSE_AccessParameters_contents_data02* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_EACMACP_INUSE_AccessParameters_contents_data02_data** tmp;
		tmp = (c_MAC_EACMACP_INUSE_AccessParameters_contents_data02_data**)EDAlloc (sizeof (c_MAC_EACMACP_INUSE_AccessParameters_contents_data02_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_EACMACP_INUSE_AccessParameters_contents_data02_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_EACMACP_INUSE_AccessParameters_contents_data02_data*)EDAlloc (sizeof (c_MAC_EACMACP_INUSE_AccessParameters_contents_data02_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_EACMACP_INUSE_AccessParameters_contents_data02_data));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->ProfileID_Present) {
				}
				if (sequence->data[i]->CommonPersistenceIncluded_Present) {
				}
				if (sequence->data[i]->CommonAPersistence_Present) {
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_EACMACP_INUSE_AccessParameters_contents_data02_data */
void FREE_c_MAC_EACMACP_INUSE_AccessParameters_contents_data02_data (c_MAC_EACMACP_INUSE_AccessParameters_contents_data02_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_MAC_EACMACP_INUSE_AccessParameters_contents_data03'. Existing items are not changed. */
int SETITEMS_c_MAC_EACMACP_INUSE_AccessParameters_contents_data03 (c_MAC_EACMACP_INUSE_AccessParameters_contents_data03* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_EACMACP_INUSE_AccessParameters_contents_data03_data** tmp;
		tmp = (c_MAC_EACMACP_INUSE_AccessParameters_contents_data03_data**)EDAlloc (sizeof (c_MAC_EACMACP_INUSE_AccessParameters_contents_data03_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_EACMACP_INUSE_AccessParameters_contents_data03_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_EACMACP_INUSE_AccessParameters_contents_data03_data*)EDAlloc (sizeof (c_MAC_EACMACP_INUSE_AccessParameters_contents_data03_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_EACMACP_INUSE_AccessParameters_contents_data03_data));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->ProfileBasedAPersistence_Present) {
				}
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_EACMACP_INUSE_AccessParameters_contents_data03_data */
void FREE_c_MAC_EACMACP_INUSE_AccessParameters_contents_data03_data (c_MAC_EACMACP_INUSE_AccessParameters_contents_data03_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_MAC_EACMACP_INUSE_AttributeUpdateRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MAC_EACMACP_INUSE_AttributeUpdateRequest_contents_data01 (c_MAC_EACMACP_INUSE_AttributeUpdateRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_EACMACP_INUSE_AttributeUpdateRequest_contents_data01_data** tmp;
		tmp = (c_MAC_EACMACP_INUSE_AttributeUpdateRequest_contents_data01_data**)EDAlloc (sizeof (c_MAC_EACMACP_INUSE_AttributeUpdateRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_EACMACP_INUSE_AttributeUpdateRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_EACMACP_INUSE_AttributeUpdateRequest_contents_data01_data*)EDAlloc (sizeof (c_MAC_EACMACP_INUSE_AttributeUpdateRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_EACMACP_INUSE_AttributeUpdateRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_EACMACP_INUSE_AttributeUpdateRequest_contents_data01_data */
void FREE_c_MAC_EACMACP_INUSE_AttributeUpdateRequest_contents_data01_data (c_MAC_EACMACP_INUSE_AttributeUpdateRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Enhanced_Access_Channel_MAC_Protocol_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_MAC_DFTCMACP_INCFG_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MAC_DFTCMACP_INCFG_ConfigurationRequest_contents_data01 (c_MAC_DFTCMACP_INCFG_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_DFTCMACP_INCFG_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_MAC_DFTCMACP_INCFG_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_MAC_DFTCMACP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_DFTCMACP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_DFTCMACP_INCFG_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_MAC_DFTCMACP_INCFG_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_DFTCMACP_INCFG_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_DFTCMACP_INCFG_ConfigurationRequest_contents_data01_data */
void FREE_c_MAC_DFTCMACP_INCFG_ConfigurationRequest_contents_data01_data (c_MAC_DFTCMACP_INCFG_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_MAC_DFTCMACP_INCFG_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MAC_DFTCMACP_INCFG_ConfigurationResponse_contents_data01 (c_MAC_DFTCMACP_INCFG_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_DFTCMACP_INCFG_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_MAC_DFTCMACP_INCFG_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_MAC_DFTCMACP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_DFTCMACP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_DFTCMACP_INCFG_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_MAC_DFTCMACP_INCFG_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_DFTCMACP_INCFG_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_DFTCMACP_INCFG_ConfigurationResponse_contents_data01_data */
void FREE_c_MAC_DFTCMACP_INCFG_ConfigurationResponse_contents_data01_data (c_MAC_DFTCMACP_INCFG_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Default_Forward_Traffic_Channel_MAC_Protocol_Attributes_Response (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_MAC_EFTCMACP_INCFG_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MAC_EFTCMACP_INCFG_ConfigurationRequest_contents_data01 (c_MAC_EFTCMACP_INCFG_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_EFTCMACP_INCFG_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_MAC_EFTCMACP_INCFG_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_MAC_EFTCMACP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_EFTCMACP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_EFTCMACP_INCFG_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_MAC_EFTCMACP_INCFG_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_EFTCMACP_INCFG_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_EFTCMACP_INCFG_ConfigurationRequest_contents_data01_data */
void FREE_c_MAC_EFTCMACP_INCFG_ConfigurationRequest_contents_data01_data (c_MAC_EFTCMACP_INCFG_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_MAC_EFTCMACP_INCFG_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MAC_EFTCMACP_INCFG_ConfigurationResponse_contents_data01 (c_MAC_EFTCMACP_INCFG_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_EFTCMACP_INCFG_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_MAC_EFTCMACP_INCFG_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_MAC_EFTCMACP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_EFTCMACP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_EFTCMACP_INCFG_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_MAC_EFTCMACP_INCFG_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_EFTCMACP_INCFG_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_EFTCMACP_INCFG_ConfigurationResponse_contents_data01_data */
void FREE_c_MAC_EFTCMACP_INCFG_ConfigurationResponse_contents_data01_data (c_MAC_EFTCMACP_INCFG_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes_Response (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_MAC_EFTCMACP_INUSE_AttributeUpdateRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MAC_EFTCMACP_INUSE_AttributeUpdateRequest_contents_data01 (c_MAC_EFTCMACP_INUSE_AttributeUpdateRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_EFTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data** tmp;
		tmp = (c_MAC_EFTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data**)EDAlloc (sizeof (c_MAC_EFTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_EFTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_EFTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data*)EDAlloc (sizeof (c_MAC_EFTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_EFTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_EFTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data */
void FREE_c_MAC_EFTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data (c_MAC_EFTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Enhanced_Forward_Traffic_Channel_MAC_Protocol_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_MAC_MFTCMACP_INCFG_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MAC_MFTCMACP_INCFG_ConfigurationRequest_contents_data01 (c_MAC_MFTCMACP_INCFG_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_MFTCMACP_INCFG_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_MAC_MFTCMACP_INCFG_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_MAC_MFTCMACP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_MFTCMACP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_MFTCMACP_INCFG_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_MAC_MFTCMACP_INCFG_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_MFTCMACP_INCFG_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_MFTCMACP_INCFG_ConfigurationRequest_contents_data01_data */
void FREE_c_MAC_MFTCMACP_INCFG_ConfigurationRequest_contents_data01_data (c_MAC_MFTCMACP_INCFG_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_MAC_MFTCMACP_INCFG_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MAC_MFTCMACP_INCFG_ConfigurationResponse_contents_data01 (c_MAC_MFTCMACP_INCFG_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_MFTCMACP_INCFG_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_MAC_MFTCMACP_INCFG_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_MAC_MFTCMACP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_MFTCMACP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_MFTCMACP_INCFG_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_MAC_MFTCMACP_INCFG_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_MFTCMACP_INCFG_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_MFTCMACP_INCFG_ConfigurationResponse_contents_data01_data */
void FREE_c_MAC_MFTCMACP_INCFG_ConfigurationResponse_contents_data01_data (c_MAC_MFTCMACP_INCFG_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes_Response (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_MAC_MFTCMACP_INUSE_FixedModeEnable_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MAC_MFTCMACP_INUSE_FixedModeEnable_contents_data01 (c_MAC_MFTCMACP_INUSE_FixedModeEnable_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_MFTCMACP_INUSE_FixedModeEnable_contents_data01_data** tmp;
		tmp = (c_MAC_MFTCMACP_INUSE_FixedModeEnable_contents_data01_data**)EDAlloc (sizeof (c_MAC_MFTCMACP_INUSE_FixedModeEnable_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_MFTCMACP_INUSE_FixedModeEnable_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_MFTCMACP_INUSE_FixedModeEnable_contents_data01_data*)EDAlloc (sizeof (c_MAC_MFTCMACP_INUSE_FixedModeEnable_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_MFTCMACP_INUSE_FixedModeEnable_contents_data01_data));
			(sequence->data[i]->DSC) = 0;
			(sequence->data[i]->DRCCover) = 0;
			(sequence->data[i]->DRCValue) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_MFTCMACP_INUSE_FixedModeEnable_contents_data01_data */
void FREE_c_MAC_MFTCMACP_INUSE_FixedModeEnable_contents_data01_data (c_MAC_MFTCMACP_INUSE_FixedModeEnable_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_MAC_MFTCMACP_INUSE_AttributeUpdateRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MAC_MFTCMACP_INUSE_AttributeUpdateRequest_contents_data01 (c_MAC_MFTCMACP_INUSE_AttributeUpdateRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_MFTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data** tmp;
		tmp = (c_MAC_MFTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data**)EDAlloc (sizeof (c_MAC_MFTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_MFTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_MFTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data*)EDAlloc (sizeof (c_MAC_MFTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_MFTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_MFTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data */
void FREE_c_MAC_MFTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data (c_MAC_MFTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Multicarrier_Forward_Traffic_Channel_MAC_Protocol_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_MAC_DRTCMACP_INCFG_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MAC_DRTCMACP_INCFG_ConfigurationRequest_contents_data01 (c_MAC_DRTCMACP_INCFG_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_DRTCMACP_INCFG_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_MAC_DRTCMACP_INCFG_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_MAC_DRTCMACP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_DRTCMACP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_DRTCMACP_INCFG_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_MAC_DRTCMACP_INCFG_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_DRTCMACP_INCFG_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_DRTCMACP_INCFG_ConfigurationRequest_contents_data01_data */
void FREE_c_MAC_DRTCMACP_INCFG_ConfigurationRequest_contents_data01_data (c_MAC_DRTCMACP_INCFG_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_MAC_DRTCMACP_INCFG_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MAC_DRTCMACP_INCFG_ConfigurationResponse_contents_data01 (c_MAC_DRTCMACP_INCFG_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_DRTCMACP_INCFG_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_MAC_DRTCMACP_INCFG_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_MAC_DRTCMACP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_DRTCMACP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_DRTCMACP_INCFG_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_MAC_DRTCMACP_INCFG_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_DRTCMACP_INCFG_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_DRTCMACP_INCFG_ConfigurationResponse_contents_data01_data */
void FREE_c_MAC_DRTCMACP_INCFG_ConfigurationResponse_contents_data01_data (c_MAC_DRTCMACP_INCFG_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Default_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Response (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_MAC_DRTCMACP_INUSE_BroadcastReverseRateLimit_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MAC_DRTCMACP_INUSE_BroadcastReverseRateLimit_contents_data01 (c_MAC_DRTCMACP_INUSE_BroadcastReverseRateLimit_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_DRTCMACP_INUSE_BroadcastReverseRateLimit_contents_data01_data** tmp;
		tmp = (c_MAC_DRTCMACP_INUSE_BroadcastReverseRateLimit_contents_data01_data**)EDAlloc (sizeof (c_MAC_DRTCMACP_INUSE_BroadcastReverseRateLimit_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_DRTCMACP_INUSE_BroadcastReverseRateLimit_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_DRTCMACP_INUSE_BroadcastReverseRateLimit_contents_data01_data*)EDAlloc (sizeof (c_MAC_DRTCMACP_INUSE_BroadcastReverseRateLimit_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_DRTCMACP_INUSE_BroadcastReverseRateLimit_contents_data01_data));
			(sequence->data[i]->RateLimit) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_DRTCMACP_INUSE_BroadcastReverseRateLimit_contents_data01_data */
void FREE_c_MAC_DRTCMACP_INUSE_BroadcastReverseRateLimit_contents_data01_data (c_MAC_DRTCMACP_INUSE_BroadcastReverseRateLimit_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_MAC_S1RTCMACP_INCFG_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MAC_S1RTCMACP_INCFG_ConfigurationRequest_contents_data01 (c_MAC_S1RTCMACP_INCFG_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_S1RTCMACP_INCFG_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_MAC_S1RTCMACP_INCFG_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_MAC_S1RTCMACP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_S1RTCMACP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_S1RTCMACP_INCFG_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_MAC_S1RTCMACP_INCFG_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_S1RTCMACP_INCFG_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_S1RTCMACP_INCFG_ConfigurationRequest_contents_data01_data */
void FREE_c_MAC_S1RTCMACP_INCFG_ConfigurationRequest_contents_data01_data (c_MAC_S1RTCMACP_INCFG_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_MAC_S1RTCMACP_INCFG_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MAC_S1RTCMACP_INCFG_ConfigurationResponse_contents_data01 (c_MAC_S1RTCMACP_INCFG_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_S1RTCMACP_INCFG_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_MAC_S1RTCMACP_INCFG_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_MAC_S1RTCMACP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_S1RTCMACP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_S1RTCMACP_INCFG_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_MAC_S1RTCMACP_INCFG_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_S1RTCMACP_INCFG_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_S1RTCMACP_INCFG_ConfigurationResponse_contents_data01_data */
void FREE_c_MAC_S1RTCMACP_INCFG_ConfigurationResponse_contents_data01_data (c_MAC_S1RTCMACP_INCFG_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Response (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_MAC_S1RTCMACP_INUSE_BroadcastReverseRateLimit_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MAC_S1RTCMACP_INUSE_BroadcastReverseRateLimit_contents_data01 (c_MAC_S1RTCMACP_INUSE_BroadcastReverseRateLimit_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_S1RTCMACP_INUSE_BroadcastReverseRateLimit_contents_data01_data** tmp;
		tmp = (c_MAC_S1RTCMACP_INUSE_BroadcastReverseRateLimit_contents_data01_data**)EDAlloc (sizeof (c_MAC_S1RTCMACP_INUSE_BroadcastReverseRateLimit_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_S1RTCMACP_INUSE_BroadcastReverseRateLimit_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_S1RTCMACP_INUSE_BroadcastReverseRateLimit_contents_data01_data*)EDAlloc (sizeof (c_MAC_S1RTCMACP_INUSE_BroadcastReverseRateLimit_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_S1RTCMACP_INUSE_BroadcastReverseRateLimit_contents_data01_data));
			(sequence->data[i]->RateLimit) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_S1RTCMACP_INUSE_BroadcastReverseRateLimit_contents_data01_data */
void FREE_c_MAC_S1RTCMACP_INUSE_BroadcastReverseRateLimit_contents_data01_data (c_MAC_S1RTCMACP_INUSE_BroadcastReverseRateLimit_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_MAC_S1RTCMACP_INUSE_AttributeUpdateRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MAC_S1RTCMACP_INUSE_AttributeUpdateRequest_contents_data01 (c_MAC_S1RTCMACP_INUSE_AttributeUpdateRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_S1RTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data** tmp;
		tmp = (c_MAC_S1RTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data**)EDAlloc (sizeof (c_MAC_S1RTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_S1RTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_S1RTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data*)EDAlloc (sizeof (c_MAC_S1RTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_S1RTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_S1RTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data */
void FREE_c_MAC_S1RTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data (c_MAC_S1RTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Subtype_1_Reverse_Traffic_Channel_MAC_Protocol_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_MAC_S3RTCMACP_INCFG_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MAC_S3RTCMACP_INCFG_ConfigurationRequest_contents_data01 (c_MAC_S3RTCMACP_INCFG_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_S3RTCMACP_INCFG_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_MAC_S3RTCMACP_INCFG_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_MAC_S3RTCMACP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_S3RTCMACP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_S3RTCMACP_INCFG_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_MAC_S3RTCMACP_INCFG_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_S3RTCMACP_INCFG_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_S3RTCMACP_INCFG_ConfigurationRequest_contents_data01_data */
void FREE_c_MAC_S3RTCMACP_INCFG_ConfigurationRequest_contents_data01_data (c_MAC_S3RTCMACP_INCFG_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_MAC_S3RTCMACP_INCFG_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MAC_S3RTCMACP_INCFG_ConfigurationResponse_contents_data01 (c_MAC_S3RTCMACP_INCFG_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_S3RTCMACP_INCFG_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_MAC_S3RTCMACP_INCFG_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_MAC_S3RTCMACP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_S3RTCMACP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_S3RTCMACP_INCFG_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_MAC_S3RTCMACP_INCFG_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_S3RTCMACP_INCFG_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_S3RTCMACP_INCFG_ConfigurationResponse_contents_data01_data */
void FREE_c_MAC_S3RTCMACP_INCFG_ConfigurationResponse_contents_data01_data (c_MAC_S3RTCMACP_INCFG_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Response (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_MAC_S3RTCMACP_INUSE_Request_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MAC_S3RTCMACP_INUSE_Request_contents_data01 (c_MAC_S3RTCMACP_INUSE_Request_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_S3RTCMACP_INUSE_Request_contents_data01_data** tmp;
		tmp = (c_MAC_S3RTCMACP_INUSE_Request_contents_data01_data**)EDAlloc (sizeof (c_MAC_S3RTCMACP_INUSE_Request_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_S3RTCMACP_INUSE_Request_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_S3RTCMACP_INUSE_Request_contents_data01_data*)EDAlloc (sizeof (c_MAC_S3RTCMACP_INUSE_Request_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_S3RTCMACP_INUSE_Request_contents_data01_data));
			(sequence->data[i]->MACFlowID) = 0;
			(sequence->data[i]->QueueLength) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_S3RTCMACP_INUSE_Request_contents_data01_data */
void FREE_c_MAC_S3RTCMACP_INUSE_Request_contents_data01_data (c_MAC_S3RTCMACP_INUSE_Request_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_MAC_S3RTCMACP_INUSE_Grant_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MAC_S3RTCMACP_INUSE_Grant_contents_data01 (c_MAC_S3RTCMACP_INUSE_Grant_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_S3RTCMACP_INUSE_Grant_contents_data01_data** tmp;
		tmp = (c_MAC_S3RTCMACP_INUSE_Grant_contents_data01_data**)EDAlloc (sizeof (c_MAC_S3RTCMACP_INUSE_Grant_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_S3RTCMACP_INUSE_Grant_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_S3RTCMACP_INUSE_Grant_contents_data01_data*)EDAlloc (sizeof (c_MAC_S3RTCMACP_INUSE_Grant_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_S3RTCMACP_INUSE_Grant_contents_data01_data));
			(sequence->data[i]->MACFlowID) = 0;
			(sequence->data[i]->T2PInflow) = 0;
			(sequence->data[i]->BucketLevel) = 0;
			(sequence->data[i]->TT2PHold) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_S3RTCMACP_INUSE_Grant_contents_data01_data */
void FREE_c_MAC_S3RTCMACP_INUSE_Grant_contents_data01_data (c_MAC_S3RTCMACP_INUSE_Grant_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_MAC_S3RTCMACP_INUSE_AttributeUpdateRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MAC_S3RTCMACP_INUSE_AttributeUpdateRequest_contents_data01 (c_MAC_S3RTCMACP_INUSE_AttributeUpdateRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_S3RTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data** tmp;
		tmp = (c_MAC_S3RTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data**)EDAlloc (sizeof (c_MAC_S3RTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_S3RTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_S3RTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data*)EDAlloc (sizeof (c_MAC_S3RTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_S3RTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_S3RTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data */
void FREE_c_MAC_S3RTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data (c_MAC_S3RTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Subtype_3_Reverse_Traffic_Channel_MAC_Protocol_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_MAC_MRTCMACP_INCFG_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MAC_MRTCMACP_INCFG_ConfigurationRequest_contents_data01 (c_MAC_MRTCMACP_INCFG_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_MRTCMACP_INCFG_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_MAC_MRTCMACP_INCFG_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_MAC_MRTCMACP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_MRTCMACP_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_MRTCMACP_INCFG_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_MAC_MRTCMACP_INCFG_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_MRTCMACP_INCFG_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_MRTCMACP_INCFG_ConfigurationRequest_contents_data01_data */
void FREE_c_MAC_MRTCMACP_INCFG_ConfigurationRequest_contents_data01_data (c_MAC_MRTCMACP_INCFG_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_MAC_MRTCMACP_INCFG_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MAC_MRTCMACP_INCFG_ConfigurationResponse_contents_data01 (c_MAC_MRTCMACP_INCFG_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_MRTCMACP_INCFG_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_MAC_MRTCMACP_INCFG_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_MAC_MRTCMACP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_MRTCMACP_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_MRTCMACP_INCFG_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_MAC_MRTCMACP_INCFG_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_MRTCMACP_INCFG_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Response (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_MRTCMACP_INCFG_ConfigurationResponse_contents_data01_data */
void FREE_c_MAC_MRTCMACP_INCFG_ConfigurationResponse_contents_data01_data (c_MAC_MRTCMACP_INCFG_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes_Response (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_MAC_MRTCMACP_INUSE_RTCAck_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MAC_MRTCMACP_INUSE_RTCAck_contents_data01 (c_MAC_MRTCMACP_INUSE_RTCAck_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_MRTCMACP_INUSE_RTCAck_contents_data01_data** tmp;
		tmp = (c_MAC_MRTCMACP_INUSE_RTCAck_contents_data01_data**)EDAlloc (sizeof (c_MAC_MRTCMACP_INUSE_RTCAck_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_MRTCMACP_INUSE_RTCAck_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_MRTCMACP_INUSE_RTCAck_contents_data01_data*)EDAlloc (sizeof (c_MAC_MRTCMACP_INUSE_RTCAck_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_MRTCMACP_INUSE_RTCAck_contents_data01_data));
			(sequence->data[i]->ReverseChannel.SystemType) = 0;
			(sequence->data[i]->ReverseChannel.BandClass) = 0;
			(sequence->data[i]->ReverseChannel.ChannelNumber) = 0;
			
			(sequence->data[i]->ReverseLogicalChannel) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_MRTCMACP_INUSE_RTCAck_contents_data01_data */
void FREE_c_MAC_MRTCMACP_INUSE_RTCAck_contents_data01_data (c_MAC_MRTCMACP_INUSE_RTCAck_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_MAC_MRTCMACP_INUSE_RTCAck_contents_data01_data_ReverseChannel */
void FREE_c_MAC_MRTCMACP_INUSE_RTCAck_contents_data01_data_ReverseChannel (c_MAC_MRTCMACP_INUSE_RTCAck_contents_data01_data_ReverseChannel* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_MAC_MRTCMACP_INUSE_ReverseCDMAChannelDropped_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MAC_MRTCMACP_INUSE_ReverseCDMAChannelDropped_contents_data01 (c_MAC_MRTCMACP_INUSE_ReverseCDMAChannelDropped_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_MRTCMACP_INUSE_ReverseCDMAChannelDropped_contents_data01_data** tmp;
		tmp = (c_MAC_MRTCMACP_INUSE_ReverseCDMAChannelDropped_contents_data01_data**)EDAlloc (sizeof (c_MAC_MRTCMACP_INUSE_ReverseCDMAChannelDropped_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_MRTCMACP_INUSE_ReverseCDMAChannelDropped_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_MRTCMACP_INUSE_ReverseCDMAChannelDropped_contents_data01_data*)EDAlloc (sizeof (c_MAC_MRTCMACP_INUSE_ReverseCDMAChannelDropped_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_MRTCMACP_INUSE_ReverseCDMAChannelDropped_contents_data01_data));
			(sequence->data[i]->ReverseChannel.SystemType) = 0;
			(sequence->data[i]->ReverseChannel.BandClass) = 0;
			(sequence->data[i]->ReverseChannel.ChannelNumber) = 0;
			
			(sequence->data[i]->ReasonCode) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_MRTCMACP_INUSE_ReverseCDMAChannelDropped_contents_data01_data */
void FREE_c_MAC_MRTCMACP_INUSE_ReverseCDMAChannelDropped_contents_data01_data (c_MAC_MRTCMACP_INUSE_ReverseCDMAChannelDropped_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* Free function for struct c_MAC_MRTCMACP_INUSE_ReverseCDMAChannelDropped_contents_data01_data_ReverseChannel */
void FREE_c_MAC_MRTCMACP_INUSE_ReverseCDMAChannelDropped_contents_data01_data_ReverseChannel (c_MAC_MRTCMACP_INUSE_ReverseCDMAChannelDropped_contents_data01_data_ReverseChannel* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_MAC_MRTCMACP_INUSE_Request_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MAC_MRTCMACP_INUSE_Request_contents_data01 (c_MAC_MRTCMACP_INUSE_Request_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_MRTCMACP_INUSE_Request_contents_data01_data** tmp;
		tmp = (c_MAC_MRTCMACP_INUSE_Request_contents_data01_data**)EDAlloc (sizeof (c_MAC_MRTCMACP_INUSE_Request_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_MRTCMACP_INUSE_Request_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_MRTCMACP_INUSE_Request_contents_data01_data*)EDAlloc (sizeof (c_MAC_MRTCMACP_INUSE_Request_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_MRTCMACP_INUSE_Request_contents_data01_data));
			(sequence->data[i]->MACFlowID) = 0;
			(sequence->data[i]->QueueLength) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_MRTCMACP_INUSE_Request_contents_data01_data */
void FREE_c_MAC_MRTCMACP_INUSE_Request_contents_data01_data (c_MAC_MRTCMACP_INUSE_Request_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_MAC_MRTCMACP_INUSE_Grant_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MAC_MRTCMACP_INUSE_Grant_contents_data01 (c_MAC_MRTCMACP_INUSE_Grant_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_MRTCMACP_INUSE_Grant_contents_data01_data** tmp;
		tmp = (c_MAC_MRTCMACP_INUSE_Grant_contents_data01_data**)EDAlloc (sizeof (c_MAC_MRTCMACP_INUSE_Grant_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_MRTCMACP_INUSE_Grant_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_MRTCMACP_INUSE_Grant_contents_data01_data*)EDAlloc (sizeof (c_MAC_MRTCMACP_INUSE_Grant_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_MRTCMACP_INUSE_Grant_contents_data01_data));
			(sequence->data[i]->ReverseLogicalChannel) = 0;
			(sequence->data[i]->NumMACFlows) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_MRTCMACP_INUSE_Grant_contents_data01_data */
void FREE_c_MAC_MRTCMACP_INUSE_Grant_contents_data01_data (c_MAC_MRTCMACP_INUSE_Grant_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_MAC_MRTCMACP_INUSE_Grant_contents_data02'. Existing items are not changed. */
int SETITEMS_c_MAC_MRTCMACP_INUSE_Grant_contents_data02 (c_MAC_MRTCMACP_INUSE_Grant_contents_data02* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_MRTCMACP_INUSE_Grant_contents_data02_data** tmp;
		tmp = (c_MAC_MRTCMACP_INUSE_Grant_contents_data02_data**)EDAlloc (sizeof (c_MAC_MRTCMACP_INUSE_Grant_contents_data02_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_MRTCMACP_INUSE_Grant_contents_data02_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_MRTCMACP_INUSE_Grant_contents_data02_data*)EDAlloc (sizeof (c_MAC_MRTCMACP_INUSE_Grant_contents_data02_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_MRTCMACP_INUSE_Grant_contents_data02_data));
			(sequence->data[i]->MACFlowID) = 0;
			(sequence->data[i]->T2PInflow) = 0;
			(sequence->data[i]->BucketLevel) = 0;
			(sequence->data[i]->TT2PHold) = 0;
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_MRTCMACP_INUSE_Grant_contents_data02_data */
void FREE_c_MAC_MRTCMACP_INUSE_Grant_contents_data02_data (c_MAC_MRTCMACP_INUSE_Grant_contents_data02_data* sp) {
ED_WARNING_REMOVER(sp);

}

/* SETITEMS commands for type 'c_MAC_MRTCMACP_INUSE_AttributeUpdateRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_MAC_MRTCMACP_INUSE_AttributeUpdateRequest_contents_data01 (c_MAC_MRTCMACP_INUSE_AttributeUpdateRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_MAC_MRTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data** tmp;
		tmp = (c_MAC_MRTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data**)EDAlloc (sizeof (c_MAC_MRTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_MAC_MRTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_MAC_MRTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data*)EDAlloc (sizeof (c_MAC_MRTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_MAC_MRTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_MAC_MRTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data */
void FREE_c_MAC_MRTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data (c_MAC_MRTCMACP_INUSE_AttributeUpdateRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Multicarrier_Reverse_Traffic_Channel_MAC_Protocol_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_PHYS01_DS0S1PLPI_INCFG_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_PHYS01_DS0S1PLPI_INCFG_ConfigurationRequest_contents_data01 (c_PHYS01_DS0S1PLPI_INCFG_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_PHYS01_DS0S1PLPI_INCFG_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_PHYS01_DS0S1PLPI_INCFG_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_PHYS01_DS0S1PLPI_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_PHYS01_DS0S1PLPI_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_PHYS01_DS0S1PLPI_INCFG_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_PHYS01_DS0S1PLPI_INCFG_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_PHYS01_DS0S1PLPI_INCFG_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeRecord.Length) = 0;
			(sequence->data[i]->AttributeRecord.AttributeID) = 0;
			sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
			sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
			
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->AttributeRecord.AttributeValue.value != NULL) {
					EDFree (sequence->data[i]->AttributeRecord.AttributeValue.value);
					sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
				}
				sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_PHYS01_DS0S1PLPI_INCFG_ConfigurationRequest_contents_data01_data */
void FREE_c_PHYS01_DS0S1PLPI_INCFG_ConfigurationRequest_contents_data01_data (c_PHYS01_DS0S1PLPI_INCFG_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeRecord.AttributeValue.value != NULL) {
		EDFree (sp->AttributeRecord.AttributeValue.value);
		sp->AttributeRecord.AttributeValue.value = NULL;
	}
	sp->AttributeRecord.AttributeValue.usedBits = 0;

}

/* Free function for struct c_PHYS01_DS0S1PLPI_INCFG_ConfigurationRequest_contents_data01_data_AttributeRecord */
void FREE_c_PHYS01_DS0S1PLPI_INCFG_ConfigurationRequest_contents_data01_data_AttributeRecord (c_PHYS01_DS0S1PLPI_INCFG_ConfigurationRequest_contents_data01_data_AttributeRecord* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeValue.value != NULL) {
		EDFree (sp->AttributeValue.value);
		sp->AttributeValue.value = NULL;
	}
	sp->AttributeValue.usedBits = 0;

}

/* SETITEMS commands for type 'c_PHYS01_DS0S1PLPI_INCFG_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_PHYS01_DS0S1PLPI_INCFG_ConfigurationResponse_contents_data01 (c_PHYS01_DS0S1PLPI_INCFG_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_PHYS01_DS0S1PLPI_INCFG_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_PHYS01_DS0S1PLPI_INCFG_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_PHYS01_DS0S1PLPI_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_PHYS01_DS0S1PLPI_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_PHYS01_DS0S1PLPI_INCFG_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_PHYS01_DS0S1PLPI_INCFG_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_PHYS01_DS0S1PLPI_INCFG_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeRecord.Length) = 0;
			(sequence->data[i]->AttributeRecord.AttributeID) = 0;
			sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
			sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
			
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->AttributeRecord.AttributeValue.value != NULL) {
					EDFree (sequence->data[i]->AttributeRecord.AttributeValue.value);
					sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
				}
				sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_PHYS01_DS0S1PLPI_INCFG_ConfigurationResponse_contents_data01_data */
void FREE_c_PHYS01_DS0S1PLPI_INCFG_ConfigurationResponse_contents_data01_data (c_PHYS01_DS0S1PLPI_INCFG_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeRecord.AttributeValue.value != NULL) {
		EDFree (sp->AttributeRecord.AttributeValue.value);
		sp->AttributeRecord.AttributeValue.value = NULL;
	}
	sp->AttributeRecord.AttributeValue.usedBits = 0;

}

/* Free function for struct c_PHYS01_DS0S1PLPI_INCFG_ConfigurationResponse_contents_data01_data_AttributeRecord */
void FREE_c_PHYS01_DS0S1PLPI_INCFG_ConfigurationResponse_contents_data01_data_AttributeRecord (c_PHYS01_DS0S1PLPI_INCFG_ConfigurationResponse_contents_data01_data_AttributeRecord* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeValue.value != NULL) {
		EDFree (sp->AttributeValue.value);
		sp->AttributeValue.value = NULL;
	}
	sp->AttributeValue.usedBits = 0;

}

/* SETITEMS commands for type 'c_PHYS2_S2PLPI_INCFG_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_PHYS2_S2PLPI_INCFG_ConfigurationRequest_contents_data01 (c_PHYS2_S2PLPI_INCFG_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_PHYS2_S2PLPI_INCFG_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_PHYS2_S2PLPI_INCFG_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_PHYS2_S2PLPI_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_PHYS2_S2PLPI_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_PHYS2_S2PLPI_INCFG_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_PHYS2_S2PLPI_INCFG_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_PHYS2_S2PLPI_INCFG_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeRecord.Length) = 0;
			(sequence->data[i]->AttributeRecord.AttributeID) = 0;
			sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
			sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
			
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->AttributeRecord.AttributeValue.value != NULL) {
					EDFree (sequence->data[i]->AttributeRecord.AttributeValue.value);
					sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
				}
				sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_PHYS2_S2PLPI_INCFG_ConfigurationRequest_contents_data01_data */
void FREE_c_PHYS2_S2PLPI_INCFG_ConfigurationRequest_contents_data01_data (c_PHYS2_S2PLPI_INCFG_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeRecord.AttributeValue.value != NULL) {
		EDFree (sp->AttributeRecord.AttributeValue.value);
		sp->AttributeRecord.AttributeValue.value = NULL;
	}
	sp->AttributeRecord.AttributeValue.usedBits = 0;

}

/* Free function for struct c_PHYS2_S2PLPI_INCFG_ConfigurationRequest_contents_data01_data_AttributeRecord */
void FREE_c_PHYS2_S2PLPI_INCFG_ConfigurationRequest_contents_data01_data_AttributeRecord (c_PHYS2_S2PLPI_INCFG_ConfigurationRequest_contents_data01_data_AttributeRecord* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeValue.value != NULL) {
		EDFree (sp->AttributeValue.value);
		sp->AttributeValue.value = NULL;
	}
	sp->AttributeValue.usedBits = 0;

}

/* SETITEMS commands for type 'c_PHYS2_S2PLPI_INCFG_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_PHYS2_S2PLPI_INCFG_ConfigurationResponse_contents_data01 (c_PHYS2_S2PLPI_INCFG_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_PHYS2_S2PLPI_INCFG_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_PHYS2_S2PLPI_INCFG_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_PHYS2_S2PLPI_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_PHYS2_S2PLPI_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_PHYS2_S2PLPI_INCFG_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_PHYS2_S2PLPI_INCFG_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_PHYS2_S2PLPI_INCFG_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeRecord.Length) = 0;
			(sequence->data[i]->AttributeRecord.AttributeID) = 0;
			sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
			sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
			
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->AttributeRecord.AttributeValue.value != NULL) {
					EDFree (sequence->data[i]->AttributeRecord.AttributeValue.value);
					sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
				}
				sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_PHYS2_S2PLPI_INCFG_ConfigurationResponse_contents_data01_data */
void FREE_c_PHYS2_S2PLPI_INCFG_ConfigurationResponse_contents_data01_data (c_PHYS2_S2PLPI_INCFG_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeRecord.AttributeValue.value != NULL) {
		EDFree (sp->AttributeRecord.AttributeValue.value);
		sp->AttributeRecord.AttributeValue.value = NULL;
	}
	sp->AttributeRecord.AttributeValue.usedBits = 0;

}

/* Free function for struct c_PHYS2_S2PLPI_INCFG_ConfigurationResponse_contents_data01_data_AttributeRecord */
void FREE_c_PHYS2_S2PLPI_INCFG_ConfigurationResponse_contents_data01_data_AttributeRecord (c_PHYS2_S2PLPI_INCFG_ConfigurationResponse_contents_data01_data_AttributeRecord* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeValue.value != NULL) {
		EDFree (sp->AttributeValue.value);
		sp->AttributeValue.value = NULL;
	}
	sp->AttributeValue.usedBits = 0;

}

/* SETITEMS commands for type 'c_PHYS3_S3PLPI_INCFG_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_PHYS3_S3PLPI_INCFG_ConfigurationRequest_contents_data01 (c_PHYS3_S3PLPI_INCFG_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_PHYS3_S3PLPI_INCFG_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_PHYS3_S3PLPI_INCFG_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_PHYS3_S3PLPI_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_PHYS3_S3PLPI_INCFG_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_PHYS3_S3PLPI_INCFG_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_PHYS3_S3PLPI_INCFG_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_PHYS3_S3PLPI_INCFG_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_PHYS3_S3PLPI_INCFG_ConfigurationRequest_contents_data01_data */
void FREE_c_PHYS3_S3PLPI_INCFG_ConfigurationRequest_contents_data01_data (c_PHYS3_S3PLPI_INCFG_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_PHYS3_S3PLPI_INCFG_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_PHYS3_S3PLPI_INCFG_ConfigurationResponse_contents_data01 (c_PHYS3_S3PLPI_INCFG_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_PHYS3_S3PLPI_INCFG_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_PHYS3_S3PLPI_INCFG_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_PHYS3_S3PLPI_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_PHYS3_S3PLPI_INCFG_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_PHYS3_S3PLPI_INCFG_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_PHYS3_S3PLPI_INCFG_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_PHYS3_S3PLPI_INCFG_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_Response (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_Response (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_PHYS3_S3PLPI_INCFG_ConfigurationResponse_contents_data01_data */
void FREE_c_PHYS3_S3PLPI_INCFG_ConfigurationResponse_contents_data01_data (c_PHYS3_S3PLPI_INCFG_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes_Response (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_PHYS3_S3PLPI_INUSE_AttributeUpdateRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_PHYS3_S3PLPI_INUSE_AttributeUpdateRequest_contents_data01 (c_PHYS3_S3PLPI_INUSE_AttributeUpdateRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_PHYS3_S3PLPI_INUSE_AttributeUpdateRequest_contents_data01_data** tmp;
		tmp = (c_PHYS3_S3PLPI_INUSE_AttributeUpdateRequest_contents_data01_data**)EDAlloc (sizeof (c_PHYS3_S3PLPI_INUSE_AttributeUpdateRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_PHYS3_S3PLPI_INUSE_AttributeUpdateRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_PHYS3_S3PLPI_INUSE_AttributeUpdateRequest_contents_data01_data*)EDAlloc (sizeof (c_PHYS3_S3PLPI_INUSE_AttributeUpdateRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_PHYS3_S3PLPI_INUSE_AttributeUpdateRequest_contents_data01_data));
			(sequence->data[i]->AttributeLength) = 0;
			INIT_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes (&(sequence->data[i]->AttributeRecord));
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				FREE_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes (&(sequence->data[i]->AttributeRecord));
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_PHYS3_S3PLPI_INUSE_AttributeUpdateRequest_contents_data01_data */
void FREE_c_PHYS3_S3PLPI_INUSE_AttributeUpdateRequest_contents_data01_data (c_PHYS3_S3PLPI_INUSE_AttributeUpdateRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	FREE_c_Air_Subtype_3_Physical_Layer_Protocol_Instance_Attributes (&(sp->AttributeRecord));

}

/* SETITEMS commands for type 'c_GEN_GCP_ConfigurationRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_GEN_GCP_ConfigurationRequest_contents_data01 (c_GEN_GCP_ConfigurationRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_GEN_GCP_ConfigurationRequest_contents_data01_data** tmp;
		tmp = (c_GEN_GCP_ConfigurationRequest_contents_data01_data**)EDAlloc (sizeof (c_GEN_GCP_ConfigurationRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_GEN_GCP_ConfigurationRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_GEN_GCP_ConfigurationRequest_contents_data01_data*)EDAlloc (sizeof (c_GEN_GCP_ConfigurationRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_GEN_GCP_ConfigurationRequest_contents_data01_data));
			(sequence->data[i]->AttributeRecord.Length) = 0;
			(sequence->data[i]->AttributeRecord.AttributeID) = 0;
			sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
			sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
			
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->AttributeRecord.AttributeValue.value != NULL) {
					EDFree (sequence->data[i]->AttributeRecord.AttributeValue.value);
					sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
				}
				sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_GEN_GCP_ConfigurationRequest_contents_data01_data */
void FREE_c_GEN_GCP_ConfigurationRequest_contents_data01_data (c_GEN_GCP_ConfigurationRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeRecord.AttributeValue.value != NULL) {
		EDFree (sp->AttributeRecord.AttributeValue.value);
		sp->AttributeRecord.AttributeValue.value = NULL;
	}
	sp->AttributeRecord.AttributeValue.usedBits = 0;

}

/* Free function for struct c_GEN_GCP_ConfigurationRequest_contents_data01_data_AttributeRecord */
void FREE_c_GEN_GCP_ConfigurationRequest_contents_data01_data_AttributeRecord (c_GEN_GCP_ConfigurationRequest_contents_data01_data_AttributeRecord* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeValue.value != NULL) {
		EDFree (sp->AttributeValue.value);
		sp->AttributeValue.value = NULL;
	}
	sp->AttributeValue.usedBits = 0;

}

/* SETITEMS commands for type 'c_GEN_GCP_ConfigurationResponse_contents_data01'. Existing items are not changed. */
int SETITEMS_c_GEN_GCP_ConfigurationResponse_contents_data01 (c_GEN_GCP_ConfigurationResponse_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_GEN_GCP_ConfigurationResponse_contents_data01_data** tmp;
		tmp = (c_GEN_GCP_ConfigurationResponse_contents_data01_data**)EDAlloc (sizeof (c_GEN_GCP_ConfigurationResponse_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_GEN_GCP_ConfigurationResponse_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_GEN_GCP_ConfigurationResponse_contents_data01_data*)EDAlloc (sizeof (c_GEN_GCP_ConfigurationResponse_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_GEN_GCP_ConfigurationResponse_contents_data01_data));
			(sequence->data[i]->AttributeRecord.Length) = 0;
			(sequence->data[i]->AttributeRecord.AttributeID) = 0;
			sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
			sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
			
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->AttributeRecord.AttributeValue.value != NULL) {
					EDFree (sequence->data[i]->AttributeRecord.AttributeValue.value);
					sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
				}
				sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_GEN_GCP_ConfigurationResponse_contents_data01_data */
void FREE_c_GEN_GCP_ConfigurationResponse_contents_data01_data (c_GEN_GCP_ConfigurationResponse_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeRecord.AttributeValue.value != NULL) {
		EDFree (sp->AttributeRecord.AttributeValue.value);
		sp->AttributeRecord.AttributeValue.value = NULL;
	}
	sp->AttributeRecord.AttributeValue.usedBits = 0;

}

/* Free function for struct c_GEN_GCP_ConfigurationResponse_contents_data01_data_AttributeRecord */
void FREE_c_GEN_GCP_ConfigurationResponse_contents_data01_data_AttributeRecord (c_GEN_GCP_ConfigurationResponse_contents_data01_data_AttributeRecord* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeValue.value != NULL) {
		EDFree (sp->AttributeValue.value);
		sp->AttributeValue.value = NULL;
	}
	sp->AttributeValue.usedBits = 0;

}

/* SETITEMS commands for type 'c_GEN_GAUP_AttributeUpdateRequest_contents_data01'. Existing items are not changed. */
int SETITEMS_c_GEN_GAUP_AttributeUpdateRequest_contents_data01 (c_GEN_GAUP_AttributeUpdateRequest_contents_data01* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		c_GEN_GAUP_AttributeUpdateRequest_contents_data01_data** tmp;
		tmp = (c_GEN_GAUP_AttributeUpdateRequest_contents_data01_data**)EDAlloc (sizeof (c_GEN_GAUP_AttributeUpdateRequest_contents_data01_data*) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (c_GEN_GAUP_AttributeUpdateRequest_contents_data01_data*) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			sequence->data[i] = (c_GEN_GAUP_AttributeUpdateRequest_contents_data01_data*)EDAlloc (sizeof (c_GEN_GAUP_AttributeUpdateRequest_contents_data01_data));
			ED_RESET_MEM (sequence->data[i], sizeof (c_GEN_GAUP_AttributeUpdateRequest_contents_data01_data));
			(sequence->data[i]->AttributeRecord.Length) = 0;
			(sequence->data[i]->AttributeRecord.AttributeID) = 0;
			sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
			sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
			
			
		}
	}
	 else {
		for (i=desiredItems; i<sequence->items; i++) {
				if (sequence->data[i]->AttributeRecord.AttributeValue.value != NULL) {
					EDFree (sequence->data[i]->AttributeRecord.AttributeValue.value);
					sequence->data[i]->AttributeRecord.AttributeValue.value = NULL;
				}
				sequence->data[i]->AttributeRecord.AttributeValue.usedBits = 0;
				EDFree (sequence->data[i]);
				sequence->data[i] = NULL;
			}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* Free function for struct c_GEN_GAUP_AttributeUpdateRequest_contents_data01_data */
void FREE_c_GEN_GAUP_AttributeUpdateRequest_contents_data01_data (c_GEN_GAUP_AttributeUpdateRequest_contents_data01_data* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeRecord.AttributeValue.value != NULL) {
		EDFree (sp->AttributeRecord.AttributeValue.value);
		sp->AttributeRecord.AttributeValue.value = NULL;
	}
	sp->AttributeRecord.AttributeValue.usedBits = 0;

}

/* Free function for struct c_GEN_GAUP_AttributeUpdateRequest_contents_data01_data_AttributeRecord */
void FREE_c_GEN_GAUP_AttributeUpdateRequest_contents_data01_data_AttributeRecord (c_GEN_GAUP_AttributeUpdateRequest_contents_data01_data_AttributeRecord* sp) {
ED_WARNING_REMOVER(sp);
	if (sp->AttributeValue.value != NULL) {
		EDFree (sp->AttributeValue.value);
		sp->AttributeValue.value = NULL;
	}
	sp->AttributeValue.usedBits = 0;

}

/* SETITEMS commands for type 'c_Air_Attribute_Response_16_ValueIDs'. Existing items are not changed. */
int SETITEMS_c_Air_Attribute_Response_16_ValueIDs (c_Air_Attribute_Response_16_ValueIDs* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		ED_LONG* tmp;
		tmp = (ED_LONG*)EDAlloc (sizeof (ED_LONG) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (ED_LONG) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			(sequence->data[i]) = 0;
		}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

/* SETITEMS commands for type 'c_Air_Attribute_Response_8_ValueIDs'. Existing items are not changed. */
int SETITEMS_c_Air_Attribute_Response_8_ValueIDs (c_Air_Attribute_Response_8_ValueIDs* sequence, int desiredItems)
{
	int i;
	/* ALK-UNI */
	if (sequence->allocatedItems < desiredItems) {
		int newSize = desiredItems + 0;
		ED_LONG* tmp;
		tmp = (ED_LONG*)EDAlloc (sizeof (ED_LONG) * (size_t)(newSize));
		if (sequence->data) {
			if (tmp != NULL && sequence->items > 0) {
				memcpy (tmp, sequence->data, sizeof (ED_LONG) * (size_t)sequence->items);
			}
			EDFree (sequence->data);
		}
		sequence->allocatedItems = newSize;
		sequence->data = tmp;
	
	}

	if (desiredItems > sequence->items) {
		for (i=sequence->items; i<desiredItems; i++) {
			(sequence->data[i]) = 0;
		}
	}

	sequence->items = desiredItems;
	return ED_NO_ERRORS;
}

